#!/usr/bin/python
from __future__ import print_function
import sys, argparse, re
import xml.etree.ElementTree as e
from collections import OrderedDict

def warning(*objs):
    print("WARNING: ", *objs, file=sys.stderr)

def error(*objs):
    print('#error ',*objs)
    print("ERROR: ", *objs, file=sys.stderr)

def modeldescription2header(args_xml, args_wrapper, file=sys.stdout):
  print('''/*This file is genereted by modeldescription2header. DO NOT EDIT! */''', file=file)

  tree = e.parse(args_xml)
  root = tree.getroot()

  # Get FMU version
  fmiVersion = root.get('fmiVersion')
  ni = root.get('numberOfEventIndicators')
  if ni == None:
      ni = '0'

  # Get model identifier.
  csFmuType = False
  meFmuType = False

  modelIdentifier = "modelIdentifier"
  providesDirectionalDerivative = False
  canGetAndSetFMUstate = False

  if fmiVersion == "1.0":
      modelIdentifier = root.get('modelIdentifier')
      providesDirectionalDerivative = root.get('providesDirectionalDerivative') == "true"
  elif fmiVersion == "2.0":
      me = root.find('ModelExchange')
      cs = root.find('CoSimulation')
      csFmuType = cs != None
      meFmuType = me != None

      if cs != None:
          modelIdentifier = cs.get('modelIdentifier')
          providesDirectionalDerivative = cs.get('providesDirectionalDerivative') == "true"
          canGetAndSetFMUstate = cs.get('canGetAndSetFMUstate') == "true"
      elif me != None:
          modelIdentifier = me.get('modelIdentifier')
          providesDirectionalDerivative = me.get('providesDirectionalDerivative') == "true"
          canGetAndSetFMUstate = me.get('canGetAndSetFMUstate') == "true"
      else:
          warning('FMU is neither ModelExchange or CoSimulation')
          exit(1)


  reals = OrderedDict()
  ints  = OrderedDict()
  bools = OrderedDict()
  states = OrderedDict()
  derivatives = OrderedDict()

  SV = root.find('ModelVariables').findall('ScalarVariable')
  strs  = OrderedDict()

  vas = root.find('VendorAnnotations')
  fmuFilename = None
  if vas != None:
      for tool in vas.findall('Tool'):
          if tool.attrib['name'] == 'fmigo':
              fmuFilename = tool.find('fmu').text

  for sv in SV:
      # Make names C compatible
      name = ''.join([c if re.match('[a-zA-Z0-9]', c) else '_' for c in sv.attrib['name']])
      if re.match('[0-9]', name[0]):
          name = '_'+name

      vr = int(sv.attrib['valueReference'])

      if name in reals.values() or name in ints.values() or name in bools.values() or name in strs.values():
          error(args_xml +' contains multiple variables named "' + name + '"!')
          exit(1)

      fmigo_tool = None
      if sv.find('Annotations') != None:
          for tool in sv.find('Annotations').findall('Tool'):
              if tool.attrib['name'] == 'fmigo':
                  fmigo_tool = tool

      # When wrapping we only really need the the variables that xml2wrappedxml.py adds,
      # plus some minor things like NUMBER_OF_REALS.
      # The logic relating to should_output keeps the generated modelDescription_t minimal.
      # It also prevents problems when dealing with ME FMUs generated by Dymola,
      # since they can contain multiple ScalarVariable entries with non-unique (type,VR) entries.
      # This is OK in certain cases, but rather than dealing with them here we just minimize
      # the amount of generated code and pass the relevant fmi2GetX/SetX commands in wrapper.c.
      should_output = not args_wrapper or fmigo_tool != None

      R = sv.find('Real')
      I = sv.find('Integer')
      E = sv.find('Enumeration')
      B = sv.find('Boolean')
      S = sv.find('String')

      if R != None:
          if vr in reals and should_output:
              error(args_xml +' contains multiple Reals with VR='+str(vr))
              exit(1)
          start = float(R.attrib['start']) if 'start' in R.attrib else 0
          if meFmuType:
              if 'derivative' in R.attrib:
                  states[vr] = (SV[int(R.attrib['derivative']) - 1].attrib['name'], start)
                  derivatives[vr] = name
          reals[vr] = (name, start, should_output)

      elif I != None or E != None:
          if vr in ints and should_output:
              error(args_xml + ' contains multiple Integers/Enums with VR='+str(vr))
              exit(1)
          IE = I if I != None else E
          start = int(IE.attrib['start']) if 'start' in IE.attrib else 0
          ints[vr] = (name, start, should_output)
      elif B != None:
          if vr in bools and should_output:
              error(args_xml + ' contains multiple Booleans with VR='+str(vr))
              exit(1)
          start = B.attrib['start'] if 'start' in B.attrib else '0'
          bools[vr] = (name, 1 if start == '1' or start == 'true' else 0, should_output)
      elif S != None:
          if vr in strs and should_output:
              error(args_xml + ' contains multiple Strings with VR='+str(vr))
              exit(1)
          start = S.attrib['start'] if 'start' in S.attrib else ''
          size = None
          if fmigo_tool != None:
              sz = fmigo_tool.find('size')
              size = int(sz.text)

          if size == None:
              error('''String variable "%s" missing size. Use an "fmigo" Annotation to specify maximum size, like this:
  <ScalarVariable ...>
    <String start="..."/>
    <Annotations>
      <Tool name="fmigo">
        <size>1024</size>
      </Tool>
    </Annotations>
  </ScalarVariable>''' % name)
              exit(1)
          strs[vr] = (name, start, should_output, size)
      else:
          error('Variable "%s" has unknown/unsupported type' % name)
          exit(1)

  print('''#ifndef MODELDESCRIPTION_H
#define MODELDESCRIPTION_H
#include "FMI2/fmi2Functions.h" //for fmi2Real etc.
#include "strlcpy.h" //for strlcpy()

#define MODEL_IDENTIFIER %s
#define MODEL_GUID "%s"
%s
#define HAVE_DIRECTIONAL_DERIVATIVE %i
#define CAN_GET_SET_FMU_STATE %i
#define NUMBER_OF_REALS %i
#define NUMBER_OF_INTEGERS %i
#define NUMBER_OF_BOOLEANS %i
#define NUMBER_OF_STRINGS %i
#define NUMBER_OF_STATES %i
#define NUMBER_OF_EVENT_INDICATORS %s

//will be defined in fmuTemplate.h
//needed in generated_fmi2GetX/fmi2SetX for wrapper.c
struct ModelInstance;
''' % (
      modelIdentifier,
      root.get('guid'),
      '#define FMI_COSIMULATION' if csFmuType else
      '#define FMI_MODELEXCHANGE' if meFmuType else '',
      1 if providesDirectionalDerivative else 0,
      1 if canGetAndSetFMUstate else 0,
      len(reals),
      len(ints),
      len(bools),
      len(strs),
      len(states),
      ni,
  ), file=file)

  print('''
#define HAVE_MODELDESCRIPTION_STRUCT
typedef struct {
%s
%s
%s
%s%s
} modelDescription_t;
''' % (
      '\n'.join(['    fmi2Real    %s; //VR=%s' % (value[0], str(key)) for key,value in reals.items() if value[2]]),
      '\n'.join(['    fmi2Integer %s; //VR=%s' % (value[0], str(key)) for key,value in ints.items() if value[2]]),
      '\n'.join(['    fmi2Boolean %s; //VR=%s' % (value[0], str(key)) for key,value in bools.items() if value[2]]),
      '\n'.join(['    fmi2Char    %s[%i]; //VR=%s' % (value[0], value[3], str(key)) for key,value in strs.items() if value[2]]),
      '\n    fmi2Boolean dirty;' if meFmuType else '',
  ), file=file)

  print('''
#define HAVE_DEFAULTS
static const modelDescription_t defaults = {
%s
%s
%s
%s%s
};
''' % (
      '\n'.join(['    %f, //%s' % (value[1], value[0]) for key,value in reals.items() if value[2]]),
      '\n'.join(['    %i, //%s' % (value[1], value[0]) for key,value in ints.items() if value[2]]),
      '\n'.join(['    %i, //%s' % (value[1], value[0]) for key,value in bools.items() if value[2]]),
      '\n'.join(['    "%s", //%s' % (value[1], value[0]) for key,value in strs.items() if value[2]]),
      '\n    1,' if meFmuType else '',
  ), file=file)

  if fmuFilename:
      print('static const char fmuFilename[] = "%s";' % fmuFilename, file=file)

  print('''
%s
%s
%s
%s''' % (
      '\n'.join(['#define VR_'+value[0].upper()+' '+str(key) for key,value in reals.items() if value[2]]),
      '\n'.join(['#define VR_'+value[0].upper()+' '+str(key) for key,value in ints.items() if value[2]]),
      '\n'.join(['#define VR_'+value[0].upper()+' '+str(key) for key,value in bools.items() if value[2]]),
      '\n'.join(['#define VR_'+value[0].upper()+' '+str(key) for key,value in strs.items() if value[2]]),
  ), file=file)

  if not args_wrapper:
      print('''
//the following getters and setters are static to avoid getting linking errors if this file is included in more than one place

#define HAVE_GENERATED_GETTERS_SETTERS  //for letting the template know that we have our own getters and setters
''', file=file)

  if meFmuType:
      print('''
#define STATES { %s }
#define DERIVATIVES { %s }
''' % (
      ', '.join(['VR_'+value[0].upper() for key,value in states.items()]),
      ', '.join(['VR_'+value.upper() for key,value in derivatives.items()]),
      ), file=file)
      print('static void update_all(modelDescription_t *md);', file=file)

  def gen_getters_setters(t, d):
      print('''
static fmi2Status generated_fmi2Get%s(struct ModelInstance *comp, %smodelDescription_t *md, const fmi2ValueReference vr[], size_t nvr, fmi2%s value[]) {
    size_t i;%s

    for (i = 0; i < nvr; i++) {
        switch (vr[i]) {
%s
        default: return fmi2Error;
        }
    }
    return fmi2OK;
}

static fmi2Status generated_fmi2Set%s(struct ModelInstance *comp, modelDescription_t *md, const fmi2ValueReference vr[], size_t nvr, const fmi2%s value[]) {
    size_t i;%s

    for (i = 0; i < nvr; i++) {
        switch (vr[i]) {
%s
        default: return fmi2Error;
        }
    }
    return fmi2OK;
}''' % (
          t,
          'const ' if csFmuType else '' ,
          t,
          '\n    if (md->dirty){\n        update_all(md);\n        md->dirty = 0;\n    }' if meFmuType else '',
          '\n'.join(['        case %i: value[i] = md->%s; break;' % (key, value[0]) for key,value in d.items()]),
          t,t,
          '\n    md->dirty = 1;\n' if meFmuType else '',
          # A bit convoluted maybe, but it works.
          # This makes sure settings strings larger than the FMU can handle results in an error, not a crash
          '\n'.join(['        case %i: if (strlcpy(md->%s, value[i], sizeof(md->%s)) >= sizeof(md->%s)) { return fmi2Error; } break;' %
                                                    (key, value[0], value[0], value[0]) for key,value in d.items()]) if t == 'String' else
          '\n'.join(['        case %i: md->%s = value[i]; break;' % (key, value[0]) for key,value in d.items()]),
      ), file=file)

  if not args_wrapper:
      gen_getters_setters('Real',    reals)
      gen_getters_setters('Integer', ints)
      gen_getters_setters('Boolean', bools)
      gen_getters_setters('String',  strs)

  print('#endif //MODELDESCRIPTION_H', file=file)

if __name__ == '__main__':
  parser = argparse.ArgumentParser(
      description='Transforms modelDescription.xml to stdout (pipe to sources/modelDescription.h)',
  )

  parser.add_argument('xml',
                      type=str,
                      help='Path to modelDescription.xml',
                      )
  parser.add_argument('-w','--wrapper',
                      dest='wrapper',
                      action='store_true',
                      help='Generate wrapping fmi2SetX/fmi2GetX',
                      )
  parser.set_defaults(wrapper=False)

  if len(sys.argv) < 2:
    print('USAGE: '+sys.argv[0] +' modelDescription-filename > header-filename', file=sys.stderr)
    print('Example: '+sys.argv[0]+' modelDescription.xml > header.h', file=sys.stderr)
    exit(1)

  # Parse xml file
  args = parser.parse_args()

  modeldescription2header(args.xml, args.wrapper)
