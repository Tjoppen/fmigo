.TH FmiGo 1 local
.SH NAME
.I fmigo-master
- connect to FMUs served by
.I fmigo-server
over TCP/IP
.br
.I fmigo-server
- serve FMU over TCP/IP
.br
.I fmigo-mpi
- runs FMUs in an MPI cluster

.SH SYNOPSIS (TCP/IP)
.B fmigo-master
.RB [ " \-rlhtcdsopfmgwC5NMazZLHDe " ]
[
.I "URLs \&..."
]
.br
.B fmigo-server --port PORT
.I FMUFILENAME
.br

.SH SYNOPSIS (MPI)
.B mpiexec -np 1 fmigo-mpi [arguments]
: -np 1 fmigo-mpi
.I FMUFILENAME
[
: -np 1 fmigo-mpi
.I FMUFILENAME
[
: ...
]
]
.br
.B mpiexec -np (num_fmus+1) fmigo-mpi [arguments]
[
.I "FMUFILENAMEs \&..."
]
.br

.SH DESCRIPTION
FmiGo simulates FMUs using the FMILibrary from JModelica.org
over TCP/IP, with optional strong coupling between simulation units.
Communication over MPI is also possible.

.SH TCP/IP
TCP/IP communication is handled by ZeroMQ.
Serialization is done via libprotobuf.
FmiGo uses a master/server architecture,
with a central node 
(
.I fmigo-master
)
connecting to a number of servers
(
.I fmigo-server
)
, each of which serve a single FMU.
See synopsis for syntax.

.SH URLs
Each URL specifies the address and TCP port of an FMU server. The syntax is:

    tcp://<address>:<port>

Examples:

    tcp://localhost:3000
    tcp://192.168.0.2:3000

.SH MPI
The MPI version of FmiGo uses a structure similar to the TCP/IP version,
but with only a single executable. The MPI world consists of a master node (rank 0) and server nodes (rank 1..N).
For N FMUs the world size must be N+1.
A simple system with two FMUs and a weak connection from FMU0 variable x to FMU1 variable y looks like this:

.B
    mpiexec -np 1 fmigo-mpi -c 0,x,1,y \\
.B
        : -np 1 fmigo-mpi fmu0.fmu \\
.B
        : -np 1 fmigo-mpi fmu1.fmu


Keep in mind that FMU indices in connections and parameters are still zero based, even if the FMU server nodes begin at rank 1.
The MPI ranks do not change the master argument syntax.

If you want multiple copies of one FMU you can increase the -np argument instead of adding more lines to the command line:

.B
    mpiexec -np 1 fmigo-mpi -c 0,x,1,y \\
.B
        : -np 2 fmigo-mpi fmu01.fmu


There is also an alternative syntax which produces shorter command lines but require computing the total number of nodes (N FMUs + 1):

.B
    mpiexec -np 3 fmigo-mpi -c 0,x,1,y fmu0.fmu fmu1.fmu

.SH FLAGS
.TP
.B \-h
Show help and quit.
.TP
.B \-r
Real time mode. Will usleep() in between communication steps if the execution was faster than real time.
.TP
.B \-N
Make kinematic connectors nonholonomic rather than holonomic.
In other words, only lock spatial/angular velocities, not positions or angles.
.TP
.B \-Z
Start master in paused state.
Use ZMQ "unpause" command to start simulation.
Requires -z.
.TP
.B \-L
Solve algebraic loops in initialization mode. Requires GPL and GNU GSL.
.TP
.B \-H
Print CSV header.
.TP
.B \-D
Always compute numerical directional derivatives, regardless of the value of providesDirectionalDerivatives in all FMUs' modelDescription.xml.
This is useful for kinematic coupling if one or more FMUs have a spring-damper type input.
Such FMUs would give a much too high mobility estimate, unless the timestep is taken into account somehow.
This is exactly what the numerical directional derivative code does, hence this flag.
.TP
.B \-e
Print some preprocessor variables suitable for "export", to stdout, then quit.
This is useful for figuring out at runtime how fmigo was configured.
Example cmake -DUSE_GPL=0:

    $ fmigo-mpi -e
    USE_MPI=1
    USE_GPL=0
    $ fmigo-master -e
    USE_MPI=0
    USE_GPL=0

Example of passing to export for further script use:

    $ for e in $(fmigo-mpi -e); do export "$e"; done
    $ echo "The value of USE_GPL is $USE_GPL"
    The value of USE_GPL is 0

.SH OPTIONS
First note that some options specify lists of values.
These can either be specified as colon separated lists (like "-w 0:1:0") in one long option, or multiple times for each one ("-w 0 -w 1 -w 0"), or any combination of the two ("-w 0 -w 1:0").
This is convenient when building command lines in script, especially when lengthy strong connection specifications (-C) are involved. 
.TP
.B \-l [0..7]
Set FMILibrary log level. Levels are as follows:

    0 = nothing     (default)
    1 = fatal       Unrecoverable errors
    2 = error       Errors that may be not critical for some FMUs
    3 = warning     Non-critical issues
    4 = info        Informative messages
    5 = verbose     Verbose messages
    6 = debug       Debug messages. Only enabled if FMILibrary is configured with FMILIB_ENABLE_LOG_LEVEL_DEBUG and FmiGo is compiled in Debug mode
    7 = all

.TP
.B \-w [VISIBILITIES]
Visibility specification list. Specifies which FMUs should show their simulator application windows. Syntax is

    -w VIS0:VIS1:VIS2...

where VISX is 1 or 0 depending on whether FMUX's window should be shown or not.
Example:

    -w 0:1:1:0

which means: show simulator windows for FMU1 and FMU2, but not FMU0 or FMU3.
Note that multiple "-w"'s can be used to break up a list:

    -w 0 -w 1 -w 1 -w 0

Unlike -p, -c and -C order is significant for visibility lists. The following is *not* equivalent to the previous example:

    -w 1 -w 1 -w 0 -w 0

By default no windows are shown (batch mode).
.TP
.B \-g [STEPPING ORDER SPEC]
FMU stepping order list. Used in serial algorithms. Should be a comma separated list of FMU indices. If the list starts with 0, then the first FMU will be stepped, and its output values will be transferred through their connections (if any).
Example:

    -g 0,2,1

Which means: step FMU0 -> FMU2 -> FMU1.
Like other lists stepping order lists can also be broken up. This is equivalent to the previous example:

    -g 0 -g 2 -g 1

Order is significant, just like visibility lists. If no -g is specified then FMUs are stepped in numerical order (FMU0 -> FMU1 -> FMU2 etc.).
.TP
.B \-c [WEAK CONNECTIONS]
Weak connection specification list. Represents which FMU and value reference to connect from and what to connect to. Syntax is

    -c WCONN1:WCONN2:WCONN3...

where the syntax of each WCONNX is one of the following:

    FMUFROM,VRFROM,FMUTO,VRTO
    FMUFROM,NAMEFROM,FMUTO,NAMETO
    TYPE,FMUFROM,VRFROM,FMUTO,VRTO
    TYPEFROM,FMUFROM,VRFROM,TYPETO,FMUTO,VRTO
    TYPEFROM,FMUFROM,VRFROM,TYPETO,FMUTO,VRTO,k,m
    FMUFROM,NAMEFROM,FMUTO,NAMETO,k,m

TYPE is a single character specifying the value type on the connection.
If TYPE is absent then the connection is assumed to be of type real, unless a NAMEs are specified (more on this further down).
Possible types:

    r - Real
    i - Integer
    b - Boolean
    s - String

FMUFROM and FMUTO are the indexes of the FMUs to read values from and to respectively.
VRFROM and VRTO are the corresponding value references. Example:

    -c 0,0,1,0:r,0,1,1,1:i,0,1,1,2

This means: connect real values FMU0 (value reference 0) to FMU1 (vr 0) and FMU0 (vr 1) to FMU1 (vr 1), and connect integer value FMU0 (vr 1) to FMU1 (vr 2).
This is a little hard to read though, so breaking connection lists with multiple "-c"'s is recommended.
Weak connections can also be specified in any order, so the following specifies the exact same set of connections:

    -c i,0,1,1,2 -c 0,1,1,1 -c r,0,0,1,0

It is possible to specify types on either side of the connection, by which type conversion may be performed.
For example:

    -c r,0,1,i,1,0 -c b,0,2,r,1,2

Means: connect FMU0 VR1 to FMU1 VR0, truncating each real to an integer.
Connect FMU0 VR2 to FMU1 VR2, converting false to 0 and true to 1.
More information on type conversion is given at the end of this section.

NAMEFROM and NAMETO are alternatives to VRFROM and VRTO.
They allow you to specify connections (and infer TYPE) by NAME rather than value reference.
It is required that the FMU has exactly one connection with any given name.
Example:

    -c 0,x_out,1,x_in

Connects variable x_out in FMU0 to variable x_in in FMU1.
Each name must have at least one non-numeric character to count as such, or the argument parser won't be able to tell what's what.

Finally k (slope) and m (intercept) are used for transforming values linearly.
They can be any real value.
This can be combined with data type conversion, for instance taking fixed point integers from one FMU,
converting them to real and scaling by 1.0/65536 before passing the resulting scaled real values to the other FMU.
This would look something like this:

    -c i,0,1,r,1,2,1.5259e-05,0
    -c 0,some_integer,1,some_real,1.5259e-05,0

Before transformation every type is converted to real.
This conversion follows C conventions.
Strings or enums may not be converted, in any direction.
The converted real values (x) are scaled and offset by k and m respectively:

    y = k*x + m

The resulting values (y) are then converted to the target type.
For reals no further conversion is required.
For integers this means truncation.
For booleans, abs(y) > 0.5 is considered true.

Default is no connections.
.TP
.B \-p [PARAMS]
Parameter specification list. Specifies parameters to send to FMUs during initialization. Format is:

    -p PARAM1:PARAM2:PARAM3...

where each PARAMX is one of the following:

    FMU,VR,VALUE
    TYPE,FMU,VR,VALUE
    FMU,NAME,VALUE

Comma, colon and backslash characters in VALUE must be escaped with backslash.
A typical use case is paths on Windows, which might look something like this in bash syntax:

    -p 's,0,0,C\\:\\\\foo bar\\\\woo.tx'

Note that extra escaping may be necessary in order to pass through your shell properly.
If using double quotes in bash:

    -p "s,0,0,C\\\\:\\\\\\\\foo bar\\\\\\\\woo.tx"

No characters other than comma, colon and backslash may be escaped.
Having a single trailing backslash in an option is an error ("C\\:\\\\foo\\").

If TYPE is not specified then real values are assumed, just like with weak connections.
If NAME is non-numeric then the value reference and type is looked up by name.
Example:

    -p b,0,0,true:r,0,0,0:s,0,0,hello

which means set FMU0 boolean VR0 to true, FMU0 real VR0 to zero and FMU0 string VR0 to "hello".
Note that despite identical value references these entries refer to different parameters since VRs apply with respect to a base type.
See -c option for a list of possible types (i, r, s, b).
Parameters can be specified in any order, and like all lists they can be broken up, so the following specifies the exact same set of parameters:

    -p s,0,0,hello -p b,0,0,true -p 0,0,0

Finally, some examples using names:

    -p 0,some_boolean,true
    -p 1,some_integer,123
    -p 2,participant1,Alice:2,participant2,Bob

Default is no parameters.
.TP
.B \-C [STRONG CONNECTIONS]
Strong coupling specification. Syntax is

    -C SCONN1:SCONN2:SCONN3...

where SCONNX has the following syntax:

    SCONNX=TYPE,FMU0,FMU1,[PARAMS]

FMU0 and FMU1 are the two sides of the strong coupling.
PARAMS depend on TYPE, and TYPE is the type of connection:

    [ball|lock]:
        PARAMS=pos0,acc0,force0,quat0,angAcc0,torque0,pos1,acc1,force1,quat1,angAcc1,torque1
        
        where posX/accX/forceX/angAccX/torqueX are VR triplets (X,Y,Z) and quatX are VR quadruplets (X,Y,Z,W), giving a total of (3+3+3+4+3+3) x 2 = 38 value references.

        The difference between "ball" and "lock" is that lock tries to lock the orientation of both connectors (ball only cares about position). 

    shaft:
        PARAMS=shaftAngle0,angularVelocity0,angularAcceleration0,torque0,shaftAngle1,angularVelocity1,angularAcceleration1,torque1

        The connection tries to keep both shaftAngles equal.

Examples:

    -C\ shaft,0,1,20,19,14,17,20,19,14,17

Meaning: Connect a shaft between FMU0 and FMU1, with VRs shaftAngle=20, angularVelocity=19, angularAcceleration=14 and torque=17 on both sides

    -C\ lock,0,1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18

Meaning: Create a lock constraints between FMU0 and FMU1 with VRs pos={0,1,2}, acc={3,4,5}, force={6,7,8}, quat={9,10,11,12}, angAcc={13,14,15} and torque={16,17,18} on both sides.

Note that like all lists you can concatenate the strong connection specifications with colon characters, but the result is hardly readable:

    -C\ shaft,0,1,20,19,14,17,20,19,14,17:lock,0,1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18:ball,1,2,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18

Just like weak connections, variable references can be resolved by name. So the following is also OK:

    -C\ shaft,0,1,theta1,omega1,alpha1,tau1,angle2,angularVelocity2,angularAcceleration2,torque2

Default is no strong connections. Specifying strong connections is incompatible with using the Gauss-Seidel stepper (-m gs).
.TP
.B \-d [TIMESTEP]
Timestep size. Default is 0.1.
.TP
.B \-f [OUTFORMAT]
Output file format. Can be "csv" (default) or "tikz". Use -H to print header with CSV output. TikZ output always uses a header.
.TP
.B \-m [METHOD]
Stepping method. Available methods are "jacobi" (Jacobi, parallel) and "gs" (Gauss-Seidel, serial). Default is "jacobi".
When strong coupling is used only "jacobi" is possible.
.TP
.B \-o [OUTFILE]
Result output file. Default is STDOUT.
.TP
.B \-s [SEPARATOR]
CSV separator character. Default is comma (,).
.TP
.B \-t [ENDTIME]
End simulation time in seconds. Default is 1.0.
.TP
.B \-M [COMPLIANCE]
Set compliance for kinematic solver (real value, default = 0.0).
.TP
.B \-a [ARGSFILENAME]
Add extra arguments parsed from file with given name, or stdin if filename is -.
This is useful for large systems where the total size of the connection specification exceeds the operating system's limit for program arguments (2 KiB of Windows).
The arguments in the file may be separated by anything std::ifstream::operator>>(std::string) considers a white space (space, newline, tab etc.).
The parsed tokens effectively replace the "-a [ARGSFILENAME]" in the list of arguments.
Recursive files are not allowed - if the argument file itself contains a "-a" token then the program stops.
Example:

    fmigo-master -t 100 -a args -p 0,1,123

Contents of file args:

    -C shaft,0,1,0,1,2,3,0,1,2,3
    -C shaft,1,2,6,7,8,9,0,1,2,3
    -c 2,1,0,6

Resulting equivalent command line:

    fmigo-master -t 100 -C shaft,0,1,0,1,2,3,0,1,2,3 -C shaft,1,2,6,7,8,9,0,1,2,3 -c 2,1,0,6 -p 0,1,123

stdin example producing the same command line (bash style here-document):

    fmigo-master -t 100 -a - -p 0,1,123 << EOF
    -C shaft,0,1,0,1,2,3,0,1,2,3
    -C shaft,1,2,6,7,8,9,0,1,2,3
    -c 2,1,0,6
    EOF

.TP
.B \-z [command_port:results_port]
Set up ZMQ command (REQ/REP) and results (PUSH/PULL) ports.
Allows controlling master and PULLing results over ZMQ.
Messages are serialized using protobuf.
For more information, see src/master/control.proto.

.SH EXAMPLES
To run an FMU simulation from time 0 to 5 with timestep 0.01:
    fmigo-master -t 5 -d 0.01 tcp://localhost:3000

To simulate two FMUs connected from the first output of the first FMU to the first input of the second:
    fmigo-master -c 0,0,1,0 tcp://localhost:3000 tcp://localhost:3001

Simulating four strongly coupled spring systems for 100 s at 100 Hz and writing the result to a CSV file:

    fmigo-master -t 100 -d 0.01 \\
        -p 0,3,0 -p 0,0,0:0,6,1 -p 0,9,2 -p 1,0,1:1,6,2 -p 1,3,2 -p 1,9,2 -p 2,0,2:2,6,3 -p 2,3,2 -p 2,9,2 -p 3,0,3:3,6,4 \\
        -C shaft,0,1,6,7,8,10,0,1,2,4 \\
        -C shaft,1,2,6,7,8,10,0,1,2,4 \\
        -C shaft,2,3,6,7,8,10,0,1,2,4 \\
        tcp://localhost:3000 tcp://localhost:3001 tcp://localhost:3002 tcp://localhost:3003 > results/output-N4-h0.01.csv

.SH "ABOUT"
The app was built by Stefan Hedman at UMIT Research Lab 2013. Large parts were rewritten by Tomas HÃ¤rdin at UMIT Research Lab 2014 - 2017.
