#!/usr/bin/python2
# -*- coding: utf-8 -*-
import sys, platform, tempfile, os, subprocess, zipfile, argparse, shutil, re
import xml.etree.ElementTree as e
from os.path import join as pjoin

# Parse command line arguments
parser = argparse.ArgumentParser(
    description='Generate CMakeLists.txt to build an FMU',
    epilog="""It is assumed that the current directory contains an XML file called "modelDescription.xml" and a directory "sources" containing .c and .h files.
Built by Tomas HÃ¤rdin at UMIT Research Lab 2016."""
    )
parser.add_argument('-l','--link',
                    type=str,
                    help='Libraries to link with, separated with commas.',
                    default='')
parser.add_argument('-d','--definitions',
                    type=str,
                    help='Adds flags to the compiler. Separate with commas and remove the -. Example: -d DFLAG,DKEY=VALUE,msse3',
                    default='')
parser.add_argument('-i','--includedir',
                    type=str,
                    help='Include directories. Separate with commas.',
                    default='')
parser.add_argument('-t','--templatedir',
                    action='append',
                    help='Directories to pull template code from, to avoid copy-pasting it all over the place. May also be a filename')
args = parser.parse_args()
link_libraries = args.link.split(",")
definitions = " -".join(args.definitions.split(","))
if len(definitions):
    definitions = "-"+definitions
include_directories = set(args.includedir.split(','))

# For logging errors and messages
def log(m):
    print( "%s: %s" % (sys.argv[0],m) )

# Parse xml file
tree = e.parse('modelDescription.xml')
root = tree.getroot()

# Get FMU version
fmiVersion = root.get('fmiVersion')

# Get FMU type (co-simulation or model exchange)
fmuType = "cs"

# Get model identifier.
modelIdentifier = "modelIdentifier"
if fmiVersion == "1.0":
    modelIdentifier = root.get('modelIdentifier')
elif fmiVersion == "2.0":
    if fmuType == "cs":
        modelIdentifier = root.find('CoSimulation').get('modelIdentifier')
    elif fmuType == "me":
        modelIdentifier = root.find('ModelExchange').get('modelIdentifier')

# Get system info
system = platform.system()
is_64bits = sys.maxsize > 2**32
# 'win32' seems to be the proper name for all Windows FMUs since FMILibrary-2.0.1
arch = 'win32' if system.lower() == 'windows' else system.lower()+( "64" if is_64bits else "32")

path = "CMakeLists.txt"

with open(path,'w') as f:

    # Find all .c and .h files in the current FMU folder
    cwd = os.getcwd()
    source_files = []
    dirs = [pjoin(cwd,"sources")]
    dirs.extend([pjoin(cwd,td) for td in args.templatedir])
    for dir in dirs:
        if os.path.isfile(dir):
            source_files.append(dir)
        else:
            source_files.extend([ pjoin(dir,s).replace('\\','/')
                for s in os.listdir(dir)
                if os.path.isfile(pjoin(dir,s))
                and os.path.splitext(s)[1] in ['.c','.cpp','.h','.hpp']
            ])

    # Check if there were any files
    if not len(source_files):
        log("No C files found in 'sources/'. Exiting...")
        exit(1)

    # Create a CMakeLists.txt
    include_directories.update([d if os.path.isdir(d) else os.path.dirname(d) for d in args.templatedir])
    source_files        = ["${CMAKE_CURRENT_SOURCE_DIR}/"+os.path.relpath(s) for s in source_files]
    include_directories = [os.path.relpath(i) for i in include_directories]
    files = "SET(SRCS\n    " + "\n    ".join(source_files) + "\n)"

    cmakestuff = """CMAKE_MINIMUM_REQUIRED(VERSION 2.8)
# We have multiple FMUs with the same name, but in different directories
cmake_policy(SET CMP0002 OLD)
SET(ARCH "%s" CACHE STRING "Architecture: linux64, linux32, win32...")
SET(TARGET %s)
%s
ADD_DEFINITIONS( %s )
ADD_LIBRARY(${TARGET} SHARED ${SRCS} ${HEADERS})
INCLUDE_DIRECTORIES(
    %s
)
SET_TARGET_PROPERTIES(${TARGET} PROPERTIES PREFIX "")
SET_TARGET_PROPERTIES(${TARGET} PROPERTIES LIBRARY_OUTPUT_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/binaries/${ARCH}")
TARGET_LINK_LIBRARIES( ${TARGET} %s )

# There doesn't seem to be a way to repack an FMU in case it is deleted.
# A post-build command is good enough for now.
add_custom_command(TARGET ${TARGET} POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E echo Packing ${TARGET}.fmu
    COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_CURRENT_BINARY_DIR}/fmu
    COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_CURRENT_BINARY_DIR}/fmu/sources
    COMMAND ${CMAKE_COMMAND} -E copy_directory ${CMAKE_CURRENT_BINARY_DIR}/binaries ${CMAKE_CURRENT_BINARY_DIR}/fmu/binaries
    COMMAND ${CMAKE_COMMAND} -E copy ${SRCS} ${CMAKE_CURRENT_BINARY_DIR}/fmu/sources
    COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/modelDescription.xml ${CMAKE_CURRENT_BINARY_DIR}/fmu
    # Later: COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/CMakeLists.txt ${CMAKE_CURRENT_BINARY_DIR}/fmu
    COMMAND ${CMAKE_COMMAND} -E chdir ${CMAKE_CURRENT_BINARY_DIR}/fmu ${CMAKE_COMMAND} -E tar cfv ${CMAKE_CURRENT_SOURCE_DIR}/${TARGET}.fmu --format=zip ${CMAKE_CURRENT_BINARY_DIR}/fmu/*
    MAIN_DEPENDENCY ${TARGET}
)
""" % (arch, modelIdentifier, files, definitions, "\n    ".join(include_directories), " ".join(link_libraries) )

    f.write( cmakestuff )
    f.close()
    print("Created %s" % (path))
    # Done!
