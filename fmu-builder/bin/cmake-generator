#!/usr/bin/python2
# -*- coding: utf-8 -*-
import sys, platform, tempfile, os, subprocess, zipfile, argparse, shutil, re
import xml.etree.ElementTree as e
from os.path import join as pjoin

# Parse command line arguments
parser = argparse.ArgumentParser(
    description='Generate CMakeLists.txt to build an FMU',
    epilog="""It is assumed that the current directory contains an XML file called "modelDescription.xml" and a directory "sources" containing .c and .h files.
Built by Tomas HÃ¤rdin at UMIT Research Lab 2016."""
    )
parser.add_argument('-l','--link',
                    type=str,
                    help='Libraries to link with, separated with commas.',
                    default='')
parser.add_argument('-d','--definitions',
                    type=str,
                    help='Adds flags to the compiler. Separate with commas and remove the -. Example: -d DFLAG,DKEY=VALUE,msse3',
                    default='')
parser.add_argument('-i','--includedir',
                    type=str,
                    help='Include directories. Separate with commas.',
                    default='')
parser.add_argument('-t','--templatedir',
                    action='append',
                    help='Directories to pull template code from, to avoid copy-pasting it all over the place. May also be a filename')
parser.add_argument('-m','--md2hdr',
                    type=str,
                    help='Location of modeldescription2header')
parser.add_argument('-c','--console',
                    action='store_true',
                    default=False,
                    help='Generate CONSOLE target')
args = parser.parse_args()
link_libraries = args.link.split(",")
definitions = " -".join(args.definitions.split(","))
if len(definitions):
    definitions = "-"+definitions
include_directories = args.includedir.split(',')

# For logging errors and messages
def log(m):
    print( "%s: %s" % (sys.argv[0],m) )

# Parse xml file
tree = e.parse('modelDescription.xml')
root = tree.getroot()

# Get FMU version
fmiVersion = root.get('fmiVersion')

# Get FMU type (co-simulation or model exchange)
fmuType = "cs"

# Get model identifier.
modelIdentifier = "modelIdentifier"
if fmiVersion == "1.0":
    modelIdentifier = root.get('modelIdentifier')
elif fmiVersion == "2.0":
    if fmuType == "cs":
        modelIdentifier = root.find('CoSimulation').get('modelIdentifier')
    elif fmuType == "me":
        modelIdentifier = root.find('ModelExchange').get('modelIdentifier')

# Get system info
system = platform.system()
is_64bits = sys.maxsize > 2**32
# 'win32' seems to be the proper name for all Windows FMUs since FMILibrary-2.0.1
arch = 'win32' if system.lower() == 'windows' else system.lower()+( "64" if is_64bits else "32")

path = "CMakeLists.txt"

with open(path,'w') as f:

    # Find all .c and .h files in the current FMU folder
    cwd = os.getcwd()
    source_files = []
    dirs = [pjoin(cwd,"sources")]
    dirs.extend([pjoin(cwd,td) for td in args.templatedir])
    for dir in dirs:
        if os.path.isfile(dir):
            source_files.append(dir)
        else:
            source_files.extend([ pjoin(dir,s).replace('\\','/')
                for s in os.listdir(dir)
                if os.path.isfile(pjoin(dir,s))
                and os.path.splitext(s)[1] in ['.c','.cpp','.h','.hpp']
            ])

    # Check if there were any files
    if not len(source_files):
        log("No C files found in 'sources/'. Exiting...")
        exit(1)

    # Create a CMakeLists.txt
    for d in args.templatedir:
        # Behave like a predictable set()
        d2 = d if os.path.isdir(d) else os.path.dirname(d)
        if not d2 in include_directories:
          include_directories.append(d2)

    source_files        = ["${CMAKE_CURRENT_SOURCE_DIR}/"+os.path.relpath(s) for s in source_files]
    include_directories = [os.path.relpath(i) for i in include_directories]
    files = "SET(SRCS\n    " + "\n    ".join(source_files) + "\n)"
    md2hdr = os.path.relpath(args.md2hdr)
    console = """
ADD_EXECUTABLE(${TARGET}_c ${SRCS})
SET_TARGET_PROPERTIES(${TARGET}_c PROPERTIES COMPILE_DEFINITIONS CONSOLE)
TARGET_LINK_LIBRARIES( ${TARGET}_c ${LIBS} )
"""

    cmakestuff = """CMAKE_MINIMUM_REQUIRED(VERSION 2.8)
SET(ARCH "%s" CACHE STRING "Architecture: linux64, linux32, win32...")
SET(TARGET %s)
%s
ADD_CUSTOM_COMMAND(
  OUTPUT ${CMAKE_CURRENT_SOURCE_DIR}/sources/modelDescription.h
  COMMAND python2 ${CMAKE_CURRENT_SOURCE_DIR}/%s
    ${CMAKE_CURRENT_SOURCE_DIR}/modelDescription.xml >
    ${CMAKE_CURRENT_SOURCE_DIR}/sources/modelDescription.h
  DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/modelDescription.xml )

ADD_DEFINITIONS( %s )
ADD_LIBRARY(${TARGET} SHARED ${SRCS})
INCLUDE_DIRECTORIES(
    %s
)
SET_TARGET_PROPERTIES(${TARGET} PROPERTIES PREFIX "")
SET_TARGET_PROPERTIES(${TARGET} PROPERTIES LIBRARY_OUTPUT_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/binaries/${ARCH}")
SET(LIBS %s)
TARGET_LINK_LIBRARIES( ${TARGET} ${LIBS} )

%s

# There doesn't seem to be a way to repack an FMU in case it is deleted.
# A post-build command is good enough for now.
# Having to have a separate series of commands for Windows is also not optimal
if (WIN32)
    add_custom_command(TARGET ${TARGET} POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E echo Packing ${TARGET}.fmu
        COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_CURRENT_BINARY_DIR}/fmu/sources
        COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_CURRENT_BINARY_DIR}/fmu/binaries/win32
        COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_BUILD_TYPE}/${TARGET}.dll ${CMAKE_CURRENT_BINARY_DIR}/fmu/binaries/win32/
        COMMAND ${CMAKE_COMMAND} -E copy ${SRCS} ${CMAKE_CURRENT_BINARY_DIR}/fmu/sources
        COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/modelDescription.xml ${CMAKE_CURRENT_BINARY_DIR}/fmu
        # Later: COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/CMakeLists.txt ${CMAKE_CURRENT_BINARY_DIR}/fmu
        COMMAND ${CMAKE_COMMAND} -E chdir ${CMAKE_CURRENT_BINARY_DIR}/fmu ${CMAKE_COMMAND} -E tar cf ${CMAKE_CURRENT_SOURCE_DIR}/${TARGET}.fmu --format=zip modelDescription.xml binaries sources
        MAIN_DEPENDENCY ${TARGET}
    )
else ()
    add_custom_command(TARGET ${TARGET} POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E echo Packing ${TARGET}.fmu
        COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_CURRENT_BINARY_DIR}/fmu/sources
        COMMAND ${CMAKE_COMMAND} -E copy_directory ${CMAKE_CURRENT_BINARY_DIR}/binaries ${CMAKE_CURRENT_BINARY_DIR}/fmu/binaries
        COMMAND ${CMAKE_COMMAND} -E copy ${SRCS} ${CMAKE_CURRENT_BINARY_DIR}/fmu/sources
        COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/modelDescription.xml ${CMAKE_CURRENT_BINARY_DIR}/fmu
        # Later: COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/CMakeLists.txt ${CMAKE_CURRENT_BINARY_DIR}/fmu
        COMMAND ${CMAKE_COMMAND} -E chdir ${CMAKE_CURRENT_BINARY_DIR}/fmu ${CMAKE_COMMAND} -E tar cf ${CMAKE_CURRENT_SOURCE_DIR}/${TARGET}.fmu --format=zip ${CMAKE_CURRENT_BINARY_DIR}/fmu/*
        MAIN_DEPENDENCY ${TARGET}
    )
endif ()
""" % (arch, modelIdentifier, files, md2hdr, definitions, "\n    ".join(include_directories), " ".join(link_libraries), console if args.console else "" )

    f.write( cmakestuff )
    f.close()
    print("Created %s" % (path))
    # Done!
