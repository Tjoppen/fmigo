// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fmitcp.proto

#ifndef PROTOBUF_fmitcp_2eproto__INCLUDED
#define PROTOBUF_fmitcp_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace fmitcp_proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_fmitcp_2eproto();
void protobuf_AssignDesc_fmitcp_2eproto();
void protobuf_ShutdownFile_fmitcp_2eproto();

class fmitcp_message;
class fmi2_event_info_t;
class fmi2_import_instantiate_req;
class fmi2_import_instantiate_res;
class fmi2_import_initialize_slave_req;
class fmi2_import_initialize_slave_res;
class fmi2_import_terminate_slave_req;
class fmi2_import_terminate_slave_res;
class fmi2_import_reset_slave_req;
class fmi2_import_reset_slave_res;
class fmi2_import_free_slave_instance_req;
class fmi2_import_free_slave_instance_res;
class fmi2_import_set_real_input_derivatives_req;
class fmi2_import_set_real_input_derivatives_res;
class fmi2_import_get_real_output_derivatives_req;
class fmi2_import_get_real_output_derivatives_res;
class fmi2_import_cancel_step_req;
class fmi2_import_cancel_step_res;
class fmi2_import_do_step_req;
class fmi2_import_do_step_res;
class fmi2_import_get_status_req;
class fmi2_import_get_status_res;
class fmi2_import_get_real_status_req;
class fmi2_import_get_real_status_res;
class fmi2_import_get_integer_status_req;
class fmi2_import_get_integer_status_res;
class fmi2_import_get_boolean_status_req;
class fmi2_import_get_boolean_status_res;
class fmi2_import_get_string_status_req;
class fmi2_import_get_string_status_res;
class fmi2_import_instantiate_model_req;
class fmi2_import_instantiate_model_res;
class fmi2_import_free_model_instance_req;
class fmi2_import_free_model_instance_res;
class fmi2_import_set_time_req;
class fmi2_import_set_time_res;
class fmi2_import_set_continuous_states_req;
class fmi2_import_set_continuous_states_res;
class fmi2_import_completed_integrator_step_req;
class fmi2_import_completed_integrator_step_res;
class fmi2_import_initialize_model_req;
class fmi2_import_initialize_model_res;
class fmi2_import_get_derivatives_req;
class fmi2_import_get_derivatives_res;
class fmi2_import_get_event_indicators_req;
class fmi2_import_get_event_indicators_res;
class fmi2_import_eventUpdate_req;
class fmi2_import_eventUpdate_res;
class fmi2_import_completed_event_iteration_req;
class fmi2_import_completed_event_iteration_res;
class fmi2_import_get_continuous_states_req;
class fmi2_import_get_continuous_states_res;
class fmi2_import_get_nominal_continuous_states_req;
class fmi2_import_get_nominal_continuous_states_res;
class fmi2_import_terminate_req;
class fmi2_import_terminate_res;
class fmi2_import_get_version_req;
class fmi2_import_get_version_res;
class fmi2_import_set_debug_logging_req;
class fmi2_import_set_debug_logging_res;
class fmi2_import_set_real_req;
class fmi2_import_set_real_res;
class fmi2_import_set_integer_req;
class fmi2_import_set_integer_res;
class fmi2_import_set_boolean_req;
class fmi2_import_set_boolean_res;
class fmi2_import_set_string_req;
class fmi2_import_set_string_res;
class fmi2_import_get_real_req;
class fmi2_import_get_real_res;
class fmi2_import_get_integer_req;
class fmi2_import_get_integer_res;
class fmi2_import_get_boolean_req;
class fmi2_import_get_boolean_res;
class fmi2_import_get_string_req;
class fmi2_import_get_string_res;
class char_req;
class char_res;
class fmi2_import_get_fmu_state_req;
class fmi2_import_get_fmu_state_res;
class fmi2_import_set_fmu_state_req;
class fmi2_import_set_fmu_state_res;
class fmi2_import_free_fmu_state_req;
class fmi2_import_free_fmu_state_res;
class fmi2_import_get_directional_derivative_req;
class fmi2_import_get_directional_derivative_res;
class get_xml_req;
class get_xml_res;

enum fmitcp_message_Type {
  fmitcp_message_Type_type_fmi2_import_instantiate_req = 1,
  fmitcp_message_Type_type_fmi2_import_instantiate_res = 2,
  fmitcp_message_Type_type_fmi2_import_initialize_slave_req = 3,
  fmitcp_message_Type_type_fmi2_import_initialize_slave_res = 4,
  fmitcp_message_Type_type_fmi2_import_terminate_slave_req = 5,
  fmitcp_message_Type_type_fmi2_import_terminate_slave_res = 6,
  fmitcp_message_Type_type_fmi2_import_reset_slave_req = 7,
  fmitcp_message_Type_type_fmi2_import_reset_slave_res = 8,
  fmitcp_message_Type_type_fmi2_import_free_slave_instance_req = 9,
  fmitcp_message_Type_type_fmi2_import_free_slave_instance_res = 10,
  fmitcp_message_Type_type_fmi2_import_set_real_input_derivatives_req = 11,
  fmitcp_message_Type_type_fmi2_import_set_real_input_derivatives_res = 12,
  fmitcp_message_Type_type_fmi2_import_get_real_output_derivatives_req = 13,
  fmitcp_message_Type_type_fmi2_import_get_real_output_derivatives_res = 14,
  fmitcp_message_Type_type_fmi2_import_cancel_step_req = 15,
  fmitcp_message_Type_type_fmi2_import_cancel_step_res = 16,
  fmitcp_message_Type_type_fmi2_import_do_step_req = 17,
  fmitcp_message_Type_type_fmi2_import_do_step_res = 18,
  fmitcp_message_Type_type_fmi2_import_get_status_req = 19,
  fmitcp_message_Type_type_fmi2_import_get_status_res = 20,
  fmitcp_message_Type_type_fmi2_import_get_real_status_req = 21,
  fmitcp_message_Type_type_fmi2_import_get_real_status_res = 22,
  fmitcp_message_Type_type_fmi2_import_get_integer_status_req = 23,
  fmitcp_message_Type_type_fmi2_import_get_integer_status_res = 24,
  fmitcp_message_Type_type_fmi2_import_get_boolean_status_req = 25,
  fmitcp_message_Type_type_fmi2_import_get_boolean_status_res = 26,
  fmitcp_message_Type_type_fmi2_import_get_string_status_req = 27,
  fmitcp_message_Type_type_fmi2_import_get_string_status_res = 28,
  fmitcp_message_Type_type_fmi2_import_instantiate_model_req = 29,
  fmitcp_message_Type_type_fmi2_import_instantiate_model_res = 30,
  fmitcp_message_Type_type_fmi2_import_free_model_instance_req = 31,
  fmitcp_message_Type_type_fmi2_import_free_model_instance_res = 32,
  fmitcp_message_Type_type_fmi2_import_set_time_req = 33,
  fmitcp_message_Type_type_fmi2_import_set_time_res = 34,
  fmitcp_message_Type_type_fmi2_import_set_continuous_states_req = 35,
  fmitcp_message_Type_type_fmi2_import_set_continuous_states_res = 36,
  fmitcp_message_Type_type_fmi2_import_completed_integrator_step_req = 37,
  fmitcp_message_Type_type_fmi2_import_completed_integrator_step_res = 38,
  fmitcp_message_Type_type_fmi2_import_initialize_model_req = 39,
  fmitcp_message_Type_type_fmi2_import_initialize_model_res = 40,
  fmitcp_message_Type_type_fmi2_import_get_derivatives_req = 41,
  fmitcp_message_Type_type_fmi2_import_get_derivatives_res = 42,
  fmitcp_message_Type_type_fmi2_import_get_event_indicators_req = 43,
  fmitcp_message_Type_type_fmi2_import_get_event_indicators_res = 44,
  fmitcp_message_Type_type_fmi2_import_eventUpdate_req = 45,
  fmitcp_message_Type_type_fmi2_import_eventUpdate_res = 46,
  fmitcp_message_Type_type_fmi2_import_completed_event_iteration_req = 47,
  fmitcp_message_Type_type_fmi2_import_completed_event_iteration_res = 48,
  fmitcp_message_Type_type_fmi2_import_get_continuous_states_req = 49,
  fmitcp_message_Type_type_fmi2_import_get_continuous_states_res = 50,
  fmitcp_message_Type_type_fmi2_import_get_nominal_continuous_states_req = 51,
  fmitcp_message_Type_type_fmi2_import_get_nominal_continuous_states_res = 52,
  fmitcp_message_Type_type_fmi2_import_terminate_req = 53,
  fmitcp_message_Type_type_fmi2_import_terminate_res = 54,
  fmitcp_message_Type_type_fmi2_import_get_version_req = 55,
  fmitcp_message_Type_type_fmi2_import_get_version_res = 56,
  fmitcp_message_Type_type_fmi2_import_set_debug_logging_req = 57,
  fmitcp_message_Type_type_fmi2_import_set_debug_logging_res = 58,
  fmitcp_message_Type_type_fmi2_import_set_real_req = 59,
  fmitcp_message_Type_type_fmi2_import_set_real_res = 60,
  fmitcp_message_Type_type_fmi2_import_set_integer_req = 61,
  fmitcp_message_Type_type_fmi2_import_set_integer_res = 62,
  fmitcp_message_Type_type_fmi2_import_set_boolean_req = 63,
  fmitcp_message_Type_type_fmi2_import_set_boolean_res = 64,
  fmitcp_message_Type_type_fmi2_import_set_string_req = 65,
  fmitcp_message_Type_type_fmi2_import_set_string_res = 66,
  fmitcp_message_Type_type_fmi2_import_get_real_req = 67,
  fmitcp_message_Type_type_fmi2_import_get_real_res = 68,
  fmitcp_message_Type_type_fmi2_import_get_integer_req = 69,
  fmitcp_message_Type_type_fmi2_import_get_integer_res = 70,
  fmitcp_message_Type_type_fmi2_import_get_boolean_req = 71,
  fmitcp_message_Type_type_fmi2_import_get_boolean_res = 72,
  fmitcp_message_Type_type_fmi2_import_get_string_req = 73,
  fmitcp_message_Type_type_fmi2_import_get_string_res = 74,
  fmitcp_message_Type_type_fmi2_import_get_fmu_state_req = 75,
  fmitcp_message_Type_type_fmi2_import_get_fmu_state_res = 76,
  fmitcp_message_Type_type_fmi2_import_set_fmu_state_req = 77,
  fmitcp_message_Type_type_fmi2_import_set_fmu_state_res = 78,
  fmitcp_message_Type_type_fmi2_import_free_fmu_state_req = 79,
  fmitcp_message_Type_type_fmi2_import_free_fmu_state_res = 80,
  fmitcp_message_Type_type_fmi2_import_serialized_fmu_state_size_req = 81,
  fmitcp_message_Type_type_fmi2_import_serialized_fmu_state_size_res = 82,
  fmitcp_message_Type_type_fmi2_import_serialize_fmu_state_req = 83,
  fmitcp_message_Type_type_fmi2_import_serialize_fmu_state_res = 84,
  fmitcp_message_Type_type_fmi2_import_de_serialize_fmu_state_req = 85,
  fmitcp_message_Type_type_fmi2_import_de_serialize_fmu_state_res = 86,
  fmitcp_message_Type_type_fmi2_import_get_directional_derivative_req = 87,
  fmitcp_message_Type_type_fmi2_import_get_directional_derivative_res = 88,
  fmitcp_message_Type_type_get_xml_req = 89,
  fmitcp_message_Type_type_get_xml_res = 90
};
bool fmitcp_message_Type_IsValid(int value);
const fmitcp_message_Type fmitcp_message_Type_Type_MIN = fmitcp_message_Type_type_fmi2_import_instantiate_req;
const fmitcp_message_Type fmitcp_message_Type_Type_MAX = fmitcp_message_Type_type_get_xml_res;
const int fmitcp_message_Type_Type_ARRAYSIZE = fmitcp_message_Type_Type_MAX + 1;

enum jm_log_level_enu_t {
  jm_log_level_nothing = 0,
  jm_log_level_fatal = 1,
  jm_log_level_error = 2,
  jm_log_level_warning = 3,
  jm_log_level_info = 4,
  jm_log_level_verbose = 5,
  jm_log_level_debug = 6,
  jm_log_level_all = 7
};
bool jm_log_level_enu_t_IsValid(int value);
const jm_log_level_enu_t jm_log_level_enu_t_MIN = jm_log_level_nothing;
const jm_log_level_enu_t jm_log_level_enu_t_MAX = jm_log_level_all;
const int jm_log_level_enu_t_ARRAYSIZE = jm_log_level_enu_t_MAX + 1;

enum fmi2_status_t {
  fmi2_status_ok = 0,
  fmi2_status_warning = 1,
  fmi2_status_discard = 2,
  fmi2_status_error = 3,
  fmi2_status_fatal = 4,
  fmi2_status_pending = 5
};
bool fmi2_status_t_IsValid(int value);
const fmi2_status_t fmi2_status_t_MIN = fmi2_status_ok;
const fmi2_status_t fmi2_status_t_MAX = fmi2_status_pending;
const int fmi2_status_t_ARRAYSIZE = fmi2_status_t_MAX + 1;

enum fmi2_status_kind_t {
  fmi2_do_step_status = 0,
  fmi2_pending_status = 1,
  fmi2_last_successful_time = 2,
  fmi2_terminated = 3
};
bool fmi2_status_kind_t_IsValid(int value);
const fmi2_status_kind_t fmi2_status_kind_t_MIN = fmi2_do_step_status;
const fmi2_status_kind_t fmi2_status_kind_t_MAX = fmi2_terminated;
const int fmi2_status_kind_t_ARRAYSIZE = fmi2_status_kind_t_MAX + 1;

enum jm_status_enu_t {
  jm_status_error = 0,
  jm_status_success = 1,
  jm_status_warning = 2
};
bool jm_status_enu_t_IsValid(int value);
const jm_status_enu_t jm_status_enu_t_MIN = jm_status_error;
const jm_status_enu_t jm_status_enu_t_MAX = jm_status_warning;
const int jm_status_enu_t_ARRAYSIZE = jm_status_enu_t_MAX + 1;

// ===================================================================

class fmitcp_message : public ::google::protobuf::MessageLite {
 public:
  fmitcp_message();
  virtual ~fmitcp_message();

  fmitcp_message(const fmitcp_message& from);

  inline fmitcp_message& operator=(const fmitcp_message& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmitcp_message& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmitcp_message* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmitcp_message* other);

  // implements Message ----------------------------------------------

  fmitcp_message* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmitcp_message& from);
  void MergeFrom(const fmitcp_message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef fmitcp_message_Type Type;
  static const Type type_fmi2_import_instantiate_req = fmitcp_message_Type_type_fmi2_import_instantiate_req;
  static const Type type_fmi2_import_instantiate_res = fmitcp_message_Type_type_fmi2_import_instantiate_res;
  static const Type type_fmi2_import_initialize_slave_req = fmitcp_message_Type_type_fmi2_import_initialize_slave_req;
  static const Type type_fmi2_import_initialize_slave_res = fmitcp_message_Type_type_fmi2_import_initialize_slave_res;
  static const Type type_fmi2_import_terminate_slave_req = fmitcp_message_Type_type_fmi2_import_terminate_slave_req;
  static const Type type_fmi2_import_terminate_slave_res = fmitcp_message_Type_type_fmi2_import_terminate_slave_res;
  static const Type type_fmi2_import_reset_slave_req = fmitcp_message_Type_type_fmi2_import_reset_slave_req;
  static const Type type_fmi2_import_reset_slave_res = fmitcp_message_Type_type_fmi2_import_reset_slave_res;
  static const Type type_fmi2_import_free_slave_instance_req = fmitcp_message_Type_type_fmi2_import_free_slave_instance_req;
  static const Type type_fmi2_import_free_slave_instance_res = fmitcp_message_Type_type_fmi2_import_free_slave_instance_res;
  static const Type type_fmi2_import_set_real_input_derivatives_req = fmitcp_message_Type_type_fmi2_import_set_real_input_derivatives_req;
  static const Type type_fmi2_import_set_real_input_derivatives_res = fmitcp_message_Type_type_fmi2_import_set_real_input_derivatives_res;
  static const Type type_fmi2_import_get_real_output_derivatives_req = fmitcp_message_Type_type_fmi2_import_get_real_output_derivatives_req;
  static const Type type_fmi2_import_get_real_output_derivatives_res = fmitcp_message_Type_type_fmi2_import_get_real_output_derivatives_res;
  static const Type type_fmi2_import_cancel_step_req = fmitcp_message_Type_type_fmi2_import_cancel_step_req;
  static const Type type_fmi2_import_cancel_step_res = fmitcp_message_Type_type_fmi2_import_cancel_step_res;
  static const Type type_fmi2_import_do_step_req = fmitcp_message_Type_type_fmi2_import_do_step_req;
  static const Type type_fmi2_import_do_step_res = fmitcp_message_Type_type_fmi2_import_do_step_res;
  static const Type type_fmi2_import_get_status_req = fmitcp_message_Type_type_fmi2_import_get_status_req;
  static const Type type_fmi2_import_get_status_res = fmitcp_message_Type_type_fmi2_import_get_status_res;
  static const Type type_fmi2_import_get_real_status_req = fmitcp_message_Type_type_fmi2_import_get_real_status_req;
  static const Type type_fmi2_import_get_real_status_res = fmitcp_message_Type_type_fmi2_import_get_real_status_res;
  static const Type type_fmi2_import_get_integer_status_req = fmitcp_message_Type_type_fmi2_import_get_integer_status_req;
  static const Type type_fmi2_import_get_integer_status_res = fmitcp_message_Type_type_fmi2_import_get_integer_status_res;
  static const Type type_fmi2_import_get_boolean_status_req = fmitcp_message_Type_type_fmi2_import_get_boolean_status_req;
  static const Type type_fmi2_import_get_boolean_status_res = fmitcp_message_Type_type_fmi2_import_get_boolean_status_res;
  static const Type type_fmi2_import_get_string_status_req = fmitcp_message_Type_type_fmi2_import_get_string_status_req;
  static const Type type_fmi2_import_get_string_status_res = fmitcp_message_Type_type_fmi2_import_get_string_status_res;
  static const Type type_fmi2_import_instantiate_model_req = fmitcp_message_Type_type_fmi2_import_instantiate_model_req;
  static const Type type_fmi2_import_instantiate_model_res = fmitcp_message_Type_type_fmi2_import_instantiate_model_res;
  static const Type type_fmi2_import_free_model_instance_req = fmitcp_message_Type_type_fmi2_import_free_model_instance_req;
  static const Type type_fmi2_import_free_model_instance_res = fmitcp_message_Type_type_fmi2_import_free_model_instance_res;
  static const Type type_fmi2_import_set_time_req = fmitcp_message_Type_type_fmi2_import_set_time_req;
  static const Type type_fmi2_import_set_time_res = fmitcp_message_Type_type_fmi2_import_set_time_res;
  static const Type type_fmi2_import_set_continuous_states_req = fmitcp_message_Type_type_fmi2_import_set_continuous_states_req;
  static const Type type_fmi2_import_set_continuous_states_res = fmitcp_message_Type_type_fmi2_import_set_continuous_states_res;
  static const Type type_fmi2_import_completed_integrator_step_req = fmitcp_message_Type_type_fmi2_import_completed_integrator_step_req;
  static const Type type_fmi2_import_completed_integrator_step_res = fmitcp_message_Type_type_fmi2_import_completed_integrator_step_res;
  static const Type type_fmi2_import_initialize_model_req = fmitcp_message_Type_type_fmi2_import_initialize_model_req;
  static const Type type_fmi2_import_initialize_model_res = fmitcp_message_Type_type_fmi2_import_initialize_model_res;
  static const Type type_fmi2_import_get_derivatives_req = fmitcp_message_Type_type_fmi2_import_get_derivatives_req;
  static const Type type_fmi2_import_get_derivatives_res = fmitcp_message_Type_type_fmi2_import_get_derivatives_res;
  static const Type type_fmi2_import_get_event_indicators_req = fmitcp_message_Type_type_fmi2_import_get_event_indicators_req;
  static const Type type_fmi2_import_get_event_indicators_res = fmitcp_message_Type_type_fmi2_import_get_event_indicators_res;
  static const Type type_fmi2_import_eventUpdate_req = fmitcp_message_Type_type_fmi2_import_eventUpdate_req;
  static const Type type_fmi2_import_eventUpdate_res = fmitcp_message_Type_type_fmi2_import_eventUpdate_res;
  static const Type type_fmi2_import_completed_event_iteration_req = fmitcp_message_Type_type_fmi2_import_completed_event_iteration_req;
  static const Type type_fmi2_import_completed_event_iteration_res = fmitcp_message_Type_type_fmi2_import_completed_event_iteration_res;
  static const Type type_fmi2_import_get_continuous_states_req = fmitcp_message_Type_type_fmi2_import_get_continuous_states_req;
  static const Type type_fmi2_import_get_continuous_states_res = fmitcp_message_Type_type_fmi2_import_get_continuous_states_res;
  static const Type type_fmi2_import_get_nominal_continuous_states_req = fmitcp_message_Type_type_fmi2_import_get_nominal_continuous_states_req;
  static const Type type_fmi2_import_get_nominal_continuous_states_res = fmitcp_message_Type_type_fmi2_import_get_nominal_continuous_states_res;
  static const Type type_fmi2_import_terminate_req = fmitcp_message_Type_type_fmi2_import_terminate_req;
  static const Type type_fmi2_import_terminate_res = fmitcp_message_Type_type_fmi2_import_terminate_res;
  static const Type type_fmi2_import_get_version_req = fmitcp_message_Type_type_fmi2_import_get_version_req;
  static const Type type_fmi2_import_get_version_res = fmitcp_message_Type_type_fmi2_import_get_version_res;
  static const Type type_fmi2_import_set_debug_logging_req = fmitcp_message_Type_type_fmi2_import_set_debug_logging_req;
  static const Type type_fmi2_import_set_debug_logging_res = fmitcp_message_Type_type_fmi2_import_set_debug_logging_res;
  static const Type type_fmi2_import_set_real_req = fmitcp_message_Type_type_fmi2_import_set_real_req;
  static const Type type_fmi2_import_set_real_res = fmitcp_message_Type_type_fmi2_import_set_real_res;
  static const Type type_fmi2_import_set_integer_req = fmitcp_message_Type_type_fmi2_import_set_integer_req;
  static const Type type_fmi2_import_set_integer_res = fmitcp_message_Type_type_fmi2_import_set_integer_res;
  static const Type type_fmi2_import_set_boolean_req = fmitcp_message_Type_type_fmi2_import_set_boolean_req;
  static const Type type_fmi2_import_set_boolean_res = fmitcp_message_Type_type_fmi2_import_set_boolean_res;
  static const Type type_fmi2_import_set_string_req = fmitcp_message_Type_type_fmi2_import_set_string_req;
  static const Type type_fmi2_import_set_string_res = fmitcp_message_Type_type_fmi2_import_set_string_res;
  static const Type type_fmi2_import_get_real_req = fmitcp_message_Type_type_fmi2_import_get_real_req;
  static const Type type_fmi2_import_get_real_res = fmitcp_message_Type_type_fmi2_import_get_real_res;
  static const Type type_fmi2_import_get_integer_req = fmitcp_message_Type_type_fmi2_import_get_integer_req;
  static const Type type_fmi2_import_get_integer_res = fmitcp_message_Type_type_fmi2_import_get_integer_res;
  static const Type type_fmi2_import_get_boolean_req = fmitcp_message_Type_type_fmi2_import_get_boolean_req;
  static const Type type_fmi2_import_get_boolean_res = fmitcp_message_Type_type_fmi2_import_get_boolean_res;
  static const Type type_fmi2_import_get_string_req = fmitcp_message_Type_type_fmi2_import_get_string_req;
  static const Type type_fmi2_import_get_string_res = fmitcp_message_Type_type_fmi2_import_get_string_res;
  static const Type type_fmi2_import_get_fmu_state_req = fmitcp_message_Type_type_fmi2_import_get_fmu_state_req;
  static const Type type_fmi2_import_get_fmu_state_res = fmitcp_message_Type_type_fmi2_import_get_fmu_state_res;
  static const Type type_fmi2_import_set_fmu_state_req = fmitcp_message_Type_type_fmi2_import_set_fmu_state_req;
  static const Type type_fmi2_import_set_fmu_state_res = fmitcp_message_Type_type_fmi2_import_set_fmu_state_res;
  static const Type type_fmi2_import_free_fmu_state_req = fmitcp_message_Type_type_fmi2_import_free_fmu_state_req;
  static const Type type_fmi2_import_free_fmu_state_res = fmitcp_message_Type_type_fmi2_import_free_fmu_state_res;
  static const Type type_fmi2_import_serialized_fmu_state_size_req = fmitcp_message_Type_type_fmi2_import_serialized_fmu_state_size_req;
  static const Type type_fmi2_import_serialized_fmu_state_size_res = fmitcp_message_Type_type_fmi2_import_serialized_fmu_state_size_res;
  static const Type type_fmi2_import_serialize_fmu_state_req = fmitcp_message_Type_type_fmi2_import_serialize_fmu_state_req;
  static const Type type_fmi2_import_serialize_fmu_state_res = fmitcp_message_Type_type_fmi2_import_serialize_fmu_state_res;
  static const Type type_fmi2_import_de_serialize_fmu_state_req = fmitcp_message_Type_type_fmi2_import_de_serialize_fmu_state_req;
  static const Type type_fmi2_import_de_serialize_fmu_state_res = fmitcp_message_Type_type_fmi2_import_de_serialize_fmu_state_res;
  static const Type type_fmi2_import_get_directional_derivative_req = fmitcp_message_Type_type_fmi2_import_get_directional_derivative_req;
  static const Type type_fmi2_import_get_directional_derivative_res = fmitcp_message_Type_type_fmi2_import_get_directional_derivative_res;
  static const Type type_get_xml_req = fmitcp_message_Type_type_get_xml_req;
  static const Type type_get_xml_res = fmitcp_message_Type_type_get_xml_res;
  static inline bool Type_IsValid(int value) {
    return fmitcp_message_Type_IsValid(value);
  }
  static const Type Type_MIN =
    fmitcp_message_Type_Type_MIN;
  static const Type Type_MAX =
    fmitcp_message_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    fmitcp_message_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .fmitcp_proto.fmitcp_message.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::fmitcp_proto::fmitcp_message_Type type() const;
  inline void set_type(::fmitcp_proto::fmitcp_message_Type value);

  // optional .fmitcp_proto.fmi2_import_instantiate_req fmi2_import_instantiate_req = 2;
  inline bool has_fmi2_import_instantiate_req() const;
  inline void clear_fmi2_import_instantiate_req();
  static const int kFmi2ImportInstantiateReqFieldNumber = 2;
  inline const ::fmitcp_proto::fmi2_import_instantiate_req& fmi2_import_instantiate_req() const;
  inline ::fmitcp_proto::fmi2_import_instantiate_req* mutable_fmi2_import_instantiate_req();
  inline ::fmitcp_proto::fmi2_import_instantiate_req* release_fmi2_import_instantiate_req();
  inline void set_allocated_fmi2_import_instantiate_req(::fmitcp_proto::fmi2_import_instantiate_req* fmi2_import_instantiate_req);

  // optional .fmitcp_proto.fmi2_import_instantiate_res fmi2_import_instantiate_res = 3;
  inline bool has_fmi2_import_instantiate_res() const;
  inline void clear_fmi2_import_instantiate_res();
  static const int kFmi2ImportInstantiateResFieldNumber = 3;
  inline const ::fmitcp_proto::fmi2_import_instantiate_res& fmi2_import_instantiate_res() const;
  inline ::fmitcp_proto::fmi2_import_instantiate_res* mutable_fmi2_import_instantiate_res();
  inline ::fmitcp_proto::fmi2_import_instantiate_res* release_fmi2_import_instantiate_res();
  inline void set_allocated_fmi2_import_instantiate_res(::fmitcp_proto::fmi2_import_instantiate_res* fmi2_import_instantiate_res);

  // optional .fmitcp_proto.fmi2_import_initialize_slave_req fmi2_import_initialize_slave_req = 4;
  inline bool has_fmi2_import_initialize_slave_req() const;
  inline void clear_fmi2_import_initialize_slave_req();
  static const int kFmi2ImportInitializeSlaveReqFieldNumber = 4;
  inline const ::fmitcp_proto::fmi2_import_initialize_slave_req& fmi2_import_initialize_slave_req() const;
  inline ::fmitcp_proto::fmi2_import_initialize_slave_req* mutable_fmi2_import_initialize_slave_req();
  inline ::fmitcp_proto::fmi2_import_initialize_slave_req* release_fmi2_import_initialize_slave_req();
  inline void set_allocated_fmi2_import_initialize_slave_req(::fmitcp_proto::fmi2_import_initialize_slave_req* fmi2_import_initialize_slave_req);

  // optional .fmitcp_proto.fmi2_import_initialize_slave_res fmi2_import_initialize_slave_res = 5;
  inline bool has_fmi2_import_initialize_slave_res() const;
  inline void clear_fmi2_import_initialize_slave_res();
  static const int kFmi2ImportInitializeSlaveResFieldNumber = 5;
  inline const ::fmitcp_proto::fmi2_import_initialize_slave_res& fmi2_import_initialize_slave_res() const;
  inline ::fmitcp_proto::fmi2_import_initialize_slave_res* mutable_fmi2_import_initialize_slave_res();
  inline ::fmitcp_proto::fmi2_import_initialize_slave_res* release_fmi2_import_initialize_slave_res();
  inline void set_allocated_fmi2_import_initialize_slave_res(::fmitcp_proto::fmi2_import_initialize_slave_res* fmi2_import_initialize_slave_res);

  // optional .fmitcp_proto.fmi2_import_terminate_slave_req fmi2_import_terminate_slave_req = 6;
  inline bool has_fmi2_import_terminate_slave_req() const;
  inline void clear_fmi2_import_terminate_slave_req();
  static const int kFmi2ImportTerminateSlaveReqFieldNumber = 6;
  inline const ::fmitcp_proto::fmi2_import_terminate_slave_req& fmi2_import_terminate_slave_req() const;
  inline ::fmitcp_proto::fmi2_import_terminate_slave_req* mutable_fmi2_import_terminate_slave_req();
  inline ::fmitcp_proto::fmi2_import_terminate_slave_req* release_fmi2_import_terminate_slave_req();
  inline void set_allocated_fmi2_import_terminate_slave_req(::fmitcp_proto::fmi2_import_terminate_slave_req* fmi2_import_terminate_slave_req);

  // optional .fmitcp_proto.fmi2_import_terminate_slave_res fmi2_import_terminate_slave_res = 7;
  inline bool has_fmi2_import_terminate_slave_res() const;
  inline void clear_fmi2_import_terminate_slave_res();
  static const int kFmi2ImportTerminateSlaveResFieldNumber = 7;
  inline const ::fmitcp_proto::fmi2_import_terminate_slave_res& fmi2_import_terminate_slave_res() const;
  inline ::fmitcp_proto::fmi2_import_terminate_slave_res* mutable_fmi2_import_terminate_slave_res();
  inline ::fmitcp_proto::fmi2_import_terminate_slave_res* release_fmi2_import_terminate_slave_res();
  inline void set_allocated_fmi2_import_terminate_slave_res(::fmitcp_proto::fmi2_import_terminate_slave_res* fmi2_import_terminate_slave_res);

  // optional .fmitcp_proto.fmi2_import_reset_slave_req fmi2_import_reset_slave_req = 8;
  inline bool has_fmi2_import_reset_slave_req() const;
  inline void clear_fmi2_import_reset_slave_req();
  static const int kFmi2ImportResetSlaveReqFieldNumber = 8;
  inline const ::fmitcp_proto::fmi2_import_reset_slave_req& fmi2_import_reset_slave_req() const;
  inline ::fmitcp_proto::fmi2_import_reset_slave_req* mutable_fmi2_import_reset_slave_req();
  inline ::fmitcp_proto::fmi2_import_reset_slave_req* release_fmi2_import_reset_slave_req();
  inline void set_allocated_fmi2_import_reset_slave_req(::fmitcp_proto::fmi2_import_reset_slave_req* fmi2_import_reset_slave_req);

  // optional .fmitcp_proto.fmi2_import_reset_slave_res fmi2_import_reset_slave_res = 9;
  inline bool has_fmi2_import_reset_slave_res() const;
  inline void clear_fmi2_import_reset_slave_res();
  static const int kFmi2ImportResetSlaveResFieldNumber = 9;
  inline const ::fmitcp_proto::fmi2_import_reset_slave_res& fmi2_import_reset_slave_res() const;
  inline ::fmitcp_proto::fmi2_import_reset_slave_res* mutable_fmi2_import_reset_slave_res();
  inline ::fmitcp_proto::fmi2_import_reset_slave_res* release_fmi2_import_reset_slave_res();
  inline void set_allocated_fmi2_import_reset_slave_res(::fmitcp_proto::fmi2_import_reset_slave_res* fmi2_import_reset_slave_res);

  // optional .fmitcp_proto.fmi2_import_free_slave_instance_req fmi2_import_free_slave_instance_req = 10;
  inline bool has_fmi2_import_free_slave_instance_req() const;
  inline void clear_fmi2_import_free_slave_instance_req();
  static const int kFmi2ImportFreeSlaveInstanceReqFieldNumber = 10;
  inline const ::fmitcp_proto::fmi2_import_free_slave_instance_req& fmi2_import_free_slave_instance_req() const;
  inline ::fmitcp_proto::fmi2_import_free_slave_instance_req* mutable_fmi2_import_free_slave_instance_req();
  inline ::fmitcp_proto::fmi2_import_free_slave_instance_req* release_fmi2_import_free_slave_instance_req();
  inline void set_allocated_fmi2_import_free_slave_instance_req(::fmitcp_proto::fmi2_import_free_slave_instance_req* fmi2_import_free_slave_instance_req);

  // optional .fmitcp_proto.fmi2_import_free_slave_instance_res fmi2_import_free_slave_instance_res = 11;
  inline bool has_fmi2_import_free_slave_instance_res() const;
  inline void clear_fmi2_import_free_slave_instance_res();
  static const int kFmi2ImportFreeSlaveInstanceResFieldNumber = 11;
  inline const ::fmitcp_proto::fmi2_import_free_slave_instance_res& fmi2_import_free_slave_instance_res() const;
  inline ::fmitcp_proto::fmi2_import_free_slave_instance_res* mutable_fmi2_import_free_slave_instance_res();
  inline ::fmitcp_proto::fmi2_import_free_slave_instance_res* release_fmi2_import_free_slave_instance_res();
  inline void set_allocated_fmi2_import_free_slave_instance_res(::fmitcp_proto::fmi2_import_free_slave_instance_res* fmi2_import_free_slave_instance_res);

  // optional .fmitcp_proto.fmi2_import_set_real_input_derivatives_req fmi2_import_set_real_input_derivatives_req = 12;
  inline bool has_fmi2_import_set_real_input_derivatives_req() const;
  inline void clear_fmi2_import_set_real_input_derivatives_req();
  static const int kFmi2ImportSetRealInputDerivativesReqFieldNumber = 12;
  inline const ::fmitcp_proto::fmi2_import_set_real_input_derivatives_req& fmi2_import_set_real_input_derivatives_req() const;
  inline ::fmitcp_proto::fmi2_import_set_real_input_derivatives_req* mutable_fmi2_import_set_real_input_derivatives_req();
  inline ::fmitcp_proto::fmi2_import_set_real_input_derivatives_req* release_fmi2_import_set_real_input_derivatives_req();
  inline void set_allocated_fmi2_import_set_real_input_derivatives_req(::fmitcp_proto::fmi2_import_set_real_input_derivatives_req* fmi2_import_set_real_input_derivatives_req);

  // optional .fmitcp_proto.fmi2_import_set_real_input_derivatives_res fmi2_import_set_real_input_derivatives_res = 13;
  inline bool has_fmi2_import_set_real_input_derivatives_res() const;
  inline void clear_fmi2_import_set_real_input_derivatives_res();
  static const int kFmi2ImportSetRealInputDerivativesResFieldNumber = 13;
  inline const ::fmitcp_proto::fmi2_import_set_real_input_derivatives_res& fmi2_import_set_real_input_derivatives_res() const;
  inline ::fmitcp_proto::fmi2_import_set_real_input_derivatives_res* mutable_fmi2_import_set_real_input_derivatives_res();
  inline ::fmitcp_proto::fmi2_import_set_real_input_derivatives_res* release_fmi2_import_set_real_input_derivatives_res();
  inline void set_allocated_fmi2_import_set_real_input_derivatives_res(::fmitcp_proto::fmi2_import_set_real_input_derivatives_res* fmi2_import_set_real_input_derivatives_res);

  // optional .fmitcp_proto.fmi2_import_get_real_output_derivatives_req fmi2_import_get_real_output_derivatives_req = 14;
  inline bool has_fmi2_import_get_real_output_derivatives_req() const;
  inline void clear_fmi2_import_get_real_output_derivatives_req();
  static const int kFmi2ImportGetRealOutputDerivativesReqFieldNumber = 14;
  inline const ::fmitcp_proto::fmi2_import_get_real_output_derivatives_req& fmi2_import_get_real_output_derivatives_req() const;
  inline ::fmitcp_proto::fmi2_import_get_real_output_derivatives_req* mutable_fmi2_import_get_real_output_derivatives_req();
  inline ::fmitcp_proto::fmi2_import_get_real_output_derivatives_req* release_fmi2_import_get_real_output_derivatives_req();
  inline void set_allocated_fmi2_import_get_real_output_derivatives_req(::fmitcp_proto::fmi2_import_get_real_output_derivatives_req* fmi2_import_get_real_output_derivatives_req);

  // optional .fmitcp_proto.fmi2_import_get_real_output_derivatives_res fmi2_import_get_real_output_derivatives_res = 15;
  inline bool has_fmi2_import_get_real_output_derivatives_res() const;
  inline void clear_fmi2_import_get_real_output_derivatives_res();
  static const int kFmi2ImportGetRealOutputDerivativesResFieldNumber = 15;
  inline const ::fmitcp_proto::fmi2_import_get_real_output_derivatives_res& fmi2_import_get_real_output_derivatives_res() const;
  inline ::fmitcp_proto::fmi2_import_get_real_output_derivatives_res* mutable_fmi2_import_get_real_output_derivatives_res();
  inline ::fmitcp_proto::fmi2_import_get_real_output_derivatives_res* release_fmi2_import_get_real_output_derivatives_res();
  inline void set_allocated_fmi2_import_get_real_output_derivatives_res(::fmitcp_proto::fmi2_import_get_real_output_derivatives_res* fmi2_import_get_real_output_derivatives_res);

  // optional .fmitcp_proto.fmi2_import_cancel_step_req fmi2_import_cancel_step_req = 16;
  inline bool has_fmi2_import_cancel_step_req() const;
  inline void clear_fmi2_import_cancel_step_req();
  static const int kFmi2ImportCancelStepReqFieldNumber = 16;
  inline const ::fmitcp_proto::fmi2_import_cancel_step_req& fmi2_import_cancel_step_req() const;
  inline ::fmitcp_proto::fmi2_import_cancel_step_req* mutable_fmi2_import_cancel_step_req();
  inline ::fmitcp_proto::fmi2_import_cancel_step_req* release_fmi2_import_cancel_step_req();
  inline void set_allocated_fmi2_import_cancel_step_req(::fmitcp_proto::fmi2_import_cancel_step_req* fmi2_import_cancel_step_req);

  // optional .fmitcp_proto.fmi2_import_cancel_step_res fmi2_import_cancel_step_res = 17;
  inline bool has_fmi2_import_cancel_step_res() const;
  inline void clear_fmi2_import_cancel_step_res();
  static const int kFmi2ImportCancelStepResFieldNumber = 17;
  inline const ::fmitcp_proto::fmi2_import_cancel_step_res& fmi2_import_cancel_step_res() const;
  inline ::fmitcp_proto::fmi2_import_cancel_step_res* mutable_fmi2_import_cancel_step_res();
  inline ::fmitcp_proto::fmi2_import_cancel_step_res* release_fmi2_import_cancel_step_res();
  inline void set_allocated_fmi2_import_cancel_step_res(::fmitcp_proto::fmi2_import_cancel_step_res* fmi2_import_cancel_step_res);

  // optional .fmitcp_proto.fmi2_import_do_step_req fmi2_import_do_step_req = 18;
  inline bool has_fmi2_import_do_step_req() const;
  inline void clear_fmi2_import_do_step_req();
  static const int kFmi2ImportDoStepReqFieldNumber = 18;
  inline const ::fmitcp_proto::fmi2_import_do_step_req& fmi2_import_do_step_req() const;
  inline ::fmitcp_proto::fmi2_import_do_step_req* mutable_fmi2_import_do_step_req();
  inline ::fmitcp_proto::fmi2_import_do_step_req* release_fmi2_import_do_step_req();
  inline void set_allocated_fmi2_import_do_step_req(::fmitcp_proto::fmi2_import_do_step_req* fmi2_import_do_step_req);

  // optional .fmitcp_proto.fmi2_import_do_step_res fmi2_import_do_step_res = 19;
  inline bool has_fmi2_import_do_step_res() const;
  inline void clear_fmi2_import_do_step_res();
  static const int kFmi2ImportDoStepResFieldNumber = 19;
  inline const ::fmitcp_proto::fmi2_import_do_step_res& fmi2_import_do_step_res() const;
  inline ::fmitcp_proto::fmi2_import_do_step_res* mutable_fmi2_import_do_step_res();
  inline ::fmitcp_proto::fmi2_import_do_step_res* release_fmi2_import_do_step_res();
  inline void set_allocated_fmi2_import_do_step_res(::fmitcp_proto::fmi2_import_do_step_res* fmi2_import_do_step_res);

  // optional .fmitcp_proto.fmi2_import_get_status_req fmi2_import_get_status_req = 20;
  inline bool has_fmi2_import_get_status_req() const;
  inline void clear_fmi2_import_get_status_req();
  static const int kFmi2ImportGetStatusReqFieldNumber = 20;
  inline const ::fmitcp_proto::fmi2_import_get_status_req& fmi2_import_get_status_req() const;
  inline ::fmitcp_proto::fmi2_import_get_status_req* mutable_fmi2_import_get_status_req();
  inline ::fmitcp_proto::fmi2_import_get_status_req* release_fmi2_import_get_status_req();
  inline void set_allocated_fmi2_import_get_status_req(::fmitcp_proto::fmi2_import_get_status_req* fmi2_import_get_status_req);

  // optional .fmitcp_proto.fmi2_import_get_status_res fmi2_import_get_status_res = 21;
  inline bool has_fmi2_import_get_status_res() const;
  inline void clear_fmi2_import_get_status_res();
  static const int kFmi2ImportGetStatusResFieldNumber = 21;
  inline const ::fmitcp_proto::fmi2_import_get_status_res& fmi2_import_get_status_res() const;
  inline ::fmitcp_proto::fmi2_import_get_status_res* mutable_fmi2_import_get_status_res();
  inline ::fmitcp_proto::fmi2_import_get_status_res* release_fmi2_import_get_status_res();
  inline void set_allocated_fmi2_import_get_status_res(::fmitcp_proto::fmi2_import_get_status_res* fmi2_import_get_status_res);

  // optional .fmitcp_proto.fmi2_import_get_real_status_req fmi2_import_get_real_status_req = 22;
  inline bool has_fmi2_import_get_real_status_req() const;
  inline void clear_fmi2_import_get_real_status_req();
  static const int kFmi2ImportGetRealStatusReqFieldNumber = 22;
  inline const ::fmitcp_proto::fmi2_import_get_real_status_req& fmi2_import_get_real_status_req() const;
  inline ::fmitcp_proto::fmi2_import_get_real_status_req* mutable_fmi2_import_get_real_status_req();
  inline ::fmitcp_proto::fmi2_import_get_real_status_req* release_fmi2_import_get_real_status_req();
  inline void set_allocated_fmi2_import_get_real_status_req(::fmitcp_proto::fmi2_import_get_real_status_req* fmi2_import_get_real_status_req);

  // optional .fmitcp_proto.fmi2_import_get_real_status_res fmi2_import_get_real_status_res = 23;
  inline bool has_fmi2_import_get_real_status_res() const;
  inline void clear_fmi2_import_get_real_status_res();
  static const int kFmi2ImportGetRealStatusResFieldNumber = 23;
  inline const ::fmitcp_proto::fmi2_import_get_real_status_res& fmi2_import_get_real_status_res() const;
  inline ::fmitcp_proto::fmi2_import_get_real_status_res* mutable_fmi2_import_get_real_status_res();
  inline ::fmitcp_proto::fmi2_import_get_real_status_res* release_fmi2_import_get_real_status_res();
  inline void set_allocated_fmi2_import_get_real_status_res(::fmitcp_proto::fmi2_import_get_real_status_res* fmi2_import_get_real_status_res);

  // optional .fmitcp_proto.fmi2_import_get_integer_status_req fmi2_import_get_integer_status_req = 24;
  inline bool has_fmi2_import_get_integer_status_req() const;
  inline void clear_fmi2_import_get_integer_status_req();
  static const int kFmi2ImportGetIntegerStatusReqFieldNumber = 24;
  inline const ::fmitcp_proto::fmi2_import_get_integer_status_req& fmi2_import_get_integer_status_req() const;
  inline ::fmitcp_proto::fmi2_import_get_integer_status_req* mutable_fmi2_import_get_integer_status_req();
  inline ::fmitcp_proto::fmi2_import_get_integer_status_req* release_fmi2_import_get_integer_status_req();
  inline void set_allocated_fmi2_import_get_integer_status_req(::fmitcp_proto::fmi2_import_get_integer_status_req* fmi2_import_get_integer_status_req);

  // optional .fmitcp_proto.fmi2_import_get_integer_status_res fmi2_import_get_integer_status_res = 25;
  inline bool has_fmi2_import_get_integer_status_res() const;
  inline void clear_fmi2_import_get_integer_status_res();
  static const int kFmi2ImportGetIntegerStatusResFieldNumber = 25;
  inline const ::fmitcp_proto::fmi2_import_get_integer_status_res& fmi2_import_get_integer_status_res() const;
  inline ::fmitcp_proto::fmi2_import_get_integer_status_res* mutable_fmi2_import_get_integer_status_res();
  inline ::fmitcp_proto::fmi2_import_get_integer_status_res* release_fmi2_import_get_integer_status_res();
  inline void set_allocated_fmi2_import_get_integer_status_res(::fmitcp_proto::fmi2_import_get_integer_status_res* fmi2_import_get_integer_status_res);

  // optional .fmitcp_proto.fmi2_import_get_boolean_status_req fmi2_import_get_boolean_status_req = 26;
  inline bool has_fmi2_import_get_boolean_status_req() const;
  inline void clear_fmi2_import_get_boolean_status_req();
  static const int kFmi2ImportGetBooleanStatusReqFieldNumber = 26;
  inline const ::fmitcp_proto::fmi2_import_get_boolean_status_req& fmi2_import_get_boolean_status_req() const;
  inline ::fmitcp_proto::fmi2_import_get_boolean_status_req* mutable_fmi2_import_get_boolean_status_req();
  inline ::fmitcp_proto::fmi2_import_get_boolean_status_req* release_fmi2_import_get_boolean_status_req();
  inline void set_allocated_fmi2_import_get_boolean_status_req(::fmitcp_proto::fmi2_import_get_boolean_status_req* fmi2_import_get_boolean_status_req);

  // optional .fmitcp_proto.fmi2_import_get_boolean_status_res fmi2_import_get_boolean_status_res = 27;
  inline bool has_fmi2_import_get_boolean_status_res() const;
  inline void clear_fmi2_import_get_boolean_status_res();
  static const int kFmi2ImportGetBooleanStatusResFieldNumber = 27;
  inline const ::fmitcp_proto::fmi2_import_get_boolean_status_res& fmi2_import_get_boolean_status_res() const;
  inline ::fmitcp_proto::fmi2_import_get_boolean_status_res* mutable_fmi2_import_get_boolean_status_res();
  inline ::fmitcp_proto::fmi2_import_get_boolean_status_res* release_fmi2_import_get_boolean_status_res();
  inline void set_allocated_fmi2_import_get_boolean_status_res(::fmitcp_proto::fmi2_import_get_boolean_status_res* fmi2_import_get_boolean_status_res);

  // optional .fmitcp_proto.fmi2_import_get_string_status_req fmi2_import_get_string_status_req = 28;
  inline bool has_fmi2_import_get_string_status_req() const;
  inline void clear_fmi2_import_get_string_status_req();
  static const int kFmi2ImportGetStringStatusReqFieldNumber = 28;
  inline const ::fmitcp_proto::fmi2_import_get_string_status_req& fmi2_import_get_string_status_req() const;
  inline ::fmitcp_proto::fmi2_import_get_string_status_req* mutable_fmi2_import_get_string_status_req();
  inline ::fmitcp_proto::fmi2_import_get_string_status_req* release_fmi2_import_get_string_status_req();
  inline void set_allocated_fmi2_import_get_string_status_req(::fmitcp_proto::fmi2_import_get_string_status_req* fmi2_import_get_string_status_req);

  // optional .fmitcp_proto.fmi2_import_get_string_status_res fmi2_import_get_string_status_res = 29;
  inline bool has_fmi2_import_get_string_status_res() const;
  inline void clear_fmi2_import_get_string_status_res();
  static const int kFmi2ImportGetStringStatusResFieldNumber = 29;
  inline const ::fmitcp_proto::fmi2_import_get_string_status_res& fmi2_import_get_string_status_res() const;
  inline ::fmitcp_proto::fmi2_import_get_string_status_res* mutable_fmi2_import_get_string_status_res();
  inline ::fmitcp_proto::fmi2_import_get_string_status_res* release_fmi2_import_get_string_status_res();
  inline void set_allocated_fmi2_import_get_string_status_res(::fmitcp_proto::fmi2_import_get_string_status_res* fmi2_import_get_string_status_res);

  // optional .fmitcp_proto.fmi2_import_instantiate_model_req fmi2_import_instantiate_model_req = 30;
  inline bool has_fmi2_import_instantiate_model_req() const;
  inline void clear_fmi2_import_instantiate_model_req();
  static const int kFmi2ImportInstantiateModelReqFieldNumber = 30;
  inline const ::fmitcp_proto::fmi2_import_instantiate_model_req& fmi2_import_instantiate_model_req() const;
  inline ::fmitcp_proto::fmi2_import_instantiate_model_req* mutable_fmi2_import_instantiate_model_req();
  inline ::fmitcp_proto::fmi2_import_instantiate_model_req* release_fmi2_import_instantiate_model_req();
  inline void set_allocated_fmi2_import_instantiate_model_req(::fmitcp_proto::fmi2_import_instantiate_model_req* fmi2_import_instantiate_model_req);

  // optional .fmitcp_proto.fmi2_import_instantiate_model_res fmi2_import_instantiate_model_res = 31;
  inline bool has_fmi2_import_instantiate_model_res() const;
  inline void clear_fmi2_import_instantiate_model_res();
  static const int kFmi2ImportInstantiateModelResFieldNumber = 31;
  inline const ::fmitcp_proto::fmi2_import_instantiate_model_res& fmi2_import_instantiate_model_res() const;
  inline ::fmitcp_proto::fmi2_import_instantiate_model_res* mutable_fmi2_import_instantiate_model_res();
  inline ::fmitcp_proto::fmi2_import_instantiate_model_res* release_fmi2_import_instantiate_model_res();
  inline void set_allocated_fmi2_import_instantiate_model_res(::fmitcp_proto::fmi2_import_instantiate_model_res* fmi2_import_instantiate_model_res);

  // optional .fmitcp_proto.fmi2_import_free_model_instance_req fmi2_import_free_model_instance_req = 32;
  inline bool has_fmi2_import_free_model_instance_req() const;
  inline void clear_fmi2_import_free_model_instance_req();
  static const int kFmi2ImportFreeModelInstanceReqFieldNumber = 32;
  inline const ::fmitcp_proto::fmi2_import_free_model_instance_req& fmi2_import_free_model_instance_req() const;
  inline ::fmitcp_proto::fmi2_import_free_model_instance_req* mutable_fmi2_import_free_model_instance_req();
  inline ::fmitcp_proto::fmi2_import_free_model_instance_req* release_fmi2_import_free_model_instance_req();
  inline void set_allocated_fmi2_import_free_model_instance_req(::fmitcp_proto::fmi2_import_free_model_instance_req* fmi2_import_free_model_instance_req);

  // optional .fmitcp_proto.fmi2_import_free_model_instance_res fmi2_import_free_model_instance_res = 33;
  inline bool has_fmi2_import_free_model_instance_res() const;
  inline void clear_fmi2_import_free_model_instance_res();
  static const int kFmi2ImportFreeModelInstanceResFieldNumber = 33;
  inline const ::fmitcp_proto::fmi2_import_free_model_instance_res& fmi2_import_free_model_instance_res() const;
  inline ::fmitcp_proto::fmi2_import_free_model_instance_res* mutable_fmi2_import_free_model_instance_res();
  inline ::fmitcp_proto::fmi2_import_free_model_instance_res* release_fmi2_import_free_model_instance_res();
  inline void set_allocated_fmi2_import_free_model_instance_res(::fmitcp_proto::fmi2_import_free_model_instance_res* fmi2_import_free_model_instance_res);

  // optional .fmitcp_proto.fmi2_import_set_time_req fmi2_import_set_time_req = 34;
  inline bool has_fmi2_import_set_time_req() const;
  inline void clear_fmi2_import_set_time_req();
  static const int kFmi2ImportSetTimeReqFieldNumber = 34;
  inline const ::fmitcp_proto::fmi2_import_set_time_req& fmi2_import_set_time_req() const;
  inline ::fmitcp_proto::fmi2_import_set_time_req* mutable_fmi2_import_set_time_req();
  inline ::fmitcp_proto::fmi2_import_set_time_req* release_fmi2_import_set_time_req();
  inline void set_allocated_fmi2_import_set_time_req(::fmitcp_proto::fmi2_import_set_time_req* fmi2_import_set_time_req);

  // optional .fmitcp_proto.fmi2_import_set_time_res fmi2_import_set_time_res = 35;
  inline bool has_fmi2_import_set_time_res() const;
  inline void clear_fmi2_import_set_time_res();
  static const int kFmi2ImportSetTimeResFieldNumber = 35;
  inline const ::fmitcp_proto::fmi2_import_set_time_res& fmi2_import_set_time_res() const;
  inline ::fmitcp_proto::fmi2_import_set_time_res* mutable_fmi2_import_set_time_res();
  inline ::fmitcp_proto::fmi2_import_set_time_res* release_fmi2_import_set_time_res();
  inline void set_allocated_fmi2_import_set_time_res(::fmitcp_proto::fmi2_import_set_time_res* fmi2_import_set_time_res);

  // optional .fmitcp_proto.fmi2_import_set_continuous_states_req fmi2_import_set_continuous_states_req = 36;
  inline bool has_fmi2_import_set_continuous_states_req() const;
  inline void clear_fmi2_import_set_continuous_states_req();
  static const int kFmi2ImportSetContinuousStatesReqFieldNumber = 36;
  inline const ::fmitcp_proto::fmi2_import_set_continuous_states_req& fmi2_import_set_continuous_states_req() const;
  inline ::fmitcp_proto::fmi2_import_set_continuous_states_req* mutable_fmi2_import_set_continuous_states_req();
  inline ::fmitcp_proto::fmi2_import_set_continuous_states_req* release_fmi2_import_set_continuous_states_req();
  inline void set_allocated_fmi2_import_set_continuous_states_req(::fmitcp_proto::fmi2_import_set_continuous_states_req* fmi2_import_set_continuous_states_req);

  // optional .fmitcp_proto.fmi2_import_set_continuous_states_res fmi2_import_set_continuous_states_res = 37;
  inline bool has_fmi2_import_set_continuous_states_res() const;
  inline void clear_fmi2_import_set_continuous_states_res();
  static const int kFmi2ImportSetContinuousStatesResFieldNumber = 37;
  inline const ::fmitcp_proto::fmi2_import_set_continuous_states_res& fmi2_import_set_continuous_states_res() const;
  inline ::fmitcp_proto::fmi2_import_set_continuous_states_res* mutable_fmi2_import_set_continuous_states_res();
  inline ::fmitcp_proto::fmi2_import_set_continuous_states_res* release_fmi2_import_set_continuous_states_res();
  inline void set_allocated_fmi2_import_set_continuous_states_res(::fmitcp_proto::fmi2_import_set_continuous_states_res* fmi2_import_set_continuous_states_res);

  // optional .fmitcp_proto.fmi2_import_completed_integrator_step_req fmi2_import_completed_integrator_step_req = 38;
  inline bool has_fmi2_import_completed_integrator_step_req() const;
  inline void clear_fmi2_import_completed_integrator_step_req();
  static const int kFmi2ImportCompletedIntegratorStepReqFieldNumber = 38;
  inline const ::fmitcp_proto::fmi2_import_completed_integrator_step_req& fmi2_import_completed_integrator_step_req() const;
  inline ::fmitcp_proto::fmi2_import_completed_integrator_step_req* mutable_fmi2_import_completed_integrator_step_req();
  inline ::fmitcp_proto::fmi2_import_completed_integrator_step_req* release_fmi2_import_completed_integrator_step_req();
  inline void set_allocated_fmi2_import_completed_integrator_step_req(::fmitcp_proto::fmi2_import_completed_integrator_step_req* fmi2_import_completed_integrator_step_req);

  // optional .fmitcp_proto.fmi2_import_completed_integrator_step_res fmi2_import_completed_integrator_step_res = 39;
  inline bool has_fmi2_import_completed_integrator_step_res() const;
  inline void clear_fmi2_import_completed_integrator_step_res();
  static const int kFmi2ImportCompletedIntegratorStepResFieldNumber = 39;
  inline const ::fmitcp_proto::fmi2_import_completed_integrator_step_res& fmi2_import_completed_integrator_step_res() const;
  inline ::fmitcp_proto::fmi2_import_completed_integrator_step_res* mutable_fmi2_import_completed_integrator_step_res();
  inline ::fmitcp_proto::fmi2_import_completed_integrator_step_res* release_fmi2_import_completed_integrator_step_res();
  inline void set_allocated_fmi2_import_completed_integrator_step_res(::fmitcp_proto::fmi2_import_completed_integrator_step_res* fmi2_import_completed_integrator_step_res);

  // optional .fmitcp_proto.fmi2_import_initialize_model_req fmi2_import_initialize_model_req = 40;
  inline bool has_fmi2_import_initialize_model_req() const;
  inline void clear_fmi2_import_initialize_model_req();
  static const int kFmi2ImportInitializeModelReqFieldNumber = 40;
  inline const ::fmitcp_proto::fmi2_import_initialize_model_req& fmi2_import_initialize_model_req() const;
  inline ::fmitcp_proto::fmi2_import_initialize_model_req* mutable_fmi2_import_initialize_model_req();
  inline ::fmitcp_proto::fmi2_import_initialize_model_req* release_fmi2_import_initialize_model_req();
  inline void set_allocated_fmi2_import_initialize_model_req(::fmitcp_proto::fmi2_import_initialize_model_req* fmi2_import_initialize_model_req);

  // optional .fmitcp_proto.fmi2_import_initialize_model_res fmi2_import_initialize_model_res = 41;
  inline bool has_fmi2_import_initialize_model_res() const;
  inline void clear_fmi2_import_initialize_model_res();
  static const int kFmi2ImportInitializeModelResFieldNumber = 41;
  inline const ::fmitcp_proto::fmi2_import_initialize_model_res& fmi2_import_initialize_model_res() const;
  inline ::fmitcp_proto::fmi2_import_initialize_model_res* mutable_fmi2_import_initialize_model_res();
  inline ::fmitcp_proto::fmi2_import_initialize_model_res* release_fmi2_import_initialize_model_res();
  inline void set_allocated_fmi2_import_initialize_model_res(::fmitcp_proto::fmi2_import_initialize_model_res* fmi2_import_initialize_model_res);

  // optional .fmitcp_proto.fmi2_import_get_derivatives_req fmi2_import_get_derivatives_req = 42;
  inline bool has_fmi2_import_get_derivatives_req() const;
  inline void clear_fmi2_import_get_derivatives_req();
  static const int kFmi2ImportGetDerivativesReqFieldNumber = 42;
  inline const ::fmitcp_proto::fmi2_import_get_derivatives_req& fmi2_import_get_derivatives_req() const;
  inline ::fmitcp_proto::fmi2_import_get_derivatives_req* mutable_fmi2_import_get_derivatives_req();
  inline ::fmitcp_proto::fmi2_import_get_derivatives_req* release_fmi2_import_get_derivatives_req();
  inline void set_allocated_fmi2_import_get_derivatives_req(::fmitcp_proto::fmi2_import_get_derivatives_req* fmi2_import_get_derivatives_req);

  // optional .fmitcp_proto.fmi2_import_get_derivatives_res fmi2_import_get_derivatives_res = 43;
  inline bool has_fmi2_import_get_derivatives_res() const;
  inline void clear_fmi2_import_get_derivatives_res();
  static const int kFmi2ImportGetDerivativesResFieldNumber = 43;
  inline const ::fmitcp_proto::fmi2_import_get_derivatives_res& fmi2_import_get_derivatives_res() const;
  inline ::fmitcp_proto::fmi2_import_get_derivatives_res* mutable_fmi2_import_get_derivatives_res();
  inline ::fmitcp_proto::fmi2_import_get_derivatives_res* release_fmi2_import_get_derivatives_res();
  inline void set_allocated_fmi2_import_get_derivatives_res(::fmitcp_proto::fmi2_import_get_derivatives_res* fmi2_import_get_derivatives_res);

  // optional .fmitcp_proto.fmi2_import_get_event_indicators_req fmi2_import_get_event_indicators_req = 44;
  inline bool has_fmi2_import_get_event_indicators_req() const;
  inline void clear_fmi2_import_get_event_indicators_req();
  static const int kFmi2ImportGetEventIndicatorsReqFieldNumber = 44;
  inline const ::fmitcp_proto::fmi2_import_get_event_indicators_req& fmi2_import_get_event_indicators_req() const;
  inline ::fmitcp_proto::fmi2_import_get_event_indicators_req* mutable_fmi2_import_get_event_indicators_req();
  inline ::fmitcp_proto::fmi2_import_get_event_indicators_req* release_fmi2_import_get_event_indicators_req();
  inline void set_allocated_fmi2_import_get_event_indicators_req(::fmitcp_proto::fmi2_import_get_event_indicators_req* fmi2_import_get_event_indicators_req);

  // optional .fmitcp_proto.fmi2_import_get_event_indicators_res fmi2_import_get_event_indicators_res = 45;
  inline bool has_fmi2_import_get_event_indicators_res() const;
  inline void clear_fmi2_import_get_event_indicators_res();
  static const int kFmi2ImportGetEventIndicatorsResFieldNumber = 45;
  inline const ::fmitcp_proto::fmi2_import_get_event_indicators_res& fmi2_import_get_event_indicators_res() const;
  inline ::fmitcp_proto::fmi2_import_get_event_indicators_res* mutable_fmi2_import_get_event_indicators_res();
  inline ::fmitcp_proto::fmi2_import_get_event_indicators_res* release_fmi2_import_get_event_indicators_res();
  inline void set_allocated_fmi2_import_get_event_indicators_res(::fmitcp_proto::fmi2_import_get_event_indicators_res* fmi2_import_get_event_indicators_res);

  // optional .fmitcp_proto.fmi2_import_eventUpdate_req fmi2_import_eventUpdate_req = 46;
  inline bool has_fmi2_import_eventupdate_req() const;
  inline void clear_fmi2_import_eventupdate_req();
  static const int kFmi2ImportEventUpdateReqFieldNumber = 46;
  inline const ::fmitcp_proto::fmi2_import_eventUpdate_req& fmi2_import_eventupdate_req() const;
  inline ::fmitcp_proto::fmi2_import_eventUpdate_req* mutable_fmi2_import_eventupdate_req();
  inline ::fmitcp_proto::fmi2_import_eventUpdate_req* release_fmi2_import_eventupdate_req();
  inline void set_allocated_fmi2_import_eventupdate_req(::fmitcp_proto::fmi2_import_eventUpdate_req* fmi2_import_eventupdate_req);

  // optional .fmitcp_proto.fmi2_import_eventUpdate_res fmi2_import_eventUpdate_res = 47;
  inline bool has_fmi2_import_eventupdate_res() const;
  inline void clear_fmi2_import_eventupdate_res();
  static const int kFmi2ImportEventUpdateResFieldNumber = 47;
  inline const ::fmitcp_proto::fmi2_import_eventUpdate_res& fmi2_import_eventupdate_res() const;
  inline ::fmitcp_proto::fmi2_import_eventUpdate_res* mutable_fmi2_import_eventupdate_res();
  inline ::fmitcp_proto::fmi2_import_eventUpdate_res* release_fmi2_import_eventupdate_res();
  inline void set_allocated_fmi2_import_eventupdate_res(::fmitcp_proto::fmi2_import_eventUpdate_res* fmi2_import_eventupdate_res);

  // optional .fmitcp_proto.fmi2_import_completed_event_iteration_req fmi2_import_completed_event_iteration_req = 48;
  inline bool has_fmi2_import_completed_event_iteration_req() const;
  inline void clear_fmi2_import_completed_event_iteration_req();
  static const int kFmi2ImportCompletedEventIterationReqFieldNumber = 48;
  inline const ::fmitcp_proto::fmi2_import_completed_event_iteration_req& fmi2_import_completed_event_iteration_req() const;
  inline ::fmitcp_proto::fmi2_import_completed_event_iteration_req* mutable_fmi2_import_completed_event_iteration_req();
  inline ::fmitcp_proto::fmi2_import_completed_event_iteration_req* release_fmi2_import_completed_event_iteration_req();
  inline void set_allocated_fmi2_import_completed_event_iteration_req(::fmitcp_proto::fmi2_import_completed_event_iteration_req* fmi2_import_completed_event_iteration_req);

  // optional .fmitcp_proto.fmi2_import_completed_event_iteration_res fmi2_import_completed_event_iteration_res = 49;
  inline bool has_fmi2_import_completed_event_iteration_res() const;
  inline void clear_fmi2_import_completed_event_iteration_res();
  static const int kFmi2ImportCompletedEventIterationResFieldNumber = 49;
  inline const ::fmitcp_proto::fmi2_import_completed_event_iteration_res& fmi2_import_completed_event_iteration_res() const;
  inline ::fmitcp_proto::fmi2_import_completed_event_iteration_res* mutable_fmi2_import_completed_event_iteration_res();
  inline ::fmitcp_proto::fmi2_import_completed_event_iteration_res* release_fmi2_import_completed_event_iteration_res();
  inline void set_allocated_fmi2_import_completed_event_iteration_res(::fmitcp_proto::fmi2_import_completed_event_iteration_res* fmi2_import_completed_event_iteration_res);

  // optional .fmitcp_proto.fmi2_import_get_continuous_states_req fmi2_import_get_continuous_states_req = 50;
  inline bool has_fmi2_import_get_continuous_states_req() const;
  inline void clear_fmi2_import_get_continuous_states_req();
  static const int kFmi2ImportGetContinuousStatesReqFieldNumber = 50;
  inline const ::fmitcp_proto::fmi2_import_get_continuous_states_req& fmi2_import_get_continuous_states_req() const;
  inline ::fmitcp_proto::fmi2_import_get_continuous_states_req* mutable_fmi2_import_get_continuous_states_req();
  inline ::fmitcp_proto::fmi2_import_get_continuous_states_req* release_fmi2_import_get_continuous_states_req();
  inline void set_allocated_fmi2_import_get_continuous_states_req(::fmitcp_proto::fmi2_import_get_continuous_states_req* fmi2_import_get_continuous_states_req);

  // optional .fmitcp_proto.fmi2_import_get_continuous_states_res fmi2_import_get_continuous_states_res = 51;
  inline bool has_fmi2_import_get_continuous_states_res() const;
  inline void clear_fmi2_import_get_continuous_states_res();
  static const int kFmi2ImportGetContinuousStatesResFieldNumber = 51;
  inline const ::fmitcp_proto::fmi2_import_get_continuous_states_res& fmi2_import_get_continuous_states_res() const;
  inline ::fmitcp_proto::fmi2_import_get_continuous_states_res* mutable_fmi2_import_get_continuous_states_res();
  inline ::fmitcp_proto::fmi2_import_get_continuous_states_res* release_fmi2_import_get_continuous_states_res();
  inline void set_allocated_fmi2_import_get_continuous_states_res(::fmitcp_proto::fmi2_import_get_continuous_states_res* fmi2_import_get_continuous_states_res);

  // optional .fmitcp_proto.fmi2_import_get_nominal_continuous_states_req fmi2_import_get_nominal_continuous_states_req = 52;
  inline bool has_fmi2_import_get_nominal_continuous_states_req() const;
  inline void clear_fmi2_import_get_nominal_continuous_states_req();
  static const int kFmi2ImportGetNominalContinuousStatesReqFieldNumber = 52;
  inline const ::fmitcp_proto::fmi2_import_get_nominal_continuous_states_req& fmi2_import_get_nominal_continuous_states_req() const;
  inline ::fmitcp_proto::fmi2_import_get_nominal_continuous_states_req* mutable_fmi2_import_get_nominal_continuous_states_req();
  inline ::fmitcp_proto::fmi2_import_get_nominal_continuous_states_req* release_fmi2_import_get_nominal_continuous_states_req();
  inline void set_allocated_fmi2_import_get_nominal_continuous_states_req(::fmitcp_proto::fmi2_import_get_nominal_continuous_states_req* fmi2_import_get_nominal_continuous_states_req);

  // optional .fmitcp_proto.fmi2_import_get_nominal_continuous_states_res fmi2_import_get_nominal_continuous_states_res = 53;
  inline bool has_fmi2_import_get_nominal_continuous_states_res() const;
  inline void clear_fmi2_import_get_nominal_continuous_states_res();
  static const int kFmi2ImportGetNominalContinuousStatesResFieldNumber = 53;
  inline const ::fmitcp_proto::fmi2_import_get_nominal_continuous_states_res& fmi2_import_get_nominal_continuous_states_res() const;
  inline ::fmitcp_proto::fmi2_import_get_nominal_continuous_states_res* mutable_fmi2_import_get_nominal_continuous_states_res();
  inline ::fmitcp_proto::fmi2_import_get_nominal_continuous_states_res* release_fmi2_import_get_nominal_continuous_states_res();
  inline void set_allocated_fmi2_import_get_nominal_continuous_states_res(::fmitcp_proto::fmi2_import_get_nominal_continuous_states_res* fmi2_import_get_nominal_continuous_states_res);

  // optional .fmitcp_proto.fmi2_import_terminate_req fmi2_import_terminate_req = 54;
  inline bool has_fmi2_import_terminate_req() const;
  inline void clear_fmi2_import_terminate_req();
  static const int kFmi2ImportTerminateReqFieldNumber = 54;
  inline const ::fmitcp_proto::fmi2_import_terminate_req& fmi2_import_terminate_req() const;
  inline ::fmitcp_proto::fmi2_import_terminate_req* mutable_fmi2_import_terminate_req();
  inline ::fmitcp_proto::fmi2_import_terminate_req* release_fmi2_import_terminate_req();
  inline void set_allocated_fmi2_import_terminate_req(::fmitcp_proto::fmi2_import_terminate_req* fmi2_import_terminate_req);

  // optional .fmitcp_proto.fmi2_import_terminate_res fmi2_import_terminate_res = 55;
  inline bool has_fmi2_import_terminate_res() const;
  inline void clear_fmi2_import_terminate_res();
  static const int kFmi2ImportTerminateResFieldNumber = 55;
  inline const ::fmitcp_proto::fmi2_import_terminate_res& fmi2_import_terminate_res() const;
  inline ::fmitcp_proto::fmi2_import_terminate_res* mutable_fmi2_import_terminate_res();
  inline ::fmitcp_proto::fmi2_import_terminate_res* release_fmi2_import_terminate_res();
  inline void set_allocated_fmi2_import_terminate_res(::fmitcp_proto::fmi2_import_terminate_res* fmi2_import_terminate_res);

  // optional .fmitcp_proto.fmi2_import_get_version_req fmi2_import_get_version_req = 56;
  inline bool has_fmi2_import_get_version_req() const;
  inline void clear_fmi2_import_get_version_req();
  static const int kFmi2ImportGetVersionReqFieldNumber = 56;
  inline const ::fmitcp_proto::fmi2_import_get_version_req& fmi2_import_get_version_req() const;
  inline ::fmitcp_proto::fmi2_import_get_version_req* mutable_fmi2_import_get_version_req();
  inline ::fmitcp_proto::fmi2_import_get_version_req* release_fmi2_import_get_version_req();
  inline void set_allocated_fmi2_import_get_version_req(::fmitcp_proto::fmi2_import_get_version_req* fmi2_import_get_version_req);

  // optional .fmitcp_proto.fmi2_import_get_version_res fmi2_import_get_version_res = 57;
  inline bool has_fmi2_import_get_version_res() const;
  inline void clear_fmi2_import_get_version_res();
  static const int kFmi2ImportGetVersionResFieldNumber = 57;
  inline const ::fmitcp_proto::fmi2_import_get_version_res& fmi2_import_get_version_res() const;
  inline ::fmitcp_proto::fmi2_import_get_version_res* mutable_fmi2_import_get_version_res();
  inline ::fmitcp_proto::fmi2_import_get_version_res* release_fmi2_import_get_version_res();
  inline void set_allocated_fmi2_import_get_version_res(::fmitcp_proto::fmi2_import_get_version_res* fmi2_import_get_version_res);

  // optional .fmitcp_proto.fmi2_import_set_debug_logging_req fmi2_import_set_debug_logging_req = 58;
  inline bool has_fmi2_import_set_debug_logging_req() const;
  inline void clear_fmi2_import_set_debug_logging_req();
  static const int kFmi2ImportSetDebugLoggingReqFieldNumber = 58;
  inline const ::fmitcp_proto::fmi2_import_set_debug_logging_req& fmi2_import_set_debug_logging_req() const;
  inline ::fmitcp_proto::fmi2_import_set_debug_logging_req* mutable_fmi2_import_set_debug_logging_req();
  inline ::fmitcp_proto::fmi2_import_set_debug_logging_req* release_fmi2_import_set_debug_logging_req();
  inline void set_allocated_fmi2_import_set_debug_logging_req(::fmitcp_proto::fmi2_import_set_debug_logging_req* fmi2_import_set_debug_logging_req);

  // optional .fmitcp_proto.fmi2_import_set_debug_logging_res fmi2_import_set_debug_logging_res = 59;
  inline bool has_fmi2_import_set_debug_logging_res() const;
  inline void clear_fmi2_import_set_debug_logging_res();
  static const int kFmi2ImportSetDebugLoggingResFieldNumber = 59;
  inline const ::fmitcp_proto::fmi2_import_set_debug_logging_res& fmi2_import_set_debug_logging_res() const;
  inline ::fmitcp_proto::fmi2_import_set_debug_logging_res* mutable_fmi2_import_set_debug_logging_res();
  inline ::fmitcp_proto::fmi2_import_set_debug_logging_res* release_fmi2_import_set_debug_logging_res();
  inline void set_allocated_fmi2_import_set_debug_logging_res(::fmitcp_proto::fmi2_import_set_debug_logging_res* fmi2_import_set_debug_logging_res);

  // optional .fmitcp_proto.fmi2_import_set_real_req fmi2_import_set_real_req = 60;
  inline bool has_fmi2_import_set_real_req() const;
  inline void clear_fmi2_import_set_real_req();
  static const int kFmi2ImportSetRealReqFieldNumber = 60;
  inline const ::fmitcp_proto::fmi2_import_set_real_req& fmi2_import_set_real_req() const;
  inline ::fmitcp_proto::fmi2_import_set_real_req* mutable_fmi2_import_set_real_req();
  inline ::fmitcp_proto::fmi2_import_set_real_req* release_fmi2_import_set_real_req();
  inline void set_allocated_fmi2_import_set_real_req(::fmitcp_proto::fmi2_import_set_real_req* fmi2_import_set_real_req);

  // optional .fmitcp_proto.fmi2_import_set_real_res fmi2_import_set_real_res = 61;
  inline bool has_fmi2_import_set_real_res() const;
  inline void clear_fmi2_import_set_real_res();
  static const int kFmi2ImportSetRealResFieldNumber = 61;
  inline const ::fmitcp_proto::fmi2_import_set_real_res& fmi2_import_set_real_res() const;
  inline ::fmitcp_proto::fmi2_import_set_real_res* mutable_fmi2_import_set_real_res();
  inline ::fmitcp_proto::fmi2_import_set_real_res* release_fmi2_import_set_real_res();
  inline void set_allocated_fmi2_import_set_real_res(::fmitcp_proto::fmi2_import_set_real_res* fmi2_import_set_real_res);

  // optional .fmitcp_proto.fmi2_import_set_integer_req fmi2_import_set_integer_req = 62;
  inline bool has_fmi2_import_set_integer_req() const;
  inline void clear_fmi2_import_set_integer_req();
  static const int kFmi2ImportSetIntegerReqFieldNumber = 62;
  inline const ::fmitcp_proto::fmi2_import_set_integer_req& fmi2_import_set_integer_req() const;
  inline ::fmitcp_proto::fmi2_import_set_integer_req* mutable_fmi2_import_set_integer_req();
  inline ::fmitcp_proto::fmi2_import_set_integer_req* release_fmi2_import_set_integer_req();
  inline void set_allocated_fmi2_import_set_integer_req(::fmitcp_proto::fmi2_import_set_integer_req* fmi2_import_set_integer_req);

  // optional .fmitcp_proto.fmi2_import_set_integer_res fmi2_import_set_integer_res = 63;
  inline bool has_fmi2_import_set_integer_res() const;
  inline void clear_fmi2_import_set_integer_res();
  static const int kFmi2ImportSetIntegerResFieldNumber = 63;
  inline const ::fmitcp_proto::fmi2_import_set_integer_res& fmi2_import_set_integer_res() const;
  inline ::fmitcp_proto::fmi2_import_set_integer_res* mutable_fmi2_import_set_integer_res();
  inline ::fmitcp_proto::fmi2_import_set_integer_res* release_fmi2_import_set_integer_res();
  inline void set_allocated_fmi2_import_set_integer_res(::fmitcp_proto::fmi2_import_set_integer_res* fmi2_import_set_integer_res);

  // optional .fmitcp_proto.fmi2_import_set_boolean_req fmi2_import_set_boolean_req = 64;
  inline bool has_fmi2_import_set_boolean_req() const;
  inline void clear_fmi2_import_set_boolean_req();
  static const int kFmi2ImportSetBooleanReqFieldNumber = 64;
  inline const ::fmitcp_proto::fmi2_import_set_boolean_req& fmi2_import_set_boolean_req() const;
  inline ::fmitcp_proto::fmi2_import_set_boolean_req* mutable_fmi2_import_set_boolean_req();
  inline ::fmitcp_proto::fmi2_import_set_boolean_req* release_fmi2_import_set_boolean_req();
  inline void set_allocated_fmi2_import_set_boolean_req(::fmitcp_proto::fmi2_import_set_boolean_req* fmi2_import_set_boolean_req);

  // optional .fmitcp_proto.fmi2_import_set_boolean_res fmi2_import_set_boolean_res = 65;
  inline bool has_fmi2_import_set_boolean_res() const;
  inline void clear_fmi2_import_set_boolean_res();
  static const int kFmi2ImportSetBooleanResFieldNumber = 65;
  inline const ::fmitcp_proto::fmi2_import_set_boolean_res& fmi2_import_set_boolean_res() const;
  inline ::fmitcp_proto::fmi2_import_set_boolean_res* mutable_fmi2_import_set_boolean_res();
  inline ::fmitcp_proto::fmi2_import_set_boolean_res* release_fmi2_import_set_boolean_res();
  inline void set_allocated_fmi2_import_set_boolean_res(::fmitcp_proto::fmi2_import_set_boolean_res* fmi2_import_set_boolean_res);

  // optional .fmitcp_proto.fmi2_import_set_string_req fmi2_import_set_string_req = 66;
  inline bool has_fmi2_import_set_string_req() const;
  inline void clear_fmi2_import_set_string_req();
  static const int kFmi2ImportSetStringReqFieldNumber = 66;
  inline const ::fmitcp_proto::fmi2_import_set_string_req& fmi2_import_set_string_req() const;
  inline ::fmitcp_proto::fmi2_import_set_string_req* mutable_fmi2_import_set_string_req();
  inline ::fmitcp_proto::fmi2_import_set_string_req* release_fmi2_import_set_string_req();
  inline void set_allocated_fmi2_import_set_string_req(::fmitcp_proto::fmi2_import_set_string_req* fmi2_import_set_string_req);

  // optional .fmitcp_proto.fmi2_import_set_string_res fmi2_import_set_string_res = 67;
  inline bool has_fmi2_import_set_string_res() const;
  inline void clear_fmi2_import_set_string_res();
  static const int kFmi2ImportSetStringResFieldNumber = 67;
  inline const ::fmitcp_proto::fmi2_import_set_string_res& fmi2_import_set_string_res() const;
  inline ::fmitcp_proto::fmi2_import_set_string_res* mutable_fmi2_import_set_string_res();
  inline ::fmitcp_proto::fmi2_import_set_string_res* release_fmi2_import_set_string_res();
  inline void set_allocated_fmi2_import_set_string_res(::fmitcp_proto::fmi2_import_set_string_res* fmi2_import_set_string_res);

  // optional .fmitcp_proto.fmi2_import_get_real_req fmi2_import_get_real_req = 68;
  inline bool has_fmi2_import_get_real_req() const;
  inline void clear_fmi2_import_get_real_req();
  static const int kFmi2ImportGetRealReqFieldNumber = 68;
  inline const ::fmitcp_proto::fmi2_import_get_real_req& fmi2_import_get_real_req() const;
  inline ::fmitcp_proto::fmi2_import_get_real_req* mutable_fmi2_import_get_real_req();
  inline ::fmitcp_proto::fmi2_import_get_real_req* release_fmi2_import_get_real_req();
  inline void set_allocated_fmi2_import_get_real_req(::fmitcp_proto::fmi2_import_get_real_req* fmi2_import_get_real_req);

  // optional .fmitcp_proto.fmi2_import_get_real_res fmi2_import_get_real_res = 69;
  inline bool has_fmi2_import_get_real_res() const;
  inline void clear_fmi2_import_get_real_res();
  static const int kFmi2ImportGetRealResFieldNumber = 69;
  inline const ::fmitcp_proto::fmi2_import_get_real_res& fmi2_import_get_real_res() const;
  inline ::fmitcp_proto::fmi2_import_get_real_res* mutable_fmi2_import_get_real_res();
  inline ::fmitcp_proto::fmi2_import_get_real_res* release_fmi2_import_get_real_res();
  inline void set_allocated_fmi2_import_get_real_res(::fmitcp_proto::fmi2_import_get_real_res* fmi2_import_get_real_res);

  // optional .fmitcp_proto.fmi2_import_get_integer_req fmi2_import_get_integer_req = 70;
  inline bool has_fmi2_import_get_integer_req() const;
  inline void clear_fmi2_import_get_integer_req();
  static const int kFmi2ImportGetIntegerReqFieldNumber = 70;
  inline const ::fmitcp_proto::fmi2_import_get_integer_req& fmi2_import_get_integer_req() const;
  inline ::fmitcp_proto::fmi2_import_get_integer_req* mutable_fmi2_import_get_integer_req();
  inline ::fmitcp_proto::fmi2_import_get_integer_req* release_fmi2_import_get_integer_req();
  inline void set_allocated_fmi2_import_get_integer_req(::fmitcp_proto::fmi2_import_get_integer_req* fmi2_import_get_integer_req);

  // optional .fmitcp_proto.fmi2_import_get_integer_res fmi2_import_get_integer_res = 71;
  inline bool has_fmi2_import_get_integer_res() const;
  inline void clear_fmi2_import_get_integer_res();
  static const int kFmi2ImportGetIntegerResFieldNumber = 71;
  inline const ::fmitcp_proto::fmi2_import_get_integer_res& fmi2_import_get_integer_res() const;
  inline ::fmitcp_proto::fmi2_import_get_integer_res* mutable_fmi2_import_get_integer_res();
  inline ::fmitcp_proto::fmi2_import_get_integer_res* release_fmi2_import_get_integer_res();
  inline void set_allocated_fmi2_import_get_integer_res(::fmitcp_proto::fmi2_import_get_integer_res* fmi2_import_get_integer_res);

  // optional .fmitcp_proto.fmi2_import_get_boolean_req fmi2_import_get_boolean_req = 72;
  inline bool has_fmi2_import_get_boolean_req() const;
  inline void clear_fmi2_import_get_boolean_req();
  static const int kFmi2ImportGetBooleanReqFieldNumber = 72;
  inline const ::fmitcp_proto::fmi2_import_get_boolean_req& fmi2_import_get_boolean_req() const;
  inline ::fmitcp_proto::fmi2_import_get_boolean_req* mutable_fmi2_import_get_boolean_req();
  inline ::fmitcp_proto::fmi2_import_get_boolean_req* release_fmi2_import_get_boolean_req();
  inline void set_allocated_fmi2_import_get_boolean_req(::fmitcp_proto::fmi2_import_get_boolean_req* fmi2_import_get_boolean_req);

  // optional .fmitcp_proto.fmi2_import_get_boolean_res fmi2_import_get_boolean_res = 73;
  inline bool has_fmi2_import_get_boolean_res() const;
  inline void clear_fmi2_import_get_boolean_res();
  static const int kFmi2ImportGetBooleanResFieldNumber = 73;
  inline const ::fmitcp_proto::fmi2_import_get_boolean_res& fmi2_import_get_boolean_res() const;
  inline ::fmitcp_proto::fmi2_import_get_boolean_res* mutable_fmi2_import_get_boolean_res();
  inline ::fmitcp_proto::fmi2_import_get_boolean_res* release_fmi2_import_get_boolean_res();
  inline void set_allocated_fmi2_import_get_boolean_res(::fmitcp_proto::fmi2_import_get_boolean_res* fmi2_import_get_boolean_res);

  // optional .fmitcp_proto.fmi2_import_get_string_req fmi2_import_get_string_req = 74;
  inline bool has_fmi2_import_get_string_req() const;
  inline void clear_fmi2_import_get_string_req();
  static const int kFmi2ImportGetStringReqFieldNumber = 74;
  inline const ::fmitcp_proto::fmi2_import_get_string_req& fmi2_import_get_string_req() const;
  inline ::fmitcp_proto::fmi2_import_get_string_req* mutable_fmi2_import_get_string_req();
  inline ::fmitcp_proto::fmi2_import_get_string_req* release_fmi2_import_get_string_req();
  inline void set_allocated_fmi2_import_get_string_req(::fmitcp_proto::fmi2_import_get_string_req* fmi2_import_get_string_req);

  // optional .fmitcp_proto.fmi2_import_get_string_res fmi2_import_get_string_res = 75;
  inline bool has_fmi2_import_get_string_res() const;
  inline void clear_fmi2_import_get_string_res();
  static const int kFmi2ImportGetStringResFieldNumber = 75;
  inline const ::fmitcp_proto::fmi2_import_get_string_res& fmi2_import_get_string_res() const;
  inline ::fmitcp_proto::fmi2_import_get_string_res* mutable_fmi2_import_get_string_res();
  inline ::fmitcp_proto::fmi2_import_get_string_res* release_fmi2_import_get_string_res();
  inline void set_allocated_fmi2_import_get_string_res(::fmitcp_proto::fmi2_import_get_string_res* fmi2_import_get_string_res);

  // optional .fmitcp_proto.fmi2_import_get_fmu_state_req fmi2_import_get_fmu_state_req = 76;
  inline bool has_fmi2_import_get_fmu_state_req() const;
  inline void clear_fmi2_import_get_fmu_state_req();
  static const int kFmi2ImportGetFmuStateReqFieldNumber = 76;
  inline const ::fmitcp_proto::fmi2_import_get_fmu_state_req& fmi2_import_get_fmu_state_req() const;
  inline ::fmitcp_proto::fmi2_import_get_fmu_state_req* mutable_fmi2_import_get_fmu_state_req();
  inline ::fmitcp_proto::fmi2_import_get_fmu_state_req* release_fmi2_import_get_fmu_state_req();
  inline void set_allocated_fmi2_import_get_fmu_state_req(::fmitcp_proto::fmi2_import_get_fmu_state_req* fmi2_import_get_fmu_state_req);

  // optional .fmitcp_proto.fmi2_import_get_fmu_state_res fmi2_import_get_fmu_state_res = 77;
  inline bool has_fmi2_import_get_fmu_state_res() const;
  inline void clear_fmi2_import_get_fmu_state_res();
  static const int kFmi2ImportGetFmuStateResFieldNumber = 77;
  inline const ::fmitcp_proto::fmi2_import_get_fmu_state_res& fmi2_import_get_fmu_state_res() const;
  inline ::fmitcp_proto::fmi2_import_get_fmu_state_res* mutable_fmi2_import_get_fmu_state_res();
  inline ::fmitcp_proto::fmi2_import_get_fmu_state_res* release_fmi2_import_get_fmu_state_res();
  inline void set_allocated_fmi2_import_get_fmu_state_res(::fmitcp_proto::fmi2_import_get_fmu_state_res* fmi2_import_get_fmu_state_res);

  // optional .fmitcp_proto.fmi2_import_set_fmu_state_req fmi2_import_set_fmu_state_req = 78;
  inline bool has_fmi2_import_set_fmu_state_req() const;
  inline void clear_fmi2_import_set_fmu_state_req();
  static const int kFmi2ImportSetFmuStateReqFieldNumber = 78;
  inline const ::fmitcp_proto::fmi2_import_set_fmu_state_req& fmi2_import_set_fmu_state_req() const;
  inline ::fmitcp_proto::fmi2_import_set_fmu_state_req* mutable_fmi2_import_set_fmu_state_req();
  inline ::fmitcp_proto::fmi2_import_set_fmu_state_req* release_fmi2_import_set_fmu_state_req();
  inline void set_allocated_fmi2_import_set_fmu_state_req(::fmitcp_proto::fmi2_import_set_fmu_state_req* fmi2_import_set_fmu_state_req);

  // optional .fmitcp_proto.fmi2_import_set_fmu_state_res fmi2_import_set_fmu_state_res = 79;
  inline bool has_fmi2_import_set_fmu_state_res() const;
  inline void clear_fmi2_import_set_fmu_state_res();
  static const int kFmi2ImportSetFmuStateResFieldNumber = 79;
  inline const ::fmitcp_proto::fmi2_import_set_fmu_state_res& fmi2_import_set_fmu_state_res() const;
  inline ::fmitcp_proto::fmi2_import_set_fmu_state_res* mutable_fmi2_import_set_fmu_state_res();
  inline ::fmitcp_proto::fmi2_import_set_fmu_state_res* release_fmi2_import_set_fmu_state_res();
  inline void set_allocated_fmi2_import_set_fmu_state_res(::fmitcp_proto::fmi2_import_set_fmu_state_res* fmi2_import_set_fmu_state_res);

  // optional .fmitcp_proto.fmi2_import_free_fmu_state_req fmi2_import_free_fmu_state_req = 80;
  inline bool has_fmi2_import_free_fmu_state_req() const;
  inline void clear_fmi2_import_free_fmu_state_req();
  static const int kFmi2ImportFreeFmuStateReqFieldNumber = 80;
  inline const ::fmitcp_proto::fmi2_import_free_fmu_state_req& fmi2_import_free_fmu_state_req() const;
  inline ::fmitcp_proto::fmi2_import_free_fmu_state_req* mutable_fmi2_import_free_fmu_state_req();
  inline ::fmitcp_proto::fmi2_import_free_fmu_state_req* release_fmi2_import_free_fmu_state_req();
  inline void set_allocated_fmi2_import_free_fmu_state_req(::fmitcp_proto::fmi2_import_free_fmu_state_req* fmi2_import_free_fmu_state_req);

  // optional .fmitcp_proto.fmi2_import_free_fmu_state_res fmi2_import_free_fmu_state_res = 81;
  inline bool has_fmi2_import_free_fmu_state_res() const;
  inline void clear_fmi2_import_free_fmu_state_res();
  static const int kFmi2ImportFreeFmuStateResFieldNumber = 81;
  inline const ::fmitcp_proto::fmi2_import_free_fmu_state_res& fmi2_import_free_fmu_state_res() const;
  inline ::fmitcp_proto::fmi2_import_free_fmu_state_res* mutable_fmi2_import_free_fmu_state_res();
  inline ::fmitcp_proto::fmi2_import_free_fmu_state_res* release_fmi2_import_free_fmu_state_res();
  inline void set_allocated_fmi2_import_free_fmu_state_res(::fmitcp_proto::fmi2_import_free_fmu_state_res* fmi2_import_free_fmu_state_res);

  // optional .fmitcp_proto.fmi2_import_get_directional_derivative_req fmi2_import_get_directional_derivative_req = 88;
  inline bool has_fmi2_import_get_directional_derivative_req() const;
  inline void clear_fmi2_import_get_directional_derivative_req();
  static const int kFmi2ImportGetDirectionalDerivativeReqFieldNumber = 88;
  inline const ::fmitcp_proto::fmi2_import_get_directional_derivative_req& fmi2_import_get_directional_derivative_req() const;
  inline ::fmitcp_proto::fmi2_import_get_directional_derivative_req* mutable_fmi2_import_get_directional_derivative_req();
  inline ::fmitcp_proto::fmi2_import_get_directional_derivative_req* release_fmi2_import_get_directional_derivative_req();
  inline void set_allocated_fmi2_import_get_directional_derivative_req(::fmitcp_proto::fmi2_import_get_directional_derivative_req* fmi2_import_get_directional_derivative_req);

  // optional .fmitcp_proto.fmi2_import_get_directional_derivative_res fmi2_import_get_directional_derivative_res = 89;
  inline bool has_fmi2_import_get_directional_derivative_res() const;
  inline void clear_fmi2_import_get_directional_derivative_res();
  static const int kFmi2ImportGetDirectionalDerivativeResFieldNumber = 89;
  inline const ::fmitcp_proto::fmi2_import_get_directional_derivative_res& fmi2_import_get_directional_derivative_res() const;
  inline ::fmitcp_proto::fmi2_import_get_directional_derivative_res* mutable_fmi2_import_get_directional_derivative_res();
  inline ::fmitcp_proto::fmi2_import_get_directional_derivative_res* release_fmi2_import_get_directional_derivative_res();
  inline void set_allocated_fmi2_import_get_directional_derivative_res(::fmitcp_proto::fmi2_import_get_directional_derivative_res* fmi2_import_get_directional_derivative_res);

  // optional .fmitcp_proto.get_xml_req get_xml_req = 90;
  inline bool has_get_xml_req() const;
  inline void clear_get_xml_req();
  static const int kGetXmlReqFieldNumber = 90;
  inline const ::fmitcp_proto::get_xml_req& get_xml_req() const;
  inline ::fmitcp_proto::get_xml_req* mutable_get_xml_req();
  inline ::fmitcp_proto::get_xml_req* release_get_xml_req();
  inline void set_allocated_get_xml_req(::fmitcp_proto::get_xml_req* get_xml_req);

  // optional .fmitcp_proto.get_xml_res get_xml_res = 91;
  inline bool has_get_xml_res() const;
  inline void clear_get_xml_res();
  static const int kGetXmlResFieldNumber = 91;
  inline const ::fmitcp_proto::get_xml_res& get_xml_res() const;
  inline ::fmitcp_proto::get_xml_res* mutable_get_xml_res();
  inline ::fmitcp_proto::get_xml_res* release_get_xml_res();
  inline void set_allocated_get_xml_res(::fmitcp_proto::get_xml_res* get_xml_res);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmitcp_message)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_fmi2_import_instantiate_req();
  inline void clear_has_fmi2_import_instantiate_req();
  inline void set_has_fmi2_import_instantiate_res();
  inline void clear_has_fmi2_import_instantiate_res();
  inline void set_has_fmi2_import_initialize_slave_req();
  inline void clear_has_fmi2_import_initialize_slave_req();
  inline void set_has_fmi2_import_initialize_slave_res();
  inline void clear_has_fmi2_import_initialize_slave_res();
  inline void set_has_fmi2_import_terminate_slave_req();
  inline void clear_has_fmi2_import_terminate_slave_req();
  inline void set_has_fmi2_import_terminate_slave_res();
  inline void clear_has_fmi2_import_terminate_slave_res();
  inline void set_has_fmi2_import_reset_slave_req();
  inline void clear_has_fmi2_import_reset_slave_req();
  inline void set_has_fmi2_import_reset_slave_res();
  inline void clear_has_fmi2_import_reset_slave_res();
  inline void set_has_fmi2_import_free_slave_instance_req();
  inline void clear_has_fmi2_import_free_slave_instance_req();
  inline void set_has_fmi2_import_free_slave_instance_res();
  inline void clear_has_fmi2_import_free_slave_instance_res();
  inline void set_has_fmi2_import_set_real_input_derivatives_req();
  inline void clear_has_fmi2_import_set_real_input_derivatives_req();
  inline void set_has_fmi2_import_set_real_input_derivatives_res();
  inline void clear_has_fmi2_import_set_real_input_derivatives_res();
  inline void set_has_fmi2_import_get_real_output_derivatives_req();
  inline void clear_has_fmi2_import_get_real_output_derivatives_req();
  inline void set_has_fmi2_import_get_real_output_derivatives_res();
  inline void clear_has_fmi2_import_get_real_output_derivatives_res();
  inline void set_has_fmi2_import_cancel_step_req();
  inline void clear_has_fmi2_import_cancel_step_req();
  inline void set_has_fmi2_import_cancel_step_res();
  inline void clear_has_fmi2_import_cancel_step_res();
  inline void set_has_fmi2_import_do_step_req();
  inline void clear_has_fmi2_import_do_step_req();
  inline void set_has_fmi2_import_do_step_res();
  inline void clear_has_fmi2_import_do_step_res();
  inline void set_has_fmi2_import_get_status_req();
  inline void clear_has_fmi2_import_get_status_req();
  inline void set_has_fmi2_import_get_status_res();
  inline void clear_has_fmi2_import_get_status_res();
  inline void set_has_fmi2_import_get_real_status_req();
  inline void clear_has_fmi2_import_get_real_status_req();
  inline void set_has_fmi2_import_get_real_status_res();
  inline void clear_has_fmi2_import_get_real_status_res();
  inline void set_has_fmi2_import_get_integer_status_req();
  inline void clear_has_fmi2_import_get_integer_status_req();
  inline void set_has_fmi2_import_get_integer_status_res();
  inline void clear_has_fmi2_import_get_integer_status_res();
  inline void set_has_fmi2_import_get_boolean_status_req();
  inline void clear_has_fmi2_import_get_boolean_status_req();
  inline void set_has_fmi2_import_get_boolean_status_res();
  inline void clear_has_fmi2_import_get_boolean_status_res();
  inline void set_has_fmi2_import_get_string_status_req();
  inline void clear_has_fmi2_import_get_string_status_req();
  inline void set_has_fmi2_import_get_string_status_res();
  inline void clear_has_fmi2_import_get_string_status_res();
  inline void set_has_fmi2_import_instantiate_model_req();
  inline void clear_has_fmi2_import_instantiate_model_req();
  inline void set_has_fmi2_import_instantiate_model_res();
  inline void clear_has_fmi2_import_instantiate_model_res();
  inline void set_has_fmi2_import_free_model_instance_req();
  inline void clear_has_fmi2_import_free_model_instance_req();
  inline void set_has_fmi2_import_free_model_instance_res();
  inline void clear_has_fmi2_import_free_model_instance_res();
  inline void set_has_fmi2_import_set_time_req();
  inline void clear_has_fmi2_import_set_time_req();
  inline void set_has_fmi2_import_set_time_res();
  inline void clear_has_fmi2_import_set_time_res();
  inline void set_has_fmi2_import_set_continuous_states_req();
  inline void clear_has_fmi2_import_set_continuous_states_req();
  inline void set_has_fmi2_import_set_continuous_states_res();
  inline void clear_has_fmi2_import_set_continuous_states_res();
  inline void set_has_fmi2_import_completed_integrator_step_req();
  inline void clear_has_fmi2_import_completed_integrator_step_req();
  inline void set_has_fmi2_import_completed_integrator_step_res();
  inline void clear_has_fmi2_import_completed_integrator_step_res();
  inline void set_has_fmi2_import_initialize_model_req();
  inline void clear_has_fmi2_import_initialize_model_req();
  inline void set_has_fmi2_import_initialize_model_res();
  inline void clear_has_fmi2_import_initialize_model_res();
  inline void set_has_fmi2_import_get_derivatives_req();
  inline void clear_has_fmi2_import_get_derivatives_req();
  inline void set_has_fmi2_import_get_derivatives_res();
  inline void clear_has_fmi2_import_get_derivatives_res();
  inline void set_has_fmi2_import_get_event_indicators_req();
  inline void clear_has_fmi2_import_get_event_indicators_req();
  inline void set_has_fmi2_import_get_event_indicators_res();
  inline void clear_has_fmi2_import_get_event_indicators_res();
  inline void set_has_fmi2_import_eventupdate_req();
  inline void clear_has_fmi2_import_eventupdate_req();
  inline void set_has_fmi2_import_eventupdate_res();
  inline void clear_has_fmi2_import_eventupdate_res();
  inline void set_has_fmi2_import_completed_event_iteration_req();
  inline void clear_has_fmi2_import_completed_event_iteration_req();
  inline void set_has_fmi2_import_completed_event_iteration_res();
  inline void clear_has_fmi2_import_completed_event_iteration_res();
  inline void set_has_fmi2_import_get_continuous_states_req();
  inline void clear_has_fmi2_import_get_continuous_states_req();
  inline void set_has_fmi2_import_get_continuous_states_res();
  inline void clear_has_fmi2_import_get_continuous_states_res();
  inline void set_has_fmi2_import_get_nominal_continuous_states_req();
  inline void clear_has_fmi2_import_get_nominal_continuous_states_req();
  inline void set_has_fmi2_import_get_nominal_continuous_states_res();
  inline void clear_has_fmi2_import_get_nominal_continuous_states_res();
  inline void set_has_fmi2_import_terminate_req();
  inline void clear_has_fmi2_import_terminate_req();
  inline void set_has_fmi2_import_terminate_res();
  inline void clear_has_fmi2_import_terminate_res();
  inline void set_has_fmi2_import_get_version_req();
  inline void clear_has_fmi2_import_get_version_req();
  inline void set_has_fmi2_import_get_version_res();
  inline void clear_has_fmi2_import_get_version_res();
  inline void set_has_fmi2_import_set_debug_logging_req();
  inline void clear_has_fmi2_import_set_debug_logging_req();
  inline void set_has_fmi2_import_set_debug_logging_res();
  inline void clear_has_fmi2_import_set_debug_logging_res();
  inline void set_has_fmi2_import_set_real_req();
  inline void clear_has_fmi2_import_set_real_req();
  inline void set_has_fmi2_import_set_real_res();
  inline void clear_has_fmi2_import_set_real_res();
  inline void set_has_fmi2_import_set_integer_req();
  inline void clear_has_fmi2_import_set_integer_req();
  inline void set_has_fmi2_import_set_integer_res();
  inline void clear_has_fmi2_import_set_integer_res();
  inline void set_has_fmi2_import_set_boolean_req();
  inline void clear_has_fmi2_import_set_boolean_req();
  inline void set_has_fmi2_import_set_boolean_res();
  inline void clear_has_fmi2_import_set_boolean_res();
  inline void set_has_fmi2_import_set_string_req();
  inline void clear_has_fmi2_import_set_string_req();
  inline void set_has_fmi2_import_set_string_res();
  inline void clear_has_fmi2_import_set_string_res();
  inline void set_has_fmi2_import_get_real_req();
  inline void clear_has_fmi2_import_get_real_req();
  inline void set_has_fmi2_import_get_real_res();
  inline void clear_has_fmi2_import_get_real_res();
  inline void set_has_fmi2_import_get_integer_req();
  inline void clear_has_fmi2_import_get_integer_req();
  inline void set_has_fmi2_import_get_integer_res();
  inline void clear_has_fmi2_import_get_integer_res();
  inline void set_has_fmi2_import_get_boolean_req();
  inline void clear_has_fmi2_import_get_boolean_req();
  inline void set_has_fmi2_import_get_boolean_res();
  inline void clear_has_fmi2_import_get_boolean_res();
  inline void set_has_fmi2_import_get_string_req();
  inline void clear_has_fmi2_import_get_string_req();
  inline void set_has_fmi2_import_get_string_res();
  inline void clear_has_fmi2_import_get_string_res();
  inline void set_has_fmi2_import_get_fmu_state_req();
  inline void clear_has_fmi2_import_get_fmu_state_req();
  inline void set_has_fmi2_import_get_fmu_state_res();
  inline void clear_has_fmi2_import_get_fmu_state_res();
  inline void set_has_fmi2_import_set_fmu_state_req();
  inline void clear_has_fmi2_import_set_fmu_state_req();
  inline void set_has_fmi2_import_set_fmu_state_res();
  inline void clear_has_fmi2_import_set_fmu_state_res();
  inline void set_has_fmi2_import_free_fmu_state_req();
  inline void clear_has_fmi2_import_free_fmu_state_req();
  inline void set_has_fmi2_import_free_fmu_state_res();
  inline void clear_has_fmi2_import_free_fmu_state_res();
  inline void set_has_fmi2_import_get_directional_derivative_req();
  inline void clear_has_fmi2_import_get_directional_derivative_req();
  inline void set_has_fmi2_import_get_directional_derivative_res();
  inline void clear_has_fmi2_import_get_directional_derivative_res();
  inline void set_has_get_xml_req();
  inline void clear_has_get_xml_req();
  inline void set_has_get_xml_res();
  inline void clear_has_get_xml_res();

  ::fmitcp_proto::fmi2_import_instantiate_req* fmi2_import_instantiate_req_;
  ::fmitcp_proto::fmi2_import_instantiate_res* fmi2_import_instantiate_res_;
  ::fmitcp_proto::fmi2_import_initialize_slave_req* fmi2_import_initialize_slave_req_;
  ::fmitcp_proto::fmi2_import_initialize_slave_res* fmi2_import_initialize_slave_res_;
  ::fmitcp_proto::fmi2_import_terminate_slave_req* fmi2_import_terminate_slave_req_;
  ::fmitcp_proto::fmi2_import_terminate_slave_res* fmi2_import_terminate_slave_res_;
  ::fmitcp_proto::fmi2_import_reset_slave_req* fmi2_import_reset_slave_req_;
  ::fmitcp_proto::fmi2_import_reset_slave_res* fmi2_import_reset_slave_res_;
  ::fmitcp_proto::fmi2_import_free_slave_instance_req* fmi2_import_free_slave_instance_req_;
  ::fmitcp_proto::fmi2_import_free_slave_instance_res* fmi2_import_free_slave_instance_res_;
  ::fmitcp_proto::fmi2_import_set_real_input_derivatives_req* fmi2_import_set_real_input_derivatives_req_;
  ::fmitcp_proto::fmi2_import_set_real_input_derivatives_res* fmi2_import_set_real_input_derivatives_res_;
  ::fmitcp_proto::fmi2_import_get_real_output_derivatives_req* fmi2_import_get_real_output_derivatives_req_;
  ::fmitcp_proto::fmi2_import_get_real_output_derivatives_res* fmi2_import_get_real_output_derivatives_res_;
  ::fmitcp_proto::fmi2_import_cancel_step_req* fmi2_import_cancel_step_req_;
  ::fmitcp_proto::fmi2_import_cancel_step_res* fmi2_import_cancel_step_res_;
  ::fmitcp_proto::fmi2_import_do_step_req* fmi2_import_do_step_req_;
  ::fmitcp_proto::fmi2_import_do_step_res* fmi2_import_do_step_res_;
  ::fmitcp_proto::fmi2_import_get_status_req* fmi2_import_get_status_req_;
  ::fmitcp_proto::fmi2_import_get_status_res* fmi2_import_get_status_res_;
  ::fmitcp_proto::fmi2_import_get_real_status_req* fmi2_import_get_real_status_req_;
  ::fmitcp_proto::fmi2_import_get_real_status_res* fmi2_import_get_real_status_res_;
  ::fmitcp_proto::fmi2_import_get_integer_status_req* fmi2_import_get_integer_status_req_;
  ::fmitcp_proto::fmi2_import_get_integer_status_res* fmi2_import_get_integer_status_res_;
  ::fmitcp_proto::fmi2_import_get_boolean_status_req* fmi2_import_get_boolean_status_req_;
  ::fmitcp_proto::fmi2_import_get_boolean_status_res* fmi2_import_get_boolean_status_res_;
  ::fmitcp_proto::fmi2_import_get_string_status_req* fmi2_import_get_string_status_req_;
  ::fmitcp_proto::fmi2_import_get_string_status_res* fmi2_import_get_string_status_res_;
  ::fmitcp_proto::fmi2_import_instantiate_model_req* fmi2_import_instantiate_model_req_;
  ::fmitcp_proto::fmi2_import_instantiate_model_res* fmi2_import_instantiate_model_res_;
  ::fmitcp_proto::fmi2_import_free_model_instance_req* fmi2_import_free_model_instance_req_;
  ::fmitcp_proto::fmi2_import_free_model_instance_res* fmi2_import_free_model_instance_res_;
  ::fmitcp_proto::fmi2_import_set_time_req* fmi2_import_set_time_req_;
  ::fmitcp_proto::fmi2_import_set_time_res* fmi2_import_set_time_res_;
  ::fmitcp_proto::fmi2_import_set_continuous_states_req* fmi2_import_set_continuous_states_req_;
  ::fmitcp_proto::fmi2_import_set_continuous_states_res* fmi2_import_set_continuous_states_res_;
  ::fmitcp_proto::fmi2_import_completed_integrator_step_req* fmi2_import_completed_integrator_step_req_;
  ::fmitcp_proto::fmi2_import_completed_integrator_step_res* fmi2_import_completed_integrator_step_res_;
  ::fmitcp_proto::fmi2_import_initialize_model_req* fmi2_import_initialize_model_req_;
  ::fmitcp_proto::fmi2_import_initialize_model_res* fmi2_import_initialize_model_res_;
  ::fmitcp_proto::fmi2_import_get_derivatives_req* fmi2_import_get_derivatives_req_;
  ::fmitcp_proto::fmi2_import_get_derivatives_res* fmi2_import_get_derivatives_res_;
  ::fmitcp_proto::fmi2_import_get_event_indicators_req* fmi2_import_get_event_indicators_req_;
  ::fmitcp_proto::fmi2_import_get_event_indicators_res* fmi2_import_get_event_indicators_res_;
  ::fmitcp_proto::fmi2_import_eventUpdate_req* fmi2_import_eventupdate_req_;
  ::fmitcp_proto::fmi2_import_eventUpdate_res* fmi2_import_eventupdate_res_;
  ::fmitcp_proto::fmi2_import_completed_event_iteration_req* fmi2_import_completed_event_iteration_req_;
  ::fmitcp_proto::fmi2_import_completed_event_iteration_res* fmi2_import_completed_event_iteration_res_;
  ::fmitcp_proto::fmi2_import_get_continuous_states_req* fmi2_import_get_continuous_states_req_;
  ::fmitcp_proto::fmi2_import_get_continuous_states_res* fmi2_import_get_continuous_states_res_;
  ::fmitcp_proto::fmi2_import_get_nominal_continuous_states_req* fmi2_import_get_nominal_continuous_states_req_;
  ::fmitcp_proto::fmi2_import_get_nominal_continuous_states_res* fmi2_import_get_nominal_continuous_states_res_;
  ::fmitcp_proto::fmi2_import_terminate_req* fmi2_import_terminate_req_;
  ::fmitcp_proto::fmi2_import_terminate_res* fmi2_import_terminate_res_;
  ::fmitcp_proto::fmi2_import_get_version_req* fmi2_import_get_version_req_;
  ::fmitcp_proto::fmi2_import_get_version_res* fmi2_import_get_version_res_;
  ::fmitcp_proto::fmi2_import_set_debug_logging_req* fmi2_import_set_debug_logging_req_;
  ::fmitcp_proto::fmi2_import_set_debug_logging_res* fmi2_import_set_debug_logging_res_;
  ::fmitcp_proto::fmi2_import_set_real_req* fmi2_import_set_real_req_;
  ::fmitcp_proto::fmi2_import_set_real_res* fmi2_import_set_real_res_;
  ::fmitcp_proto::fmi2_import_set_integer_req* fmi2_import_set_integer_req_;
  ::fmitcp_proto::fmi2_import_set_integer_res* fmi2_import_set_integer_res_;
  ::fmitcp_proto::fmi2_import_set_boolean_req* fmi2_import_set_boolean_req_;
  ::fmitcp_proto::fmi2_import_set_boolean_res* fmi2_import_set_boolean_res_;
  ::fmitcp_proto::fmi2_import_set_string_req* fmi2_import_set_string_req_;
  ::fmitcp_proto::fmi2_import_set_string_res* fmi2_import_set_string_res_;
  ::fmitcp_proto::fmi2_import_get_real_req* fmi2_import_get_real_req_;
  ::fmitcp_proto::fmi2_import_get_real_res* fmi2_import_get_real_res_;
  ::fmitcp_proto::fmi2_import_get_integer_req* fmi2_import_get_integer_req_;
  ::fmitcp_proto::fmi2_import_get_integer_res* fmi2_import_get_integer_res_;
  ::fmitcp_proto::fmi2_import_get_boolean_req* fmi2_import_get_boolean_req_;
  ::fmitcp_proto::fmi2_import_get_boolean_res* fmi2_import_get_boolean_res_;
  ::fmitcp_proto::fmi2_import_get_string_req* fmi2_import_get_string_req_;
  ::fmitcp_proto::fmi2_import_get_string_res* fmi2_import_get_string_res_;
  ::fmitcp_proto::fmi2_import_get_fmu_state_req* fmi2_import_get_fmu_state_req_;
  ::fmitcp_proto::fmi2_import_get_fmu_state_res* fmi2_import_get_fmu_state_res_;
  ::fmitcp_proto::fmi2_import_set_fmu_state_req* fmi2_import_set_fmu_state_req_;
  ::fmitcp_proto::fmi2_import_set_fmu_state_res* fmi2_import_set_fmu_state_res_;
  ::fmitcp_proto::fmi2_import_free_fmu_state_req* fmi2_import_free_fmu_state_req_;
  ::fmitcp_proto::fmi2_import_free_fmu_state_res* fmi2_import_free_fmu_state_res_;
  ::fmitcp_proto::fmi2_import_get_directional_derivative_req* fmi2_import_get_directional_derivative_req_;
  ::fmitcp_proto::fmi2_import_get_directional_derivative_res* fmi2_import_get_directional_derivative_res_;
  ::fmitcp_proto::get_xml_req* get_xml_req_;
  ::fmitcp_proto::get_xml_res* get_xml_res_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(85 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmitcp_message* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_event_info_t : public ::google::protobuf::MessageLite {
 public:
  fmi2_event_info_t();
  virtual ~fmi2_event_info_t();

  fmi2_event_info_t(const fmi2_event_info_t& from);

  inline fmi2_event_info_t& operator=(const fmi2_event_info_t& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_event_info_t& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_event_info_t* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_event_info_t* other);

  // implements Message ----------------------------------------------

  fmi2_event_info_t* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_event_info_t& from);
  void MergeFrom(const fmi2_event_info_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool iterationConverged = 1;
  inline bool has_iterationconverged() const;
  inline void clear_iterationconverged();
  static const int kIterationConvergedFieldNumber = 1;
  inline bool iterationconverged() const;
  inline void set_iterationconverged(bool value);

  // required bool stateValueReferencesChanged = 2;
  inline bool has_statevaluereferenceschanged() const;
  inline void clear_statevaluereferenceschanged();
  static const int kStateValueReferencesChangedFieldNumber = 2;
  inline bool statevaluereferenceschanged() const;
  inline void set_statevaluereferenceschanged(bool value);

  // required bool stateValuesChanged = 3;
  inline bool has_statevalueschanged() const;
  inline void clear_statevalueschanged();
  static const int kStateValuesChangedFieldNumber = 3;
  inline bool statevalueschanged() const;
  inline void set_statevalueschanged(bool value);

  // required bool terminateSimulation = 4;
  inline bool has_terminatesimulation() const;
  inline void clear_terminatesimulation();
  static const int kTerminateSimulationFieldNumber = 4;
  inline bool terminatesimulation() const;
  inline void set_terminatesimulation(bool value);

  // required bool upcomingTimeEvent = 5;
  inline bool has_upcomingtimeevent() const;
  inline void clear_upcomingtimeevent();
  static const int kUpcomingTimeEventFieldNumber = 5;
  inline bool upcomingtimeevent() const;
  inline void set_upcomingtimeevent(bool value);

  // required double nextEventTime = 6;
  inline bool has_nexteventtime() const;
  inline void clear_nexteventtime();
  static const int kNextEventTimeFieldNumber = 6;
  inline double nexteventtime() const;
  inline void set_nexteventtime(double value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_event_info_t)
 private:
  inline void set_has_iterationconverged();
  inline void clear_has_iterationconverged();
  inline void set_has_statevaluereferenceschanged();
  inline void clear_has_statevaluereferenceschanged();
  inline void set_has_statevalueschanged();
  inline void clear_has_statevalueschanged();
  inline void set_has_terminatesimulation();
  inline void clear_has_terminatesimulation();
  inline void set_has_upcomingtimeevent();
  inline void clear_has_upcomingtimeevent();
  inline void set_has_nexteventtime();
  inline void clear_has_nexteventtime();

  bool iterationconverged_;
  bool statevaluereferenceschanged_;
  bool statevalueschanged_;
  bool terminatesimulation_;
  bool upcomingtimeevent_;
  double nexteventtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_event_info_t* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_instantiate_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_instantiate_req();
  virtual ~fmi2_import_instantiate_req();

  fmi2_import_instantiate_req(const fmi2_import_instantiate_req& from);

  inline fmi2_import_instantiate_req& operator=(const fmi2_import_instantiate_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_instantiate_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_instantiate_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_instantiate_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_instantiate_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_instantiate_req& from);
  void MergeFrom(const fmi2_import_instantiate_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // optional bool visible = 2;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 2;
  inline bool visible() const;
  inline void set_visible(bool value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_instantiate_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_visible();
  inline void clear_has_visible();

  ::google::protobuf::int32 message_id_;
  bool visible_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_instantiate_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_instantiate_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_instantiate_res();
  virtual ~fmi2_import_instantiate_res();

  fmi2_import_instantiate_res(const fmi2_import_instantiate_res& from);

  inline fmi2_import_instantiate_res& operator=(const fmi2_import_instantiate_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_instantiate_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_instantiate_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_instantiate_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_instantiate_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_instantiate_res& from);
  void MergeFrom(const fmi2_import_instantiate_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.jm_status_enu_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::jm_status_enu_t status() const;
  inline void set_status(::fmitcp_proto::jm_status_enu_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_instantiate_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_instantiate_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_initialize_slave_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_initialize_slave_req();
  virtual ~fmi2_import_initialize_slave_req();

  fmi2_import_initialize_slave_req(const fmi2_import_initialize_slave_req& from);

  inline fmi2_import_initialize_slave_req& operator=(const fmi2_import_initialize_slave_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_initialize_slave_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_initialize_slave_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_initialize_slave_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_initialize_slave_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_initialize_slave_req& from);
  void MergeFrom(const fmi2_import_initialize_slave_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // required bool toleranceDefined = 3;
  inline bool has_tolerancedefined() const;
  inline void clear_tolerancedefined();
  static const int kToleranceDefinedFieldNumber = 3;
  inline bool tolerancedefined() const;
  inline void set_tolerancedefined(bool value);

  // required double tolerance = 4;
  inline bool has_tolerance() const;
  inline void clear_tolerance();
  static const int kToleranceFieldNumber = 4;
  inline double tolerance() const;
  inline void set_tolerance(double value);

  // required double startTime = 5;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 5;
  inline double starttime() const;
  inline void set_starttime(double value);

  // required bool stopTimeDefined = 6;
  inline bool has_stoptimedefined() const;
  inline void clear_stoptimedefined();
  static const int kStopTimeDefinedFieldNumber = 6;
  inline bool stoptimedefined() const;
  inline void set_stoptimedefined(bool value);

  // required double stopTime = 7;
  inline bool has_stoptime() const;
  inline void clear_stoptime();
  static const int kStopTimeFieldNumber = 7;
  inline double stoptime() const;
  inline void set_stoptime(double value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_initialize_slave_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();
  inline void set_has_tolerancedefined();
  inline void clear_has_tolerancedefined();
  inline void set_has_tolerance();
  inline void clear_has_tolerance();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_stoptimedefined();
  inline void clear_has_stoptimedefined();
  inline void set_has_stoptime();
  inline void clear_has_stoptime();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  double tolerance_;
  double starttime_;
  double stoptime_;
  bool tolerancedefined_;
  bool stoptimedefined_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_initialize_slave_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_initialize_slave_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_initialize_slave_res();
  virtual ~fmi2_import_initialize_slave_res();

  fmi2_import_initialize_slave_res(const fmi2_import_initialize_slave_res& from);

  inline fmi2_import_initialize_slave_res& operator=(const fmi2_import_initialize_slave_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_initialize_slave_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_initialize_slave_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_initialize_slave_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_initialize_slave_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_initialize_slave_res& from);
  void MergeFrom(const fmi2_import_initialize_slave_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_initialize_slave_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_initialize_slave_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_terminate_slave_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_terminate_slave_req();
  virtual ~fmi2_import_terminate_slave_req();

  fmi2_import_terminate_slave_req(const fmi2_import_terminate_slave_req& from);

  inline fmi2_import_terminate_slave_req& operator=(const fmi2_import_terminate_slave_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_terminate_slave_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_terminate_slave_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_terminate_slave_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_terminate_slave_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_terminate_slave_req& from);
  void MergeFrom(const fmi2_import_terminate_slave_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_terminate_slave_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_terminate_slave_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_terminate_slave_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_terminate_slave_res();
  virtual ~fmi2_import_terminate_slave_res();

  fmi2_import_terminate_slave_res(const fmi2_import_terminate_slave_res& from);

  inline fmi2_import_terminate_slave_res& operator=(const fmi2_import_terminate_slave_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_terminate_slave_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_terminate_slave_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_terminate_slave_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_terminate_slave_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_terminate_slave_res& from);
  void MergeFrom(const fmi2_import_terminate_slave_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_terminate_slave_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_terminate_slave_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_reset_slave_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_reset_slave_req();
  virtual ~fmi2_import_reset_slave_req();

  fmi2_import_reset_slave_req(const fmi2_import_reset_slave_req& from);

  inline fmi2_import_reset_slave_req& operator=(const fmi2_import_reset_slave_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_reset_slave_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_reset_slave_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_reset_slave_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_reset_slave_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_reset_slave_req& from);
  void MergeFrom(const fmi2_import_reset_slave_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_reset_slave_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_reset_slave_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_reset_slave_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_reset_slave_res();
  virtual ~fmi2_import_reset_slave_res();

  fmi2_import_reset_slave_res(const fmi2_import_reset_slave_res& from);

  inline fmi2_import_reset_slave_res& operator=(const fmi2_import_reset_slave_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_reset_slave_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_reset_slave_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_reset_slave_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_reset_slave_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_reset_slave_res& from);
  void MergeFrom(const fmi2_import_reset_slave_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_reset_slave_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_reset_slave_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_free_slave_instance_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_free_slave_instance_req();
  virtual ~fmi2_import_free_slave_instance_req();

  fmi2_import_free_slave_instance_req(const fmi2_import_free_slave_instance_req& from);

  inline fmi2_import_free_slave_instance_req& operator=(const fmi2_import_free_slave_instance_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_free_slave_instance_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_free_slave_instance_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_free_slave_instance_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_free_slave_instance_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_free_slave_instance_req& from);
  void MergeFrom(const fmi2_import_free_slave_instance_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_free_slave_instance_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_free_slave_instance_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_free_slave_instance_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_free_slave_instance_res();
  virtual ~fmi2_import_free_slave_instance_res();

  fmi2_import_free_slave_instance_res(const fmi2_import_free_slave_instance_res& from);

  inline fmi2_import_free_slave_instance_res& operator=(const fmi2_import_free_slave_instance_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_free_slave_instance_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_free_slave_instance_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_free_slave_instance_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_free_slave_instance_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_free_slave_instance_res& from);
  void MergeFrom(const fmi2_import_free_slave_instance_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_free_slave_instance_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();

  ::google::protobuf::int32 message_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_free_slave_instance_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_set_real_input_derivatives_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_set_real_input_derivatives_req();
  virtual ~fmi2_import_set_real_input_derivatives_req();

  fmi2_import_set_real_input_derivatives_req(const fmi2_import_set_real_input_derivatives_req& from);

  inline fmi2_import_set_real_input_derivatives_req& operator=(const fmi2_import_set_real_input_derivatives_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_set_real_input_derivatives_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_set_real_input_derivatives_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_set_real_input_derivatives_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_set_real_input_derivatives_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_set_real_input_derivatives_req& from);
  void MergeFrom(const fmi2_import_set_real_input_derivatives_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // repeated int32 valueReferences = 3 [packed = true];
  inline int valuereferences_size() const;
  inline void clear_valuereferences();
  static const int kValueReferencesFieldNumber = 3;
  inline ::google::protobuf::int32 valuereferences(int index) const;
  inline void set_valuereferences(int index, ::google::protobuf::int32 value);
  inline void add_valuereferences(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      valuereferences() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_valuereferences();

  // repeated int32 orders = 4 [packed = true];
  inline int orders_size() const;
  inline void clear_orders();
  static const int kOrdersFieldNumber = 4;
  inline ::google::protobuf::int32 orders(int index) const;
  inline void set_orders(int index, ::google::protobuf::int32 value);
  inline void add_orders(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      orders() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_orders();

  // repeated double values = 5 [packed = true];
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 5;
  inline double values(int index) const;
  inline void set_values(int index, double value);
  inline void add_values(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      values() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_set_real_input_derivatives_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > valuereferences_;
  mutable int _valuereferences_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > orders_;
  mutable int _orders_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > values_;
  mutable int _values_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_set_real_input_derivatives_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_set_real_input_derivatives_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_set_real_input_derivatives_res();
  virtual ~fmi2_import_set_real_input_derivatives_res();

  fmi2_import_set_real_input_derivatives_res(const fmi2_import_set_real_input_derivatives_res& from);

  inline fmi2_import_set_real_input_derivatives_res& operator=(const fmi2_import_set_real_input_derivatives_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_set_real_input_derivatives_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_set_real_input_derivatives_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_set_real_input_derivatives_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_set_real_input_derivatives_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_set_real_input_derivatives_res& from);
  void MergeFrom(const fmi2_import_set_real_input_derivatives_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_set_real_input_derivatives_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_set_real_input_derivatives_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_real_output_derivatives_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_real_output_derivatives_req();
  virtual ~fmi2_import_get_real_output_derivatives_req();

  fmi2_import_get_real_output_derivatives_req(const fmi2_import_get_real_output_derivatives_req& from);

  inline fmi2_import_get_real_output_derivatives_req& operator=(const fmi2_import_get_real_output_derivatives_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_real_output_derivatives_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_real_output_derivatives_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_real_output_derivatives_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_real_output_derivatives_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_real_output_derivatives_req& from);
  void MergeFrom(const fmi2_import_get_real_output_derivatives_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // repeated int32 valueReferences = 3 [packed = true];
  inline int valuereferences_size() const;
  inline void clear_valuereferences();
  static const int kValueReferencesFieldNumber = 3;
  inline ::google::protobuf::int32 valuereferences(int index) const;
  inline void set_valuereferences(int index, ::google::protobuf::int32 value);
  inline void add_valuereferences(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      valuereferences() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_valuereferences();

  // repeated int32 orders = 4 [packed = true];
  inline int orders_size() const;
  inline void clear_orders();
  static const int kOrdersFieldNumber = 4;
  inline ::google::protobuf::int32 orders(int index) const;
  inline void set_orders(int index, ::google::protobuf::int32 value);
  inline void add_orders(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      orders() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_orders();

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_real_output_derivatives_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > valuereferences_;
  mutable int _valuereferences_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > orders_;
  mutable int _orders_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_real_output_derivatives_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_real_output_derivatives_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_real_output_derivatives_res();
  virtual ~fmi2_import_get_real_output_derivatives_res();

  fmi2_import_get_real_output_derivatives_res(const fmi2_import_get_real_output_derivatives_res& from);

  inline fmi2_import_get_real_output_derivatives_res& operator=(const fmi2_import_get_real_output_derivatives_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_real_output_derivatives_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_real_output_derivatives_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_real_output_derivatives_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_real_output_derivatives_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_real_output_derivatives_res& from);
  void MergeFrom(const fmi2_import_get_real_output_derivatives_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // repeated double values = 3 [packed = true];
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 3;
  inline double values(int index) const;
  inline void set_values(int index, double value);
  inline void add_values(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      values() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_real_output_derivatives_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;
  ::google::protobuf::RepeatedField< double > values_;
  mutable int _values_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_real_output_derivatives_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_cancel_step_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_cancel_step_req();
  virtual ~fmi2_import_cancel_step_req();

  fmi2_import_cancel_step_req(const fmi2_import_cancel_step_req& from);

  inline fmi2_import_cancel_step_req& operator=(const fmi2_import_cancel_step_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_cancel_step_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_cancel_step_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_cancel_step_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_cancel_step_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_cancel_step_req& from);
  void MergeFrom(const fmi2_import_cancel_step_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_cancel_step_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_cancel_step_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_cancel_step_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_cancel_step_res();
  virtual ~fmi2_import_cancel_step_res();

  fmi2_import_cancel_step_res(const fmi2_import_cancel_step_res& from);

  inline fmi2_import_cancel_step_res& operator=(const fmi2_import_cancel_step_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_cancel_step_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_cancel_step_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_cancel_step_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_cancel_step_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_cancel_step_res& from);
  void MergeFrom(const fmi2_import_cancel_step_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_cancel_step_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_cancel_step_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_do_step_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_do_step_req();
  virtual ~fmi2_import_do_step_req();

  fmi2_import_do_step_req(const fmi2_import_do_step_req& from);

  inline fmi2_import_do_step_req& operator=(const fmi2_import_do_step_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_do_step_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_do_step_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_do_step_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_do_step_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_do_step_req& from);
  void MergeFrom(const fmi2_import_do_step_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // required double currentCommunicationPoint = 3;
  inline bool has_currentcommunicationpoint() const;
  inline void clear_currentcommunicationpoint();
  static const int kCurrentCommunicationPointFieldNumber = 3;
  inline double currentcommunicationpoint() const;
  inline void set_currentcommunicationpoint(double value);

  // required double communicationStepSize = 4;
  inline bool has_communicationstepsize() const;
  inline void clear_communicationstepsize();
  static const int kCommunicationStepSizeFieldNumber = 4;
  inline double communicationstepsize() const;
  inline void set_communicationstepsize(double value);

  // required bool newStep = 5;
  inline bool has_newstep() const;
  inline void clear_newstep();
  static const int kNewStepFieldNumber = 5;
  inline bool newstep() const;
  inline void set_newstep(bool value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_do_step_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();
  inline void set_has_currentcommunicationpoint();
  inline void clear_has_currentcommunicationpoint();
  inline void set_has_communicationstepsize();
  inline void clear_has_communicationstepsize();
  inline void set_has_newstep();
  inline void clear_has_newstep();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  double currentcommunicationpoint_;
  double communicationstepsize_;
  bool newstep_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_do_step_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_do_step_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_do_step_res();
  virtual ~fmi2_import_do_step_res();

  fmi2_import_do_step_res(const fmi2_import_do_step_res& from);

  inline fmi2_import_do_step_res& operator=(const fmi2_import_do_step_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_do_step_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_do_step_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_do_step_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_do_step_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_do_step_res& from);
  void MergeFrom(const fmi2_import_do_step_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_do_step_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_do_step_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_status_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_status_req();
  virtual ~fmi2_import_get_status_req();

  fmi2_import_get_status_req(const fmi2_import_get_status_req& from);

  inline fmi2_import_get_status_req& operator=(const fmi2_import_get_status_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_status_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_status_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_status_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_status_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_status_req& from);
  void MergeFrom(const fmi2_import_get_status_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_kind_t status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::fmitcp_proto::fmi2_status_kind_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_kind_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_status_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_status_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_status_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_status_res();
  virtual ~fmi2_import_get_status_res();

  fmi2_import_get_status_res(const fmi2_import_get_status_res& from);

  inline fmi2_import_get_status_res& operator=(const fmi2_import_get_status_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_status_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_status_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_status_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_status_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_status_res& from);
  void MergeFrom(const fmi2_import_get_status_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::fmitcp_proto::fmi2_status_t value() const;
  inline void set_value(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_status_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::int32 message_id_;
  int value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_status_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_real_status_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_real_status_req();
  virtual ~fmi2_import_get_real_status_req();

  fmi2_import_get_real_status_req(const fmi2_import_get_real_status_req& from);

  inline fmi2_import_get_real_status_req& operator=(const fmi2_import_get_real_status_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_real_status_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_real_status_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_real_status_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_real_status_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_real_status_req& from);
  void MergeFrom(const fmi2_import_get_real_status_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_kind_t kind = 3;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 3;
  inline ::fmitcp_proto::fmi2_status_kind_t kind() const;
  inline void set_kind(::fmitcp_proto::fmi2_status_kind_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_real_status_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();
  inline void set_has_kind();
  inline void clear_has_kind();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  int kind_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_real_status_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_real_status_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_real_status_res();
  virtual ~fmi2_import_get_real_status_res();

  fmi2_import_get_real_status_res(const fmi2_import_get_real_status_res& from);

  inline fmi2_import_get_real_status_res& operator=(const fmi2_import_get_real_status_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_real_status_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_real_status_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_real_status_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_real_status_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_real_status_res& from);
  void MergeFrom(const fmi2_import_get_real_status_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required double value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value() const;
  inline void set_value(double value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_real_status_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_value();
  inline void clear_has_value();

  double value_;
  ::google::protobuf::int32 message_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_real_status_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_integer_status_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_integer_status_req();
  virtual ~fmi2_import_get_integer_status_req();

  fmi2_import_get_integer_status_req(const fmi2_import_get_integer_status_req& from);

  inline fmi2_import_get_integer_status_req& operator=(const fmi2_import_get_integer_status_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_integer_status_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_integer_status_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_integer_status_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_integer_status_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_integer_status_req& from);
  void MergeFrom(const fmi2_import_get_integer_status_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_kind_t kind = 3;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 3;
  inline ::fmitcp_proto::fmi2_status_kind_t kind() const;
  inline void set_kind(::fmitcp_proto::fmi2_status_kind_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_integer_status_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();
  inline void set_has_kind();
  inline void clear_has_kind();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  int kind_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_integer_status_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_integer_status_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_integer_status_res();
  virtual ~fmi2_import_get_integer_status_res();

  fmi2_import_get_integer_status_res(const fmi2_import_get_integer_status_res& from);

  inline fmi2_import_get_integer_status_res& operator=(const fmi2_import_get_integer_status_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_integer_status_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_integer_status_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_integer_status_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_integer_status_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_integer_status_res& from);
  void MergeFrom(const fmi2_import_get_integer_status_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_integer_status_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_integer_status_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_boolean_status_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_boolean_status_req();
  virtual ~fmi2_import_get_boolean_status_req();

  fmi2_import_get_boolean_status_req(const fmi2_import_get_boolean_status_req& from);

  inline fmi2_import_get_boolean_status_req& operator=(const fmi2_import_get_boolean_status_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_boolean_status_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_boolean_status_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_boolean_status_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_boolean_status_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_boolean_status_req& from);
  void MergeFrom(const fmi2_import_get_boolean_status_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_kind_t kind = 3;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 3;
  inline ::fmitcp_proto::fmi2_status_kind_t kind() const;
  inline void set_kind(::fmitcp_proto::fmi2_status_kind_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_boolean_status_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();
  inline void set_has_kind();
  inline void clear_has_kind();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  int kind_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_boolean_status_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_boolean_status_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_boolean_status_res();
  virtual ~fmi2_import_get_boolean_status_res();

  fmi2_import_get_boolean_status_res(const fmi2_import_get_boolean_status_res& from);

  inline fmi2_import_get_boolean_status_res& operator=(const fmi2_import_get_boolean_status_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_boolean_status_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_boolean_status_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_boolean_status_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_boolean_status_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_boolean_status_res& from);
  void MergeFrom(const fmi2_import_get_boolean_status_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required bool value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline bool value() const;
  inline void set_value(bool value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_boolean_status_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::int32 message_id_;
  bool value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_boolean_status_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_string_status_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_string_status_req();
  virtual ~fmi2_import_get_string_status_req();

  fmi2_import_get_string_status_req(const fmi2_import_get_string_status_req& from);

  inline fmi2_import_get_string_status_req& operator=(const fmi2_import_get_string_status_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_string_status_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_string_status_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_string_status_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_string_status_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_string_status_req& from);
  void MergeFrom(const fmi2_import_get_string_status_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_kind_t kind = 3;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 3;
  inline ::fmitcp_proto::fmi2_status_kind_t kind() const;
  inline void set_kind(::fmitcp_proto::fmi2_status_kind_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_string_status_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();
  inline void set_has_kind();
  inline void clear_has_kind();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  int kind_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_string_status_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_string_status_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_string_status_res();
  virtual ~fmi2_import_get_string_status_res();

  fmi2_import_get_string_status_res(const fmi2_import_get_string_status_res& from);

  inline fmi2_import_get_string_status_res& operator=(const fmi2_import_get_string_status_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_string_status_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_string_status_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_string_status_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_string_status_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_string_status_res& from);
  void MergeFrom(const fmi2_import_get_string_status_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_string_status_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string* value_;
  ::google::protobuf::int32 message_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_string_status_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_instantiate_model_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_instantiate_model_req();
  virtual ~fmi2_import_instantiate_model_req();

  fmi2_import_instantiate_model_req(const fmi2_import_instantiate_model_req& from);

  inline fmi2_import_instantiate_model_req& operator=(const fmi2_import_instantiate_model_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_instantiate_model_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_instantiate_model_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_instantiate_model_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_instantiate_model_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_instantiate_model_req& from);
  void MergeFrom(const fmi2_import_instantiate_model_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // required string instanceName = 3;
  inline bool has_instancename() const;
  inline void clear_instancename();
  static const int kInstanceNameFieldNumber = 3;
  inline const ::std::string& instancename() const;
  inline void set_instancename(const ::std::string& value);
  inline void set_instancename(const char* value);
  inline void set_instancename(const char* value, size_t size);
  inline ::std::string* mutable_instancename();
  inline ::std::string* release_instancename();
  inline void set_allocated_instancename(::std::string* instancename);

  // required string resourceLocation = 4;
  inline bool has_resourcelocation() const;
  inline void clear_resourcelocation();
  static const int kResourceLocationFieldNumber = 4;
  inline const ::std::string& resourcelocation() const;
  inline void set_resourcelocation(const ::std::string& value);
  inline void set_resourcelocation(const char* value);
  inline void set_resourcelocation(const char* value, size_t size);
  inline ::std::string* mutable_resourcelocation();
  inline ::std::string* release_resourcelocation();
  inline void set_allocated_resourcelocation(::std::string* resourcelocation);

  // optional bool visible = 5;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 5;
  inline bool visible() const;
  inline void set_visible(bool value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_instantiate_model_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();
  inline void set_has_instancename();
  inline void clear_has_instancename();
  inline void set_has_resourcelocation();
  inline void clear_has_resourcelocation();
  inline void set_has_visible();
  inline void clear_has_visible();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  ::std::string* instancename_;
  ::std::string* resourcelocation_;
  bool visible_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_instantiate_model_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_instantiate_model_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_instantiate_model_res();
  virtual ~fmi2_import_instantiate_model_res();

  fmi2_import_instantiate_model_res(const fmi2_import_instantiate_model_res& from);

  inline fmi2_import_instantiate_model_res& operator=(const fmi2_import_instantiate_model_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_instantiate_model_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_instantiate_model_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_instantiate_model_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_instantiate_model_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_instantiate_model_res& from);
  void MergeFrom(const fmi2_import_instantiate_model_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.jm_status_enu_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::jm_status_enu_t status() const;
  inline void set_status(::fmitcp_proto::jm_status_enu_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_instantiate_model_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_instantiate_model_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_free_model_instance_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_free_model_instance_req();
  virtual ~fmi2_import_free_model_instance_req();

  fmi2_import_free_model_instance_req(const fmi2_import_free_model_instance_req& from);

  inline fmi2_import_free_model_instance_req& operator=(const fmi2_import_free_model_instance_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_free_model_instance_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_free_model_instance_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_free_model_instance_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_free_model_instance_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_free_model_instance_req& from);
  void MergeFrom(const fmi2_import_free_model_instance_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_free_model_instance_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_free_model_instance_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_free_model_instance_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_free_model_instance_res();
  virtual ~fmi2_import_free_model_instance_res();

  fmi2_import_free_model_instance_res(const fmi2_import_free_model_instance_res& from);

  inline fmi2_import_free_model_instance_res& operator=(const fmi2_import_free_model_instance_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_free_model_instance_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_free_model_instance_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_free_model_instance_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_free_model_instance_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_free_model_instance_res& from);
  void MergeFrom(const fmi2_import_free_model_instance_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_free_model_instance_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();

  ::google::protobuf::int32 message_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_free_model_instance_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_set_time_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_set_time_req();
  virtual ~fmi2_import_set_time_req();

  fmi2_import_set_time_req(const fmi2_import_set_time_req& from);

  inline fmi2_import_set_time_req& operator=(const fmi2_import_set_time_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_set_time_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_set_time_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_set_time_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_set_time_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_set_time_req& from);
  void MergeFrom(const fmi2_import_set_time_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // required double time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline double time() const;
  inline void set_time(double value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_set_time_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  double time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_set_time_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_set_time_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_set_time_res();
  virtual ~fmi2_import_set_time_res();

  fmi2_import_set_time_res(const fmi2_import_set_time_res& from);

  inline fmi2_import_set_time_res& operator=(const fmi2_import_set_time_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_set_time_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_set_time_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_set_time_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_set_time_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_set_time_res& from);
  void MergeFrom(const fmi2_import_set_time_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_set_time_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_set_time_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_set_continuous_states_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_set_continuous_states_req();
  virtual ~fmi2_import_set_continuous_states_req();

  fmi2_import_set_continuous_states_req(const fmi2_import_set_continuous_states_req& from);

  inline fmi2_import_set_continuous_states_req& operator=(const fmi2_import_set_continuous_states_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_set_continuous_states_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_set_continuous_states_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_set_continuous_states_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_set_continuous_states_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_set_continuous_states_req& from);
  void MergeFrom(const fmi2_import_set_continuous_states_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // repeated double x = 3 [packed = true];
  inline int x_size() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline double x(int index) const;
  inline void set_x(int index, double value);
  inline void add_x(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      x() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_x();

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_set_continuous_states_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  ::google::protobuf::RepeatedField< double > x_;
  mutable int _x_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_set_continuous_states_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_set_continuous_states_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_set_continuous_states_res();
  virtual ~fmi2_import_set_continuous_states_res();

  fmi2_import_set_continuous_states_res(const fmi2_import_set_continuous_states_res& from);

  inline fmi2_import_set_continuous_states_res& operator=(const fmi2_import_set_continuous_states_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_set_continuous_states_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_set_continuous_states_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_set_continuous_states_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_set_continuous_states_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_set_continuous_states_res& from);
  void MergeFrom(const fmi2_import_set_continuous_states_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_set_continuous_states_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_set_continuous_states_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_completed_integrator_step_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_completed_integrator_step_req();
  virtual ~fmi2_import_completed_integrator_step_req();

  fmi2_import_completed_integrator_step_req(const fmi2_import_completed_integrator_step_req& from);

  inline fmi2_import_completed_integrator_step_req& operator=(const fmi2_import_completed_integrator_step_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_completed_integrator_step_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_completed_integrator_step_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_completed_integrator_step_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_completed_integrator_step_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_completed_integrator_step_req& from);
  void MergeFrom(const fmi2_import_completed_integrator_step_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_completed_integrator_step_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_completed_integrator_step_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_completed_integrator_step_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_completed_integrator_step_res();
  virtual ~fmi2_import_completed_integrator_step_res();

  fmi2_import_completed_integrator_step_res(const fmi2_import_completed_integrator_step_res& from);

  inline fmi2_import_completed_integrator_step_res& operator=(const fmi2_import_completed_integrator_step_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_completed_integrator_step_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_completed_integrator_step_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_completed_integrator_step_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_completed_integrator_step_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_completed_integrator_step_res& from);
  void MergeFrom(const fmi2_import_completed_integrator_step_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required bool callEventUpdate = 2;
  inline bool has_calleventupdate() const;
  inline void clear_calleventupdate();
  static const int kCallEventUpdateFieldNumber = 2;
  inline bool calleventupdate() const;
  inline void set_calleventupdate(bool value);

  // required .fmitcp_proto.fmi2_status_t status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_completed_integrator_step_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_calleventupdate();
  inline void clear_has_calleventupdate();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  bool calleventupdate_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_completed_integrator_step_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_initialize_model_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_initialize_model_req();
  virtual ~fmi2_import_initialize_model_req();

  fmi2_import_initialize_model_req(const fmi2_import_initialize_model_req& from);

  inline fmi2_import_initialize_model_req& operator=(const fmi2_import_initialize_model_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_initialize_model_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_initialize_model_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_initialize_model_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_initialize_model_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_initialize_model_req& from);
  void MergeFrom(const fmi2_import_initialize_model_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // required bool toleranceControlled = 3;
  inline bool has_tolerancecontrolled() const;
  inline void clear_tolerancecontrolled();
  static const int kToleranceControlledFieldNumber = 3;
  inline bool tolerancecontrolled() const;
  inline void set_tolerancecontrolled(bool value);

  // required double relativeTolerance = 4;
  inline bool has_relativetolerance() const;
  inline void clear_relativetolerance();
  static const int kRelativeToleranceFieldNumber = 4;
  inline double relativetolerance() const;
  inline void set_relativetolerance(double value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_initialize_model_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();
  inline void set_has_tolerancecontrolled();
  inline void clear_has_tolerancecontrolled();
  inline void set_has_relativetolerance();
  inline void clear_has_relativetolerance();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  double relativetolerance_;
  bool tolerancecontrolled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_initialize_model_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_initialize_model_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_initialize_model_res();
  virtual ~fmi2_import_initialize_model_res();

  fmi2_import_initialize_model_res(const fmi2_import_initialize_model_res& from);

  inline fmi2_import_initialize_model_res& operator=(const fmi2_import_initialize_model_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_initialize_model_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_initialize_model_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_initialize_model_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_initialize_model_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_initialize_model_res& from);
  void MergeFrom(const fmi2_import_initialize_model_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_event_info_t eventInfo = 2;
  inline bool has_eventinfo() const;
  inline void clear_eventinfo();
  static const int kEventInfoFieldNumber = 2;
  inline const ::fmitcp_proto::fmi2_event_info_t& eventinfo() const;
  inline ::fmitcp_proto::fmi2_event_info_t* mutable_eventinfo();
  inline ::fmitcp_proto::fmi2_event_info_t* release_eventinfo();
  inline void set_allocated_eventinfo(::fmitcp_proto::fmi2_event_info_t* eventinfo);

  // required .fmitcp_proto.fmi2_status_t status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_initialize_model_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_eventinfo();
  inline void clear_has_eventinfo();
  inline void set_has_status();
  inline void clear_has_status();

  ::fmitcp_proto::fmi2_event_info_t* eventinfo_;
  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_initialize_model_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_derivatives_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_derivatives_req();
  virtual ~fmi2_import_get_derivatives_req();

  fmi2_import_get_derivatives_req(const fmi2_import_get_derivatives_req& from);

  inline fmi2_import_get_derivatives_req& operator=(const fmi2_import_get_derivatives_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_derivatives_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_derivatives_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_derivatives_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_derivatives_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_derivatives_req& from);
  void MergeFrom(const fmi2_import_get_derivatives_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_derivatives_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_derivatives_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_derivatives_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_derivatives_res();
  virtual ~fmi2_import_get_derivatives_res();

  fmi2_import_get_derivatives_res(const fmi2_import_get_derivatives_res& from);

  inline fmi2_import_get_derivatives_res& operator=(const fmi2_import_get_derivatives_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_derivatives_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_derivatives_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_derivatives_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_derivatives_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_derivatives_res& from);
  void MergeFrom(const fmi2_import_get_derivatives_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // repeated double derivatives = 2 [packed = true];
  inline int derivatives_size() const;
  inline void clear_derivatives();
  static const int kDerivativesFieldNumber = 2;
  inline double derivatives(int index) const;
  inline void set_derivatives(int index, double value);
  inline void add_derivatives(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      derivatives() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_derivatives();

  // required .fmitcp_proto.fmi2_status_t status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_derivatives_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::RepeatedField< double > derivatives_;
  mutable int _derivatives_cached_byte_size_;
  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_derivatives_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_event_indicators_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_event_indicators_req();
  virtual ~fmi2_import_get_event_indicators_req();

  fmi2_import_get_event_indicators_req(const fmi2_import_get_event_indicators_req& from);

  inline fmi2_import_get_event_indicators_req& operator=(const fmi2_import_get_event_indicators_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_event_indicators_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_event_indicators_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_event_indicators_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_event_indicators_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_event_indicators_req& from);
  void MergeFrom(const fmi2_import_get_event_indicators_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_event_indicators_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_event_indicators_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_event_indicators_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_event_indicators_res();
  virtual ~fmi2_import_get_event_indicators_res();

  fmi2_import_get_event_indicators_res(const fmi2_import_get_event_indicators_res& from);

  inline fmi2_import_get_event_indicators_res& operator=(const fmi2_import_get_event_indicators_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_event_indicators_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_event_indicators_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_event_indicators_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_event_indicators_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_event_indicators_res& from);
  void MergeFrom(const fmi2_import_get_event_indicators_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // repeated double eventIndicators = 2 [packed = true];
  inline int eventindicators_size() const;
  inline void clear_eventindicators();
  static const int kEventIndicatorsFieldNumber = 2;
  inline double eventindicators(int index) const;
  inline void set_eventindicators(int index, double value);
  inline void add_eventindicators(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      eventindicators() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_eventindicators();

  // required .fmitcp_proto.fmi2_status_t status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_event_indicators_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::RepeatedField< double > eventindicators_;
  mutable int _eventindicators_cached_byte_size_;
  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_event_indicators_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_eventUpdate_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_eventUpdate_req();
  virtual ~fmi2_import_eventUpdate_req();

  fmi2_import_eventUpdate_req(const fmi2_import_eventUpdate_req& from);

  inline fmi2_import_eventUpdate_req& operator=(const fmi2_import_eventUpdate_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_eventUpdate_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_eventUpdate_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_eventUpdate_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_eventUpdate_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_eventUpdate_req& from);
  void MergeFrom(const fmi2_import_eventUpdate_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // required bool intermediateResults = 3;
  inline bool has_intermediateresults() const;
  inline void clear_intermediateresults();
  static const int kIntermediateResultsFieldNumber = 3;
  inline bool intermediateresults() const;
  inline void set_intermediateresults(bool value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_eventUpdate_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();
  inline void set_has_intermediateresults();
  inline void clear_has_intermediateresults();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  bool intermediateresults_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_eventUpdate_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_eventUpdate_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_eventUpdate_res();
  virtual ~fmi2_import_eventUpdate_res();

  fmi2_import_eventUpdate_res(const fmi2_import_eventUpdate_res& from);

  inline fmi2_import_eventUpdate_res& operator=(const fmi2_import_eventUpdate_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_eventUpdate_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_eventUpdate_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_eventUpdate_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_eventUpdate_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_eventUpdate_res& from);
  void MergeFrom(const fmi2_import_eventUpdate_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_event_info_t eventInfo = 2;
  inline bool has_eventinfo() const;
  inline void clear_eventinfo();
  static const int kEventInfoFieldNumber = 2;
  inline const ::fmitcp_proto::fmi2_event_info_t& eventinfo() const;
  inline ::fmitcp_proto::fmi2_event_info_t* mutable_eventinfo();
  inline ::fmitcp_proto::fmi2_event_info_t* release_eventinfo();
  inline void set_allocated_eventinfo(::fmitcp_proto::fmi2_event_info_t* eventinfo);

  // required .fmitcp_proto.fmi2_status_t status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_eventUpdate_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_eventinfo();
  inline void clear_has_eventinfo();
  inline void set_has_status();
  inline void clear_has_status();

  ::fmitcp_proto::fmi2_event_info_t* eventinfo_;
  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_eventUpdate_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_completed_event_iteration_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_completed_event_iteration_req();
  virtual ~fmi2_import_completed_event_iteration_req();

  fmi2_import_completed_event_iteration_req(const fmi2_import_completed_event_iteration_req& from);

  inline fmi2_import_completed_event_iteration_req& operator=(const fmi2_import_completed_event_iteration_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_completed_event_iteration_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_completed_event_iteration_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_completed_event_iteration_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_completed_event_iteration_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_completed_event_iteration_req& from);
  void MergeFrom(const fmi2_import_completed_event_iteration_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_completed_event_iteration_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_completed_event_iteration_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_completed_event_iteration_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_completed_event_iteration_res();
  virtual ~fmi2_import_completed_event_iteration_res();

  fmi2_import_completed_event_iteration_res(const fmi2_import_completed_event_iteration_res& from);

  inline fmi2_import_completed_event_iteration_res& operator=(const fmi2_import_completed_event_iteration_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_completed_event_iteration_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_completed_event_iteration_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_completed_event_iteration_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_completed_event_iteration_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_completed_event_iteration_res& from);
  void MergeFrom(const fmi2_import_completed_event_iteration_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_completed_event_iteration_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_completed_event_iteration_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_continuous_states_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_continuous_states_req();
  virtual ~fmi2_import_get_continuous_states_req();

  fmi2_import_get_continuous_states_req(const fmi2_import_get_continuous_states_req& from);

  inline fmi2_import_get_continuous_states_req& operator=(const fmi2_import_get_continuous_states_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_continuous_states_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_continuous_states_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_continuous_states_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_continuous_states_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_continuous_states_req& from);
  void MergeFrom(const fmi2_import_get_continuous_states_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_continuous_states_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_continuous_states_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_continuous_states_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_continuous_states_res();
  virtual ~fmi2_import_get_continuous_states_res();

  fmi2_import_get_continuous_states_res(const fmi2_import_get_continuous_states_res& from);

  inline fmi2_import_get_continuous_states_res& operator=(const fmi2_import_get_continuous_states_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_continuous_states_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_continuous_states_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_continuous_states_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_continuous_states_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_continuous_states_res& from);
  void MergeFrom(const fmi2_import_get_continuous_states_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // repeated double states = 2 [packed = true];
  inline int states_size() const;
  inline void clear_states();
  static const int kStatesFieldNumber = 2;
  inline double states(int index) const;
  inline void set_states(int index, double value);
  inline void add_states(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      states() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_states();

  // required .fmitcp_proto.fmi2_status_t status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_continuous_states_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::RepeatedField< double > states_;
  mutable int _states_cached_byte_size_;
  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_continuous_states_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_nominal_continuous_states_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_nominal_continuous_states_req();
  virtual ~fmi2_import_get_nominal_continuous_states_req();

  fmi2_import_get_nominal_continuous_states_req(const fmi2_import_get_nominal_continuous_states_req& from);

  inline fmi2_import_get_nominal_continuous_states_req& operator=(const fmi2_import_get_nominal_continuous_states_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_nominal_continuous_states_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_nominal_continuous_states_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_nominal_continuous_states_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_nominal_continuous_states_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_nominal_continuous_states_req& from);
  void MergeFrom(const fmi2_import_get_nominal_continuous_states_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_nominal_continuous_states_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_nominal_continuous_states_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_nominal_continuous_states_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_nominal_continuous_states_res();
  virtual ~fmi2_import_get_nominal_continuous_states_res();

  fmi2_import_get_nominal_continuous_states_res(const fmi2_import_get_nominal_continuous_states_res& from);

  inline fmi2_import_get_nominal_continuous_states_res& operator=(const fmi2_import_get_nominal_continuous_states_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_nominal_continuous_states_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_nominal_continuous_states_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_nominal_continuous_states_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_nominal_continuous_states_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_nominal_continuous_states_res& from);
  void MergeFrom(const fmi2_import_get_nominal_continuous_states_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // repeated double nominal = 2 [packed = true];
  inline int nominal_size() const;
  inline void clear_nominal();
  static const int kNominalFieldNumber = 2;
  inline double nominal(int index) const;
  inline void set_nominal(int index, double value);
  inline void add_nominal(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      nominal() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_nominal();

  // required .fmitcp_proto.fmi2_status_t status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_nominal_continuous_states_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::RepeatedField< double > nominal_;
  mutable int _nominal_cached_byte_size_;
  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_nominal_continuous_states_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_terminate_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_terminate_req();
  virtual ~fmi2_import_terminate_req();

  fmi2_import_terminate_req(const fmi2_import_terminate_req& from);

  inline fmi2_import_terminate_req& operator=(const fmi2_import_terminate_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_terminate_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_terminate_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_terminate_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_terminate_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_terminate_req& from);
  void MergeFrom(const fmi2_import_terminate_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_terminate_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_terminate_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_terminate_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_terminate_res();
  virtual ~fmi2_import_terminate_res();

  fmi2_import_terminate_res(const fmi2_import_terminate_res& from);

  inline fmi2_import_terminate_res& operator=(const fmi2_import_terminate_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_terminate_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_terminate_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_terminate_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_terminate_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_terminate_res& from);
  void MergeFrom(const fmi2_import_terminate_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_terminate_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_terminate_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_version_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_version_req();
  virtual ~fmi2_import_get_version_req();

  fmi2_import_get_version_req(const fmi2_import_get_version_req& from);

  inline fmi2_import_get_version_req& operator=(const fmi2_import_get_version_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_version_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_version_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_version_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_version_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_version_req& from);
  void MergeFrom(const fmi2_import_get_version_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_version_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_version_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_version_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_version_res();
  virtual ~fmi2_import_get_version_res();

  fmi2_import_get_version_res(const fmi2_import_get_version_res& from);

  inline fmi2_import_get_version_res& operator=(const fmi2_import_get_version_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_version_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_version_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_version_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_version_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_version_res& from);
  void MergeFrom(const fmi2_import_get_version_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required string version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_version_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_version();
  inline void clear_has_version();

  ::std::string* version_;
  ::google::protobuf::int32 message_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_version_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_set_debug_logging_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_set_debug_logging_req();
  virtual ~fmi2_import_set_debug_logging_req();

  fmi2_import_set_debug_logging_req(const fmi2_import_set_debug_logging_req& from);

  inline fmi2_import_set_debug_logging_req& operator=(const fmi2_import_set_debug_logging_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_set_debug_logging_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_set_debug_logging_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_set_debug_logging_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_set_debug_logging_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_set_debug_logging_req& from);
  void MergeFrom(const fmi2_import_set_debug_logging_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // required bool loggingOn = 3;
  inline bool has_loggingon() const;
  inline void clear_loggingon();
  static const int kLoggingOnFieldNumber = 3;
  inline bool loggingon() const;
  inline void set_loggingon(bool value);

  // repeated string categories = 4;
  inline int categories_size() const;
  inline void clear_categories();
  static const int kCategoriesFieldNumber = 4;
  inline const ::std::string& categories(int index) const;
  inline ::std::string* mutable_categories(int index);
  inline void set_categories(int index, const ::std::string& value);
  inline void set_categories(int index, const char* value);
  inline void set_categories(int index, const char* value, size_t size);
  inline ::std::string* add_categories();
  inline void add_categories(const ::std::string& value);
  inline void add_categories(const char* value);
  inline void add_categories(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& categories() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_categories();

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_set_debug_logging_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();
  inline void set_has_loggingon();
  inline void clear_has_loggingon();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> categories_;
  bool loggingon_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_set_debug_logging_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_set_debug_logging_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_set_debug_logging_res();
  virtual ~fmi2_import_set_debug_logging_res();

  fmi2_import_set_debug_logging_res(const fmi2_import_set_debug_logging_res& from);

  inline fmi2_import_set_debug_logging_res& operator=(const fmi2_import_set_debug_logging_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_set_debug_logging_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_set_debug_logging_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_set_debug_logging_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_set_debug_logging_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_set_debug_logging_res& from);
  void MergeFrom(const fmi2_import_set_debug_logging_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_set_debug_logging_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_set_debug_logging_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_set_real_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_set_real_req();
  virtual ~fmi2_import_set_real_req();

  fmi2_import_set_real_req(const fmi2_import_set_real_req& from);

  inline fmi2_import_set_real_req& operator=(const fmi2_import_set_real_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_set_real_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_set_real_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_set_real_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_set_real_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_set_real_req& from);
  void MergeFrom(const fmi2_import_set_real_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // repeated int32 valueReferences = 3 [packed = true];
  inline int valuereferences_size() const;
  inline void clear_valuereferences();
  static const int kValueReferencesFieldNumber = 3;
  inline ::google::protobuf::int32 valuereferences(int index) const;
  inline void set_valuereferences(int index, ::google::protobuf::int32 value);
  inline void add_valuereferences(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      valuereferences() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_valuereferences();

  // repeated double values = 4 [packed = true];
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 4;
  inline double values(int index) const;
  inline void set_values(int index, double value);
  inline void add_values(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      values() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_set_real_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > valuereferences_;
  mutable int _valuereferences_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > values_;
  mutable int _values_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_set_real_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_set_real_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_set_real_res();
  virtual ~fmi2_import_set_real_res();

  fmi2_import_set_real_res(const fmi2_import_set_real_res& from);

  inline fmi2_import_set_real_res& operator=(const fmi2_import_set_real_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_set_real_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_set_real_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_set_real_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_set_real_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_set_real_res& from);
  void MergeFrom(const fmi2_import_set_real_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_set_real_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_set_real_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_set_integer_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_set_integer_req();
  virtual ~fmi2_import_set_integer_req();

  fmi2_import_set_integer_req(const fmi2_import_set_integer_req& from);

  inline fmi2_import_set_integer_req& operator=(const fmi2_import_set_integer_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_set_integer_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_set_integer_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_set_integer_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_set_integer_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_set_integer_req& from);
  void MergeFrom(const fmi2_import_set_integer_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // repeated int32 valueReferences = 3 [packed = true];
  inline int valuereferences_size() const;
  inline void clear_valuereferences();
  static const int kValueReferencesFieldNumber = 3;
  inline ::google::protobuf::int32 valuereferences(int index) const;
  inline void set_valuereferences(int index, ::google::protobuf::int32 value);
  inline void add_valuereferences(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      valuereferences() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_valuereferences();

  // repeated int32 values = 4 [packed = true];
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 4;
  inline ::google::protobuf::int32 values(int index) const;
  inline void set_values(int index, ::google::protobuf::int32 value);
  inline void add_values(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      values() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_set_integer_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > valuereferences_;
  mutable int _valuereferences_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > values_;
  mutable int _values_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_set_integer_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_set_integer_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_set_integer_res();
  virtual ~fmi2_import_set_integer_res();

  fmi2_import_set_integer_res(const fmi2_import_set_integer_res& from);

  inline fmi2_import_set_integer_res& operator=(const fmi2_import_set_integer_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_set_integer_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_set_integer_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_set_integer_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_set_integer_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_set_integer_res& from);
  void MergeFrom(const fmi2_import_set_integer_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_set_integer_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_set_integer_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_set_boolean_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_set_boolean_req();
  virtual ~fmi2_import_set_boolean_req();

  fmi2_import_set_boolean_req(const fmi2_import_set_boolean_req& from);

  inline fmi2_import_set_boolean_req& operator=(const fmi2_import_set_boolean_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_set_boolean_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_set_boolean_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_set_boolean_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_set_boolean_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_set_boolean_req& from);
  void MergeFrom(const fmi2_import_set_boolean_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // repeated int32 valueReferences = 3 [packed = true];
  inline int valuereferences_size() const;
  inline void clear_valuereferences();
  static const int kValueReferencesFieldNumber = 3;
  inline ::google::protobuf::int32 valuereferences(int index) const;
  inline void set_valuereferences(int index, ::google::protobuf::int32 value);
  inline void add_valuereferences(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      valuereferences() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_valuereferences();

  // repeated bool values = 4 [packed = true];
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 4;
  inline bool values(int index) const;
  inline void set_values(int index, bool value);
  inline void add_values(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      values() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_set_boolean_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > valuereferences_;
  mutable int _valuereferences_cached_byte_size_;
  ::google::protobuf::RepeatedField< bool > values_;
  mutable int _values_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_set_boolean_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_set_boolean_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_set_boolean_res();
  virtual ~fmi2_import_set_boolean_res();

  fmi2_import_set_boolean_res(const fmi2_import_set_boolean_res& from);

  inline fmi2_import_set_boolean_res& operator=(const fmi2_import_set_boolean_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_set_boolean_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_set_boolean_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_set_boolean_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_set_boolean_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_set_boolean_res& from);
  void MergeFrom(const fmi2_import_set_boolean_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_set_boolean_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_set_boolean_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_set_string_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_set_string_req();
  virtual ~fmi2_import_set_string_req();

  fmi2_import_set_string_req(const fmi2_import_set_string_req& from);

  inline fmi2_import_set_string_req& operator=(const fmi2_import_set_string_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_set_string_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_set_string_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_set_string_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_set_string_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_set_string_req& from);
  void MergeFrom(const fmi2_import_set_string_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // repeated int32 valueReferences = 3 [packed = true];
  inline int valuereferences_size() const;
  inline void clear_valuereferences();
  static const int kValueReferencesFieldNumber = 3;
  inline ::google::protobuf::int32 valuereferences(int index) const;
  inline void set_valuereferences(int index, ::google::protobuf::int32 value);
  inline void add_valuereferences(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      valuereferences() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_valuereferences();

  // repeated string values = 4;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 4;
  inline const ::std::string& values(int index) const;
  inline ::std::string* mutable_values(int index);
  inline void set_values(int index, const ::std::string& value);
  inline void set_values(int index, const char* value);
  inline void set_values(int index, const char* value, size_t size);
  inline ::std::string* add_values();
  inline void add_values(const ::std::string& value);
  inline void add_values(const char* value);
  inline void add_values(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_set_string_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > valuereferences_;
  mutable int _valuereferences_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_set_string_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_set_string_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_set_string_res();
  virtual ~fmi2_import_set_string_res();

  fmi2_import_set_string_res(const fmi2_import_set_string_res& from);

  inline fmi2_import_set_string_res& operator=(const fmi2_import_set_string_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_set_string_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_set_string_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_set_string_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_set_string_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_set_string_res& from);
  void MergeFrom(const fmi2_import_set_string_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_set_string_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_set_string_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_real_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_real_req();
  virtual ~fmi2_import_get_real_req();

  fmi2_import_get_real_req(const fmi2_import_get_real_req& from);

  inline fmi2_import_get_real_req& operator=(const fmi2_import_get_real_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_real_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_real_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_real_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_real_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_real_req& from);
  void MergeFrom(const fmi2_import_get_real_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // repeated int32 valueReferences = 3 [packed = true];
  inline int valuereferences_size() const;
  inline void clear_valuereferences();
  static const int kValueReferencesFieldNumber = 3;
  inline ::google::protobuf::int32 valuereferences(int index) const;
  inline void set_valuereferences(int index, ::google::protobuf::int32 value);
  inline void add_valuereferences(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      valuereferences() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_valuereferences();

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_real_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > valuereferences_;
  mutable int _valuereferences_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_real_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_real_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_real_res();
  virtual ~fmi2_import_get_real_res();

  fmi2_import_get_real_res(const fmi2_import_get_real_res& from);

  inline fmi2_import_get_real_res& operator=(const fmi2_import_get_real_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_real_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_real_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_real_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_real_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_real_res& from);
  void MergeFrom(const fmi2_import_get_real_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // repeated double values = 2 [packed = true];
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 2;
  inline double values(int index) const;
  inline void set_values(int index, double value);
  inline void add_values(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      values() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_values();

  // required .fmitcp_proto.fmi2_status_t status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_real_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::RepeatedField< double > values_;
  mutable int _values_cached_byte_size_;
  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_real_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_integer_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_integer_req();
  virtual ~fmi2_import_get_integer_req();

  fmi2_import_get_integer_req(const fmi2_import_get_integer_req& from);

  inline fmi2_import_get_integer_req& operator=(const fmi2_import_get_integer_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_integer_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_integer_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_integer_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_integer_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_integer_req& from);
  void MergeFrom(const fmi2_import_get_integer_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // repeated int32 valueReferences = 3 [packed = true];
  inline int valuereferences_size() const;
  inline void clear_valuereferences();
  static const int kValueReferencesFieldNumber = 3;
  inline ::google::protobuf::int32 valuereferences(int index) const;
  inline void set_valuereferences(int index, ::google::protobuf::int32 value);
  inline void add_valuereferences(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      valuereferences() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_valuereferences();

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_integer_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > valuereferences_;
  mutable int _valuereferences_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_integer_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_integer_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_integer_res();
  virtual ~fmi2_import_get_integer_res();

  fmi2_import_get_integer_res(const fmi2_import_get_integer_res& from);

  inline fmi2_import_get_integer_res& operator=(const fmi2_import_get_integer_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_integer_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_integer_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_integer_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_integer_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_integer_res& from);
  void MergeFrom(const fmi2_import_get_integer_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // repeated int32 values = 2 [packed = true];
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 2;
  inline ::google::protobuf::int32 values(int index) const;
  inline void set_values(int index, ::google::protobuf::int32 value);
  inline void add_values(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      values() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_values();

  // required .fmitcp_proto.fmi2_status_t status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_integer_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > values_;
  mutable int _values_cached_byte_size_;
  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_integer_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_boolean_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_boolean_req();
  virtual ~fmi2_import_get_boolean_req();

  fmi2_import_get_boolean_req(const fmi2_import_get_boolean_req& from);

  inline fmi2_import_get_boolean_req& operator=(const fmi2_import_get_boolean_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_boolean_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_boolean_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_boolean_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_boolean_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_boolean_req& from);
  void MergeFrom(const fmi2_import_get_boolean_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // repeated int32 valueReferences = 3 [packed = true];
  inline int valuereferences_size() const;
  inline void clear_valuereferences();
  static const int kValueReferencesFieldNumber = 3;
  inline ::google::protobuf::int32 valuereferences(int index) const;
  inline void set_valuereferences(int index, ::google::protobuf::int32 value);
  inline void add_valuereferences(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      valuereferences() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_valuereferences();

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_boolean_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > valuereferences_;
  mutable int _valuereferences_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_boolean_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_boolean_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_boolean_res();
  virtual ~fmi2_import_get_boolean_res();

  fmi2_import_get_boolean_res(const fmi2_import_get_boolean_res& from);

  inline fmi2_import_get_boolean_res& operator=(const fmi2_import_get_boolean_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_boolean_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_boolean_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_boolean_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_boolean_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_boolean_res& from);
  void MergeFrom(const fmi2_import_get_boolean_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // repeated bool values = 2 [packed = true];
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 2;
  inline bool values(int index) const;
  inline void set_values(int index, bool value);
  inline void add_values(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      values() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_values();

  // required .fmitcp_proto.fmi2_status_t status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_boolean_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::RepeatedField< bool > values_;
  mutable int _values_cached_byte_size_;
  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_boolean_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_string_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_string_req();
  virtual ~fmi2_import_get_string_req();

  fmi2_import_get_string_req(const fmi2_import_get_string_req& from);

  inline fmi2_import_get_string_req& operator=(const fmi2_import_get_string_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_string_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_string_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_string_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_string_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_string_req& from);
  void MergeFrom(const fmi2_import_get_string_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // repeated int32 valueReferences = 3 [packed = true];
  inline int valuereferences_size() const;
  inline void clear_valuereferences();
  static const int kValueReferencesFieldNumber = 3;
  inline ::google::protobuf::int32 valuereferences(int index) const;
  inline void set_valuereferences(int index, ::google::protobuf::int32 value);
  inline void add_valuereferences(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      valuereferences() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_valuereferences();

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_string_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > valuereferences_;
  mutable int _valuereferences_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_string_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_string_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_string_res();
  virtual ~fmi2_import_get_string_res();

  fmi2_import_get_string_res(const fmi2_import_get_string_res& from);

  inline fmi2_import_get_string_res& operator=(const fmi2_import_get_string_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_string_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_string_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_string_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_string_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_string_res& from);
  void MergeFrom(const fmi2_import_get_string_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // repeated string values = 2;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 2;
  inline const ::std::string& values(int index) const;
  inline ::std::string* mutable_values(int index);
  inline void set_values(int index, const ::std::string& value);
  inline void set_values(int index, const char* value);
  inline void set_values(int index, const char* value, size_t size);
  inline ::std::string* add_values();
  inline void add_values(const ::std::string& value);
  inline void add_values(const char* value);
  inline void add_values(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // required .fmitcp_proto.fmi2_status_t status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_string_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_string_res* default_instance_;
};
// -------------------------------------------------------------------

class char_req : public ::google::protobuf::MessageLite {
 public:
  char_req();
  virtual ~char_req();

  char_req(const char_req& from);

  inline char_req& operator=(const char_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const char_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const char_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(char_req* other);

  // implements Message ----------------------------------------------

  char_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const char_req& from);
  void MergeFrom(const char_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fmitcp_proto.char_req)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static char_req* default_instance_;
};
// -------------------------------------------------------------------

class char_res : public ::google::protobuf::MessageLite {
 public:
  char_res();
  virtual ~char_res();

  char_res(const char_res& from);

  inline char_res& operator=(const char_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const char_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const char_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(char_res* other);

  // implements Message ----------------------------------------------

  char_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const char_res& from);
  void MergeFrom(const char_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fmitcp_proto.char_res)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static char_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_fmu_state_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_fmu_state_req();
  virtual ~fmi2_import_get_fmu_state_req();

  fmi2_import_get_fmu_state_req(const fmi2_import_get_fmu_state_req& from);

  inline fmi2_import_get_fmu_state_req& operator=(const fmi2_import_get_fmu_state_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_fmu_state_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_fmu_state_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_fmu_state_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_fmu_state_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_fmu_state_req& from);
  void MergeFrom(const fmi2_import_get_fmu_state_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_fmu_state_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_fmu_state_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_fmu_state_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_fmu_state_res();
  virtual ~fmi2_import_get_fmu_state_res();

  fmi2_import_get_fmu_state_res(const fmi2_import_get_fmu_state_res& from);

  inline fmi2_import_get_fmu_state_res& operator=(const fmi2_import_get_fmu_state_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_fmu_state_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_fmu_state_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_fmu_state_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_fmu_state_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_fmu_state_res& from);
  void MergeFrom(const fmi2_import_get_fmu_state_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 stateId = 2;
  inline bool has_stateid() const;
  inline void clear_stateid();
  static const int kStateIdFieldNumber = 2;
  inline ::google::protobuf::int32 stateid() const;
  inline void set_stateid(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_fmu_state_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_stateid();
  inline void clear_has_stateid();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 stateid_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_fmu_state_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_set_fmu_state_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_set_fmu_state_req();
  virtual ~fmi2_import_set_fmu_state_req();

  fmi2_import_set_fmu_state_req(const fmi2_import_set_fmu_state_req& from);

  inline fmi2_import_set_fmu_state_req& operator=(const fmi2_import_set_fmu_state_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_set_fmu_state_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_set_fmu_state_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_set_fmu_state_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_set_fmu_state_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_set_fmu_state_req& from);
  void MergeFrom(const fmi2_import_set_fmu_state_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // required int32 stateId = 3;
  inline bool has_stateid() const;
  inline void clear_stateid();
  static const int kStateIdFieldNumber = 3;
  inline ::google::protobuf::int32 stateid() const;
  inline void set_stateid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_set_fmu_state_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();
  inline void set_has_stateid();
  inline void clear_has_stateid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  ::google::protobuf::int32 stateid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_set_fmu_state_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_set_fmu_state_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_set_fmu_state_res();
  virtual ~fmi2_import_set_fmu_state_res();

  fmi2_import_set_fmu_state_res(const fmi2_import_set_fmu_state_res& from);

  inline fmi2_import_set_fmu_state_res& operator=(const fmi2_import_set_fmu_state_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_set_fmu_state_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_set_fmu_state_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_set_fmu_state_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_set_fmu_state_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_set_fmu_state_res& from);
  void MergeFrom(const fmi2_import_set_fmu_state_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_set_fmu_state_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_set_fmu_state_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_free_fmu_state_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_free_fmu_state_req();
  virtual ~fmi2_import_free_fmu_state_req();

  fmi2_import_free_fmu_state_req(const fmi2_import_free_fmu_state_req& from);

  inline fmi2_import_free_fmu_state_req& operator=(const fmi2_import_free_fmu_state_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_free_fmu_state_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_free_fmu_state_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_free_fmu_state_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_free_fmu_state_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_free_fmu_state_req& from);
  void MergeFrom(const fmi2_import_free_fmu_state_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 stateId = 2;
  inline bool has_stateid() const;
  inline void clear_stateid();
  static const int kStateIdFieldNumber = 2;
  inline ::google::protobuf::int32 stateid() const;
  inline void set_stateid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_free_fmu_state_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_stateid();
  inline void clear_has_stateid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 stateid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_free_fmu_state_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_free_fmu_state_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_free_fmu_state_res();
  virtual ~fmi2_import_free_fmu_state_res();

  fmi2_import_free_fmu_state_res(const fmi2_import_free_fmu_state_res& from);

  inline fmi2_import_free_fmu_state_res& operator=(const fmi2_import_free_fmu_state_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_free_fmu_state_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_free_fmu_state_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_free_fmu_state_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_free_fmu_state_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_free_fmu_state_res& from);
  void MergeFrom(const fmi2_import_free_fmu_state_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.fmi2_status_t status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_free_fmu_state_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_free_fmu_state_res* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_directional_derivative_req : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_directional_derivative_req();
  virtual ~fmi2_import_get_directional_derivative_req();

  fmi2_import_get_directional_derivative_req(const fmi2_import_get_directional_derivative_req& from);

  inline fmi2_import_get_directional_derivative_req& operator=(const fmi2_import_get_directional_derivative_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_directional_derivative_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_directional_derivative_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_directional_derivative_req* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_directional_derivative_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_directional_derivative_req& from);
  void MergeFrom(const fmi2_import_get_directional_derivative_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // repeated int32 v_ref = 3 [packed = true];
  inline int v_ref_size() const;
  inline void clear_v_ref();
  static const int kVRefFieldNumber = 3;
  inline ::google::protobuf::int32 v_ref(int index) const;
  inline void set_v_ref(int index, ::google::protobuf::int32 value);
  inline void add_v_ref(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      v_ref() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_v_ref();

  // repeated int32 z_ref = 4 [packed = true];
  inline int z_ref_size() const;
  inline void clear_z_ref();
  static const int kZRefFieldNumber = 4;
  inline ::google::protobuf::int32 z_ref(int index) const;
  inline void set_z_ref(int index, ::google::protobuf::int32 value);
  inline void add_z_ref(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      z_ref() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_z_ref();

  // repeated double dv = 5 [packed = true];
  inline int dv_size() const;
  inline void clear_dv();
  static const int kDvFieldNumber = 5;
  inline double dv(int index) const;
  inline void set_dv(int index, double value);
  inline void add_dv(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      dv() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_dv();

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_directional_derivative_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > v_ref_;
  mutable int _v_ref_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > z_ref_;
  mutable int _z_ref_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > dv_;
  mutable int _dv_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_directional_derivative_req* default_instance_;
};
// -------------------------------------------------------------------

class fmi2_import_get_directional_derivative_res : public ::google::protobuf::MessageLite {
 public:
  fmi2_import_get_directional_derivative_res();
  virtual ~fmi2_import_get_directional_derivative_res();

  fmi2_import_get_directional_derivative_res(const fmi2_import_get_directional_derivative_res& from);

  inline fmi2_import_get_directional_derivative_res& operator=(const fmi2_import_get_directional_derivative_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const fmi2_import_get_directional_derivative_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const fmi2_import_get_directional_derivative_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(fmi2_import_get_directional_derivative_res* other);

  // implements Message ----------------------------------------------

  fmi2_import_get_directional_derivative_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const fmi2_import_get_directional_derivative_res& from);
  void MergeFrom(const fmi2_import_get_directional_derivative_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // repeated double dz = 2 [packed = true];
  inline int dz_size() const;
  inline void clear_dz();
  static const int kDzFieldNumber = 2;
  inline double dz(int index) const;
  inline void set_dz(int index, double value);
  inline void add_dz(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      dz() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_dz();

  // required .fmitcp_proto.fmi2_status_t status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::fmitcp_proto::fmi2_status_t status() const;
  inline void set_status(::fmitcp_proto::fmi2_status_t value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.fmi2_import_get_directional_derivative_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::RepeatedField< double > dz_;
  mutable int _dz_cached_byte_size_;
  ::google::protobuf::int32 message_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static fmi2_import_get_directional_derivative_res* default_instance_;
};
// -------------------------------------------------------------------

class get_xml_req : public ::google::protobuf::MessageLite {
 public:
  get_xml_req();
  virtual ~get_xml_req();

  get_xml_req(const get_xml_req& from);

  inline get_xml_req& operator=(const get_xml_req& from) {
    CopyFrom(from);
    return *this;
  }

  static const get_xml_req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const get_xml_req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(get_xml_req* other);

  // implements Message ----------------------------------------------

  get_xml_req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const get_xml_req& from);
  void MergeFrom(const get_xml_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required int32 fmuId = 2;
  inline bool has_fmuid() const;
  inline void clear_fmuid();
  static const int kFmuIdFieldNumber = 2;
  inline ::google::protobuf::int32 fmuid() const;
  inline void set_fmuid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.get_xml_req)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_fmuid();
  inline void clear_has_fmuid();

  ::google::protobuf::int32 message_id_;
  ::google::protobuf::int32 fmuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static get_xml_req* default_instance_;
};
// -------------------------------------------------------------------

class get_xml_res : public ::google::protobuf::MessageLite {
 public:
  get_xml_res();
  virtual ~get_xml_res();

  get_xml_res(const get_xml_res& from);

  inline get_xml_res& operator=(const get_xml_res& from) {
    CopyFrom(from);
    return *this;
  }

  static const get_xml_res& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const get_xml_res* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(get_xml_res* other);

  // implements Message ----------------------------------------------

  get_xml_res* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const get_xml_res& from);
  void MergeFrom(const get_xml_res& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 message_id = 1;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::int32 message_id() const;
  inline void set_message_id(::google::protobuf::int32 value);

  // required .fmitcp_proto.jm_log_level_enu_t logLevel = 2;
  inline bool has_loglevel() const;
  inline void clear_loglevel();
  static const int kLogLevelFieldNumber = 2;
  inline ::fmitcp_proto::jm_log_level_enu_t loglevel() const;
  inline void set_loglevel(::fmitcp_proto::jm_log_level_enu_t value);

  // required string xml = 3;
  inline bool has_xml() const;
  inline void clear_xml();
  static const int kXmlFieldNumber = 3;
  inline const ::std::string& xml() const;
  inline void set_xml(const ::std::string& value);
  inline void set_xml(const char* value);
  inline void set_xml(const char* value, size_t size);
  inline ::std::string* mutable_xml();
  inline ::std::string* release_xml();
  inline void set_allocated_xml(::std::string* xml);

  // @@protoc_insertion_point(class_scope:fmitcp_proto.get_xml_res)
 private:
  inline void set_has_message_id();
  inline void clear_has_message_id();
  inline void set_has_loglevel();
  inline void clear_has_loglevel();
  inline void set_has_xml();
  inline void clear_has_xml();

  ::google::protobuf::int32 message_id_;
  int loglevel_;
  ::std::string* xml_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_fmitcp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_fmitcp_2eproto();
  #endif
  friend void protobuf_AssignDesc_fmitcp_2eproto();
  friend void protobuf_ShutdownFile_fmitcp_2eproto();

  void InitAsDefaultInstance();
  static get_xml_res* default_instance_;
};
// ===================================================================


// ===================================================================

// fmitcp_message

// required .fmitcp_proto.fmitcp_message.Type type = 1;
inline bool fmitcp_message::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmitcp_message::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmitcp_message::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmitcp_message::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::fmitcp_proto::fmitcp_message_Type fmitcp_message::type() const {
  return static_cast< ::fmitcp_proto::fmitcp_message_Type >(type_);
}
inline void fmitcp_message::set_type(::fmitcp_proto::fmitcp_message_Type value) {
  assert(::fmitcp_proto::fmitcp_message_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .fmitcp_proto.fmi2_import_instantiate_req fmi2_import_instantiate_req = 2;
inline bool fmitcp_message::has_fmi2_import_instantiate_req() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_instantiate_req() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmitcp_message::clear_has_fmi2_import_instantiate_req() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmitcp_message::clear_fmi2_import_instantiate_req() {
  if (fmi2_import_instantiate_req_ != NULL) fmi2_import_instantiate_req_->::fmitcp_proto::fmi2_import_instantiate_req::Clear();
  clear_has_fmi2_import_instantiate_req();
}
inline const ::fmitcp_proto::fmi2_import_instantiate_req& fmitcp_message::fmi2_import_instantiate_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_instantiate_req_ != NULL ? *fmi2_import_instantiate_req_ : *default_instance().fmi2_import_instantiate_req_;
#else
  return fmi2_import_instantiate_req_ != NULL ? *fmi2_import_instantiate_req_ : *default_instance_->fmi2_import_instantiate_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_instantiate_req* fmitcp_message::mutable_fmi2_import_instantiate_req() {
  set_has_fmi2_import_instantiate_req();
  if (fmi2_import_instantiate_req_ == NULL) fmi2_import_instantiate_req_ = new ::fmitcp_proto::fmi2_import_instantiate_req;
  return fmi2_import_instantiate_req_;
}
inline ::fmitcp_proto::fmi2_import_instantiate_req* fmitcp_message::release_fmi2_import_instantiate_req() {
  clear_has_fmi2_import_instantiate_req();
  ::fmitcp_proto::fmi2_import_instantiate_req* temp = fmi2_import_instantiate_req_;
  fmi2_import_instantiate_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_instantiate_req(::fmitcp_proto::fmi2_import_instantiate_req* fmi2_import_instantiate_req) {
  delete fmi2_import_instantiate_req_;
  fmi2_import_instantiate_req_ = fmi2_import_instantiate_req;
  if (fmi2_import_instantiate_req) {
    set_has_fmi2_import_instantiate_req();
  } else {
    clear_has_fmi2_import_instantiate_req();
  }
}

// optional .fmitcp_proto.fmi2_import_instantiate_res fmi2_import_instantiate_res = 3;
inline bool fmitcp_message::has_fmi2_import_instantiate_res() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_instantiate_res() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmitcp_message::clear_has_fmi2_import_instantiate_res() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmitcp_message::clear_fmi2_import_instantiate_res() {
  if (fmi2_import_instantiate_res_ != NULL) fmi2_import_instantiate_res_->::fmitcp_proto::fmi2_import_instantiate_res::Clear();
  clear_has_fmi2_import_instantiate_res();
}
inline const ::fmitcp_proto::fmi2_import_instantiate_res& fmitcp_message::fmi2_import_instantiate_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_instantiate_res_ != NULL ? *fmi2_import_instantiate_res_ : *default_instance().fmi2_import_instantiate_res_;
#else
  return fmi2_import_instantiate_res_ != NULL ? *fmi2_import_instantiate_res_ : *default_instance_->fmi2_import_instantiate_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_instantiate_res* fmitcp_message::mutable_fmi2_import_instantiate_res() {
  set_has_fmi2_import_instantiate_res();
  if (fmi2_import_instantiate_res_ == NULL) fmi2_import_instantiate_res_ = new ::fmitcp_proto::fmi2_import_instantiate_res;
  return fmi2_import_instantiate_res_;
}
inline ::fmitcp_proto::fmi2_import_instantiate_res* fmitcp_message::release_fmi2_import_instantiate_res() {
  clear_has_fmi2_import_instantiate_res();
  ::fmitcp_proto::fmi2_import_instantiate_res* temp = fmi2_import_instantiate_res_;
  fmi2_import_instantiate_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_instantiate_res(::fmitcp_proto::fmi2_import_instantiate_res* fmi2_import_instantiate_res) {
  delete fmi2_import_instantiate_res_;
  fmi2_import_instantiate_res_ = fmi2_import_instantiate_res;
  if (fmi2_import_instantiate_res) {
    set_has_fmi2_import_instantiate_res();
  } else {
    clear_has_fmi2_import_instantiate_res();
  }
}

// optional .fmitcp_proto.fmi2_import_initialize_slave_req fmi2_import_initialize_slave_req = 4;
inline bool fmitcp_message::has_fmi2_import_initialize_slave_req() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_initialize_slave_req() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fmitcp_message::clear_has_fmi2_import_initialize_slave_req() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fmitcp_message::clear_fmi2_import_initialize_slave_req() {
  if (fmi2_import_initialize_slave_req_ != NULL) fmi2_import_initialize_slave_req_->::fmitcp_proto::fmi2_import_initialize_slave_req::Clear();
  clear_has_fmi2_import_initialize_slave_req();
}
inline const ::fmitcp_proto::fmi2_import_initialize_slave_req& fmitcp_message::fmi2_import_initialize_slave_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_initialize_slave_req_ != NULL ? *fmi2_import_initialize_slave_req_ : *default_instance().fmi2_import_initialize_slave_req_;
#else
  return fmi2_import_initialize_slave_req_ != NULL ? *fmi2_import_initialize_slave_req_ : *default_instance_->fmi2_import_initialize_slave_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_initialize_slave_req* fmitcp_message::mutable_fmi2_import_initialize_slave_req() {
  set_has_fmi2_import_initialize_slave_req();
  if (fmi2_import_initialize_slave_req_ == NULL) fmi2_import_initialize_slave_req_ = new ::fmitcp_proto::fmi2_import_initialize_slave_req;
  return fmi2_import_initialize_slave_req_;
}
inline ::fmitcp_proto::fmi2_import_initialize_slave_req* fmitcp_message::release_fmi2_import_initialize_slave_req() {
  clear_has_fmi2_import_initialize_slave_req();
  ::fmitcp_proto::fmi2_import_initialize_slave_req* temp = fmi2_import_initialize_slave_req_;
  fmi2_import_initialize_slave_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_initialize_slave_req(::fmitcp_proto::fmi2_import_initialize_slave_req* fmi2_import_initialize_slave_req) {
  delete fmi2_import_initialize_slave_req_;
  fmi2_import_initialize_slave_req_ = fmi2_import_initialize_slave_req;
  if (fmi2_import_initialize_slave_req) {
    set_has_fmi2_import_initialize_slave_req();
  } else {
    clear_has_fmi2_import_initialize_slave_req();
  }
}

// optional .fmitcp_proto.fmi2_import_initialize_slave_res fmi2_import_initialize_slave_res = 5;
inline bool fmitcp_message::has_fmi2_import_initialize_slave_res() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_initialize_slave_res() {
  _has_bits_[0] |= 0x00000010u;
}
inline void fmitcp_message::clear_has_fmi2_import_initialize_slave_res() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void fmitcp_message::clear_fmi2_import_initialize_slave_res() {
  if (fmi2_import_initialize_slave_res_ != NULL) fmi2_import_initialize_slave_res_->::fmitcp_proto::fmi2_import_initialize_slave_res::Clear();
  clear_has_fmi2_import_initialize_slave_res();
}
inline const ::fmitcp_proto::fmi2_import_initialize_slave_res& fmitcp_message::fmi2_import_initialize_slave_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_initialize_slave_res_ != NULL ? *fmi2_import_initialize_slave_res_ : *default_instance().fmi2_import_initialize_slave_res_;
#else
  return fmi2_import_initialize_slave_res_ != NULL ? *fmi2_import_initialize_slave_res_ : *default_instance_->fmi2_import_initialize_slave_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_initialize_slave_res* fmitcp_message::mutable_fmi2_import_initialize_slave_res() {
  set_has_fmi2_import_initialize_slave_res();
  if (fmi2_import_initialize_slave_res_ == NULL) fmi2_import_initialize_slave_res_ = new ::fmitcp_proto::fmi2_import_initialize_slave_res;
  return fmi2_import_initialize_slave_res_;
}
inline ::fmitcp_proto::fmi2_import_initialize_slave_res* fmitcp_message::release_fmi2_import_initialize_slave_res() {
  clear_has_fmi2_import_initialize_slave_res();
  ::fmitcp_proto::fmi2_import_initialize_slave_res* temp = fmi2_import_initialize_slave_res_;
  fmi2_import_initialize_slave_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_initialize_slave_res(::fmitcp_proto::fmi2_import_initialize_slave_res* fmi2_import_initialize_slave_res) {
  delete fmi2_import_initialize_slave_res_;
  fmi2_import_initialize_slave_res_ = fmi2_import_initialize_slave_res;
  if (fmi2_import_initialize_slave_res) {
    set_has_fmi2_import_initialize_slave_res();
  } else {
    clear_has_fmi2_import_initialize_slave_res();
  }
}

// optional .fmitcp_proto.fmi2_import_terminate_slave_req fmi2_import_terminate_slave_req = 6;
inline bool fmitcp_message::has_fmi2_import_terminate_slave_req() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_terminate_slave_req() {
  _has_bits_[0] |= 0x00000020u;
}
inline void fmitcp_message::clear_has_fmi2_import_terminate_slave_req() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void fmitcp_message::clear_fmi2_import_terminate_slave_req() {
  if (fmi2_import_terminate_slave_req_ != NULL) fmi2_import_terminate_slave_req_->::fmitcp_proto::fmi2_import_terminate_slave_req::Clear();
  clear_has_fmi2_import_terminate_slave_req();
}
inline const ::fmitcp_proto::fmi2_import_terminate_slave_req& fmitcp_message::fmi2_import_terminate_slave_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_terminate_slave_req_ != NULL ? *fmi2_import_terminate_slave_req_ : *default_instance().fmi2_import_terminate_slave_req_;
#else
  return fmi2_import_terminate_slave_req_ != NULL ? *fmi2_import_terminate_slave_req_ : *default_instance_->fmi2_import_terminate_slave_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_terminate_slave_req* fmitcp_message::mutable_fmi2_import_terminate_slave_req() {
  set_has_fmi2_import_terminate_slave_req();
  if (fmi2_import_terminate_slave_req_ == NULL) fmi2_import_terminate_slave_req_ = new ::fmitcp_proto::fmi2_import_terminate_slave_req;
  return fmi2_import_terminate_slave_req_;
}
inline ::fmitcp_proto::fmi2_import_terminate_slave_req* fmitcp_message::release_fmi2_import_terminate_slave_req() {
  clear_has_fmi2_import_terminate_slave_req();
  ::fmitcp_proto::fmi2_import_terminate_slave_req* temp = fmi2_import_terminate_slave_req_;
  fmi2_import_terminate_slave_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_terminate_slave_req(::fmitcp_proto::fmi2_import_terminate_slave_req* fmi2_import_terminate_slave_req) {
  delete fmi2_import_terminate_slave_req_;
  fmi2_import_terminate_slave_req_ = fmi2_import_terminate_slave_req;
  if (fmi2_import_terminate_slave_req) {
    set_has_fmi2_import_terminate_slave_req();
  } else {
    clear_has_fmi2_import_terminate_slave_req();
  }
}

// optional .fmitcp_proto.fmi2_import_terminate_slave_res fmi2_import_terminate_slave_res = 7;
inline bool fmitcp_message::has_fmi2_import_terminate_slave_res() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_terminate_slave_res() {
  _has_bits_[0] |= 0x00000040u;
}
inline void fmitcp_message::clear_has_fmi2_import_terminate_slave_res() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void fmitcp_message::clear_fmi2_import_terminate_slave_res() {
  if (fmi2_import_terminate_slave_res_ != NULL) fmi2_import_terminate_slave_res_->::fmitcp_proto::fmi2_import_terminate_slave_res::Clear();
  clear_has_fmi2_import_terminate_slave_res();
}
inline const ::fmitcp_proto::fmi2_import_terminate_slave_res& fmitcp_message::fmi2_import_terminate_slave_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_terminate_slave_res_ != NULL ? *fmi2_import_terminate_slave_res_ : *default_instance().fmi2_import_terminate_slave_res_;
#else
  return fmi2_import_terminate_slave_res_ != NULL ? *fmi2_import_terminate_slave_res_ : *default_instance_->fmi2_import_terminate_slave_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_terminate_slave_res* fmitcp_message::mutable_fmi2_import_terminate_slave_res() {
  set_has_fmi2_import_terminate_slave_res();
  if (fmi2_import_terminate_slave_res_ == NULL) fmi2_import_terminate_slave_res_ = new ::fmitcp_proto::fmi2_import_terminate_slave_res;
  return fmi2_import_terminate_slave_res_;
}
inline ::fmitcp_proto::fmi2_import_terminate_slave_res* fmitcp_message::release_fmi2_import_terminate_slave_res() {
  clear_has_fmi2_import_terminate_slave_res();
  ::fmitcp_proto::fmi2_import_terminate_slave_res* temp = fmi2_import_terminate_slave_res_;
  fmi2_import_terminate_slave_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_terminate_slave_res(::fmitcp_proto::fmi2_import_terminate_slave_res* fmi2_import_terminate_slave_res) {
  delete fmi2_import_terminate_slave_res_;
  fmi2_import_terminate_slave_res_ = fmi2_import_terminate_slave_res;
  if (fmi2_import_terminate_slave_res) {
    set_has_fmi2_import_terminate_slave_res();
  } else {
    clear_has_fmi2_import_terminate_slave_res();
  }
}

// optional .fmitcp_proto.fmi2_import_reset_slave_req fmi2_import_reset_slave_req = 8;
inline bool fmitcp_message::has_fmi2_import_reset_slave_req() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_reset_slave_req() {
  _has_bits_[0] |= 0x00000080u;
}
inline void fmitcp_message::clear_has_fmi2_import_reset_slave_req() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void fmitcp_message::clear_fmi2_import_reset_slave_req() {
  if (fmi2_import_reset_slave_req_ != NULL) fmi2_import_reset_slave_req_->::fmitcp_proto::fmi2_import_reset_slave_req::Clear();
  clear_has_fmi2_import_reset_slave_req();
}
inline const ::fmitcp_proto::fmi2_import_reset_slave_req& fmitcp_message::fmi2_import_reset_slave_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_reset_slave_req_ != NULL ? *fmi2_import_reset_slave_req_ : *default_instance().fmi2_import_reset_slave_req_;
#else
  return fmi2_import_reset_slave_req_ != NULL ? *fmi2_import_reset_slave_req_ : *default_instance_->fmi2_import_reset_slave_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_reset_slave_req* fmitcp_message::mutable_fmi2_import_reset_slave_req() {
  set_has_fmi2_import_reset_slave_req();
  if (fmi2_import_reset_slave_req_ == NULL) fmi2_import_reset_slave_req_ = new ::fmitcp_proto::fmi2_import_reset_slave_req;
  return fmi2_import_reset_slave_req_;
}
inline ::fmitcp_proto::fmi2_import_reset_slave_req* fmitcp_message::release_fmi2_import_reset_slave_req() {
  clear_has_fmi2_import_reset_slave_req();
  ::fmitcp_proto::fmi2_import_reset_slave_req* temp = fmi2_import_reset_slave_req_;
  fmi2_import_reset_slave_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_reset_slave_req(::fmitcp_proto::fmi2_import_reset_slave_req* fmi2_import_reset_slave_req) {
  delete fmi2_import_reset_slave_req_;
  fmi2_import_reset_slave_req_ = fmi2_import_reset_slave_req;
  if (fmi2_import_reset_slave_req) {
    set_has_fmi2_import_reset_slave_req();
  } else {
    clear_has_fmi2_import_reset_slave_req();
  }
}

// optional .fmitcp_proto.fmi2_import_reset_slave_res fmi2_import_reset_slave_res = 9;
inline bool fmitcp_message::has_fmi2_import_reset_slave_res() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_reset_slave_res() {
  _has_bits_[0] |= 0x00000100u;
}
inline void fmitcp_message::clear_has_fmi2_import_reset_slave_res() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void fmitcp_message::clear_fmi2_import_reset_slave_res() {
  if (fmi2_import_reset_slave_res_ != NULL) fmi2_import_reset_slave_res_->::fmitcp_proto::fmi2_import_reset_slave_res::Clear();
  clear_has_fmi2_import_reset_slave_res();
}
inline const ::fmitcp_proto::fmi2_import_reset_slave_res& fmitcp_message::fmi2_import_reset_slave_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_reset_slave_res_ != NULL ? *fmi2_import_reset_slave_res_ : *default_instance().fmi2_import_reset_slave_res_;
#else
  return fmi2_import_reset_slave_res_ != NULL ? *fmi2_import_reset_slave_res_ : *default_instance_->fmi2_import_reset_slave_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_reset_slave_res* fmitcp_message::mutable_fmi2_import_reset_slave_res() {
  set_has_fmi2_import_reset_slave_res();
  if (fmi2_import_reset_slave_res_ == NULL) fmi2_import_reset_slave_res_ = new ::fmitcp_proto::fmi2_import_reset_slave_res;
  return fmi2_import_reset_slave_res_;
}
inline ::fmitcp_proto::fmi2_import_reset_slave_res* fmitcp_message::release_fmi2_import_reset_slave_res() {
  clear_has_fmi2_import_reset_slave_res();
  ::fmitcp_proto::fmi2_import_reset_slave_res* temp = fmi2_import_reset_slave_res_;
  fmi2_import_reset_slave_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_reset_slave_res(::fmitcp_proto::fmi2_import_reset_slave_res* fmi2_import_reset_slave_res) {
  delete fmi2_import_reset_slave_res_;
  fmi2_import_reset_slave_res_ = fmi2_import_reset_slave_res;
  if (fmi2_import_reset_slave_res) {
    set_has_fmi2_import_reset_slave_res();
  } else {
    clear_has_fmi2_import_reset_slave_res();
  }
}

// optional .fmitcp_proto.fmi2_import_free_slave_instance_req fmi2_import_free_slave_instance_req = 10;
inline bool fmitcp_message::has_fmi2_import_free_slave_instance_req() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_free_slave_instance_req() {
  _has_bits_[0] |= 0x00000200u;
}
inline void fmitcp_message::clear_has_fmi2_import_free_slave_instance_req() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void fmitcp_message::clear_fmi2_import_free_slave_instance_req() {
  if (fmi2_import_free_slave_instance_req_ != NULL) fmi2_import_free_slave_instance_req_->::fmitcp_proto::fmi2_import_free_slave_instance_req::Clear();
  clear_has_fmi2_import_free_slave_instance_req();
}
inline const ::fmitcp_proto::fmi2_import_free_slave_instance_req& fmitcp_message::fmi2_import_free_slave_instance_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_free_slave_instance_req_ != NULL ? *fmi2_import_free_slave_instance_req_ : *default_instance().fmi2_import_free_slave_instance_req_;
#else
  return fmi2_import_free_slave_instance_req_ != NULL ? *fmi2_import_free_slave_instance_req_ : *default_instance_->fmi2_import_free_slave_instance_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_free_slave_instance_req* fmitcp_message::mutable_fmi2_import_free_slave_instance_req() {
  set_has_fmi2_import_free_slave_instance_req();
  if (fmi2_import_free_slave_instance_req_ == NULL) fmi2_import_free_slave_instance_req_ = new ::fmitcp_proto::fmi2_import_free_slave_instance_req;
  return fmi2_import_free_slave_instance_req_;
}
inline ::fmitcp_proto::fmi2_import_free_slave_instance_req* fmitcp_message::release_fmi2_import_free_slave_instance_req() {
  clear_has_fmi2_import_free_slave_instance_req();
  ::fmitcp_proto::fmi2_import_free_slave_instance_req* temp = fmi2_import_free_slave_instance_req_;
  fmi2_import_free_slave_instance_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_free_slave_instance_req(::fmitcp_proto::fmi2_import_free_slave_instance_req* fmi2_import_free_slave_instance_req) {
  delete fmi2_import_free_slave_instance_req_;
  fmi2_import_free_slave_instance_req_ = fmi2_import_free_slave_instance_req;
  if (fmi2_import_free_slave_instance_req) {
    set_has_fmi2_import_free_slave_instance_req();
  } else {
    clear_has_fmi2_import_free_slave_instance_req();
  }
}

// optional .fmitcp_proto.fmi2_import_free_slave_instance_res fmi2_import_free_slave_instance_res = 11;
inline bool fmitcp_message::has_fmi2_import_free_slave_instance_res() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_free_slave_instance_res() {
  _has_bits_[0] |= 0x00000400u;
}
inline void fmitcp_message::clear_has_fmi2_import_free_slave_instance_res() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void fmitcp_message::clear_fmi2_import_free_slave_instance_res() {
  if (fmi2_import_free_slave_instance_res_ != NULL) fmi2_import_free_slave_instance_res_->::fmitcp_proto::fmi2_import_free_slave_instance_res::Clear();
  clear_has_fmi2_import_free_slave_instance_res();
}
inline const ::fmitcp_proto::fmi2_import_free_slave_instance_res& fmitcp_message::fmi2_import_free_slave_instance_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_free_slave_instance_res_ != NULL ? *fmi2_import_free_slave_instance_res_ : *default_instance().fmi2_import_free_slave_instance_res_;
#else
  return fmi2_import_free_slave_instance_res_ != NULL ? *fmi2_import_free_slave_instance_res_ : *default_instance_->fmi2_import_free_slave_instance_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_free_slave_instance_res* fmitcp_message::mutable_fmi2_import_free_slave_instance_res() {
  set_has_fmi2_import_free_slave_instance_res();
  if (fmi2_import_free_slave_instance_res_ == NULL) fmi2_import_free_slave_instance_res_ = new ::fmitcp_proto::fmi2_import_free_slave_instance_res;
  return fmi2_import_free_slave_instance_res_;
}
inline ::fmitcp_proto::fmi2_import_free_slave_instance_res* fmitcp_message::release_fmi2_import_free_slave_instance_res() {
  clear_has_fmi2_import_free_slave_instance_res();
  ::fmitcp_proto::fmi2_import_free_slave_instance_res* temp = fmi2_import_free_slave_instance_res_;
  fmi2_import_free_slave_instance_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_free_slave_instance_res(::fmitcp_proto::fmi2_import_free_slave_instance_res* fmi2_import_free_slave_instance_res) {
  delete fmi2_import_free_slave_instance_res_;
  fmi2_import_free_slave_instance_res_ = fmi2_import_free_slave_instance_res;
  if (fmi2_import_free_slave_instance_res) {
    set_has_fmi2_import_free_slave_instance_res();
  } else {
    clear_has_fmi2_import_free_slave_instance_res();
  }
}

// optional .fmitcp_proto.fmi2_import_set_real_input_derivatives_req fmi2_import_set_real_input_derivatives_req = 12;
inline bool fmitcp_message::has_fmi2_import_set_real_input_derivatives_req() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_set_real_input_derivatives_req() {
  _has_bits_[0] |= 0x00000800u;
}
inline void fmitcp_message::clear_has_fmi2_import_set_real_input_derivatives_req() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void fmitcp_message::clear_fmi2_import_set_real_input_derivatives_req() {
  if (fmi2_import_set_real_input_derivatives_req_ != NULL) fmi2_import_set_real_input_derivatives_req_->::fmitcp_proto::fmi2_import_set_real_input_derivatives_req::Clear();
  clear_has_fmi2_import_set_real_input_derivatives_req();
}
inline const ::fmitcp_proto::fmi2_import_set_real_input_derivatives_req& fmitcp_message::fmi2_import_set_real_input_derivatives_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_set_real_input_derivatives_req_ != NULL ? *fmi2_import_set_real_input_derivatives_req_ : *default_instance().fmi2_import_set_real_input_derivatives_req_;
#else
  return fmi2_import_set_real_input_derivatives_req_ != NULL ? *fmi2_import_set_real_input_derivatives_req_ : *default_instance_->fmi2_import_set_real_input_derivatives_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_set_real_input_derivatives_req* fmitcp_message::mutable_fmi2_import_set_real_input_derivatives_req() {
  set_has_fmi2_import_set_real_input_derivatives_req();
  if (fmi2_import_set_real_input_derivatives_req_ == NULL) fmi2_import_set_real_input_derivatives_req_ = new ::fmitcp_proto::fmi2_import_set_real_input_derivatives_req;
  return fmi2_import_set_real_input_derivatives_req_;
}
inline ::fmitcp_proto::fmi2_import_set_real_input_derivatives_req* fmitcp_message::release_fmi2_import_set_real_input_derivatives_req() {
  clear_has_fmi2_import_set_real_input_derivatives_req();
  ::fmitcp_proto::fmi2_import_set_real_input_derivatives_req* temp = fmi2_import_set_real_input_derivatives_req_;
  fmi2_import_set_real_input_derivatives_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_set_real_input_derivatives_req(::fmitcp_proto::fmi2_import_set_real_input_derivatives_req* fmi2_import_set_real_input_derivatives_req) {
  delete fmi2_import_set_real_input_derivatives_req_;
  fmi2_import_set_real_input_derivatives_req_ = fmi2_import_set_real_input_derivatives_req;
  if (fmi2_import_set_real_input_derivatives_req) {
    set_has_fmi2_import_set_real_input_derivatives_req();
  } else {
    clear_has_fmi2_import_set_real_input_derivatives_req();
  }
}

// optional .fmitcp_proto.fmi2_import_set_real_input_derivatives_res fmi2_import_set_real_input_derivatives_res = 13;
inline bool fmitcp_message::has_fmi2_import_set_real_input_derivatives_res() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_set_real_input_derivatives_res() {
  _has_bits_[0] |= 0x00001000u;
}
inline void fmitcp_message::clear_has_fmi2_import_set_real_input_derivatives_res() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void fmitcp_message::clear_fmi2_import_set_real_input_derivatives_res() {
  if (fmi2_import_set_real_input_derivatives_res_ != NULL) fmi2_import_set_real_input_derivatives_res_->::fmitcp_proto::fmi2_import_set_real_input_derivatives_res::Clear();
  clear_has_fmi2_import_set_real_input_derivatives_res();
}
inline const ::fmitcp_proto::fmi2_import_set_real_input_derivatives_res& fmitcp_message::fmi2_import_set_real_input_derivatives_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_set_real_input_derivatives_res_ != NULL ? *fmi2_import_set_real_input_derivatives_res_ : *default_instance().fmi2_import_set_real_input_derivatives_res_;
#else
  return fmi2_import_set_real_input_derivatives_res_ != NULL ? *fmi2_import_set_real_input_derivatives_res_ : *default_instance_->fmi2_import_set_real_input_derivatives_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_set_real_input_derivatives_res* fmitcp_message::mutable_fmi2_import_set_real_input_derivatives_res() {
  set_has_fmi2_import_set_real_input_derivatives_res();
  if (fmi2_import_set_real_input_derivatives_res_ == NULL) fmi2_import_set_real_input_derivatives_res_ = new ::fmitcp_proto::fmi2_import_set_real_input_derivatives_res;
  return fmi2_import_set_real_input_derivatives_res_;
}
inline ::fmitcp_proto::fmi2_import_set_real_input_derivatives_res* fmitcp_message::release_fmi2_import_set_real_input_derivatives_res() {
  clear_has_fmi2_import_set_real_input_derivatives_res();
  ::fmitcp_proto::fmi2_import_set_real_input_derivatives_res* temp = fmi2_import_set_real_input_derivatives_res_;
  fmi2_import_set_real_input_derivatives_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_set_real_input_derivatives_res(::fmitcp_proto::fmi2_import_set_real_input_derivatives_res* fmi2_import_set_real_input_derivatives_res) {
  delete fmi2_import_set_real_input_derivatives_res_;
  fmi2_import_set_real_input_derivatives_res_ = fmi2_import_set_real_input_derivatives_res;
  if (fmi2_import_set_real_input_derivatives_res) {
    set_has_fmi2_import_set_real_input_derivatives_res();
  } else {
    clear_has_fmi2_import_set_real_input_derivatives_res();
  }
}

// optional .fmitcp_proto.fmi2_import_get_real_output_derivatives_req fmi2_import_get_real_output_derivatives_req = 14;
inline bool fmitcp_message::has_fmi2_import_get_real_output_derivatives_req() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_real_output_derivatives_req() {
  _has_bits_[0] |= 0x00002000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_real_output_derivatives_req() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void fmitcp_message::clear_fmi2_import_get_real_output_derivatives_req() {
  if (fmi2_import_get_real_output_derivatives_req_ != NULL) fmi2_import_get_real_output_derivatives_req_->::fmitcp_proto::fmi2_import_get_real_output_derivatives_req::Clear();
  clear_has_fmi2_import_get_real_output_derivatives_req();
}
inline const ::fmitcp_proto::fmi2_import_get_real_output_derivatives_req& fmitcp_message::fmi2_import_get_real_output_derivatives_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_real_output_derivatives_req_ != NULL ? *fmi2_import_get_real_output_derivatives_req_ : *default_instance().fmi2_import_get_real_output_derivatives_req_;
#else
  return fmi2_import_get_real_output_derivatives_req_ != NULL ? *fmi2_import_get_real_output_derivatives_req_ : *default_instance_->fmi2_import_get_real_output_derivatives_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_real_output_derivatives_req* fmitcp_message::mutable_fmi2_import_get_real_output_derivatives_req() {
  set_has_fmi2_import_get_real_output_derivatives_req();
  if (fmi2_import_get_real_output_derivatives_req_ == NULL) fmi2_import_get_real_output_derivatives_req_ = new ::fmitcp_proto::fmi2_import_get_real_output_derivatives_req;
  return fmi2_import_get_real_output_derivatives_req_;
}
inline ::fmitcp_proto::fmi2_import_get_real_output_derivatives_req* fmitcp_message::release_fmi2_import_get_real_output_derivatives_req() {
  clear_has_fmi2_import_get_real_output_derivatives_req();
  ::fmitcp_proto::fmi2_import_get_real_output_derivatives_req* temp = fmi2_import_get_real_output_derivatives_req_;
  fmi2_import_get_real_output_derivatives_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_real_output_derivatives_req(::fmitcp_proto::fmi2_import_get_real_output_derivatives_req* fmi2_import_get_real_output_derivatives_req) {
  delete fmi2_import_get_real_output_derivatives_req_;
  fmi2_import_get_real_output_derivatives_req_ = fmi2_import_get_real_output_derivatives_req;
  if (fmi2_import_get_real_output_derivatives_req) {
    set_has_fmi2_import_get_real_output_derivatives_req();
  } else {
    clear_has_fmi2_import_get_real_output_derivatives_req();
  }
}

// optional .fmitcp_proto.fmi2_import_get_real_output_derivatives_res fmi2_import_get_real_output_derivatives_res = 15;
inline bool fmitcp_message::has_fmi2_import_get_real_output_derivatives_res() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_real_output_derivatives_res() {
  _has_bits_[0] |= 0x00004000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_real_output_derivatives_res() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void fmitcp_message::clear_fmi2_import_get_real_output_derivatives_res() {
  if (fmi2_import_get_real_output_derivatives_res_ != NULL) fmi2_import_get_real_output_derivatives_res_->::fmitcp_proto::fmi2_import_get_real_output_derivatives_res::Clear();
  clear_has_fmi2_import_get_real_output_derivatives_res();
}
inline const ::fmitcp_proto::fmi2_import_get_real_output_derivatives_res& fmitcp_message::fmi2_import_get_real_output_derivatives_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_real_output_derivatives_res_ != NULL ? *fmi2_import_get_real_output_derivatives_res_ : *default_instance().fmi2_import_get_real_output_derivatives_res_;
#else
  return fmi2_import_get_real_output_derivatives_res_ != NULL ? *fmi2_import_get_real_output_derivatives_res_ : *default_instance_->fmi2_import_get_real_output_derivatives_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_real_output_derivatives_res* fmitcp_message::mutable_fmi2_import_get_real_output_derivatives_res() {
  set_has_fmi2_import_get_real_output_derivatives_res();
  if (fmi2_import_get_real_output_derivatives_res_ == NULL) fmi2_import_get_real_output_derivatives_res_ = new ::fmitcp_proto::fmi2_import_get_real_output_derivatives_res;
  return fmi2_import_get_real_output_derivatives_res_;
}
inline ::fmitcp_proto::fmi2_import_get_real_output_derivatives_res* fmitcp_message::release_fmi2_import_get_real_output_derivatives_res() {
  clear_has_fmi2_import_get_real_output_derivatives_res();
  ::fmitcp_proto::fmi2_import_get_real_output_derivatives_res* temp = fmi2_import_get_real_output_derivatives_res_;
  fmi2_import_get_real_output_derivatives_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_real_output_derivatives_res(::fmitcp_proto::fmi2_import_get_real_output_derivatives_res* fmi2_import_get_real_output_derivatives_res) {
  delete fmi2_import_get_real_output_derivatives_res_;
  fmi2_import_get_real_output_derivatives_res_ = fmi2_import_get_real_output_derivatives_res;
  if (fmi2_import_get_real_output_derivatives_res) {
    set_has_fmi2_import_get_real_output_derivatives_res();
  } else {
    clear_has_fmi2_import_get_real_output_derivatives_res();
  }
}

// optional .fmitcp_proto.fmi2_import_cancel_step_req fmi2_import_cancel_step_req = 16;
inline bool fmitcp_message::has_fmi2_import_cancel_step_req() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_cancel_step_req() {
  _has_bits_[0] |= 0x00008000u;
}
inline void fmitcp_message::clear_has_fmi2_import_cancel_step_req() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void fmitcp_message::clear_fmi2_import_cancel_step_req() {
  if (fmi2_import_cancel_step_req_ != NULL) fmi2_import_cancel_step_req_->::fmitcp_proto::fmi2_import_cancel_step_req::Clear();
  clear_has_fmi2_import_cancel_step_req();
}
inline const ::fmitcp_proto::fmi2_import_cancel_step_req& fmitcp_message::fmi2_import_cancel_step_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_cancel_step_req_ != NULL ? *fmi2_import_cancel_step_req_ : *default_instance().fmi2_import_cancel_step_req_;
#else
  return fmi2_import_cancel_step_req_ != NULL ? *fmi2_import_cancel_step_req_ : *default_instance_->fmi2_import_cancel_step_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_cancel_step_req* fmitcp_message::mutable_fmi2_import_cancel_step_req() {
  set_has_fmi2_import_cancel_step_req();
  if (fmi2_import_cancel_step_req_ == NULL) fmi2_import_cancel_step_req_ = new ::fmitcp_proto::fmi2_import_cancel_step_req;
  return fmi2_import_cancel_step_req_;
}
inline ::fmitcp_proto::fmi2_import_cancel_step_req* fmitcp_message::release_fmi2_import_cancel_step_req() {
  clear_has_fmi2_import_cancel_step_req();
  ::fmitcp_proto::fmi2_import_cancel_step_req* temp = fmi2_import_cancel_step_req_;
  fmi2_import_cancel_step_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_cancel_step_req(::fmitcp_proto::fmi2_import_cancel_step_req* fmi2_import_cancel_step_req) {
  delete fmi2_import_cancel_step_req_;
  fmi2_import_cancel_step_req_ = fmi2_import_cancel_step_req;
  if (fmi2_import_cancel_step_req) {
    set_has_fmi2_import_cancel_step_req();
  } else {
    clear_has_fmi2_import_cancel_step_req();
  }
}

// optional .fmitcp_proto.fmi2_import_cancel_step_res fmi2_import_cancel_step_res = 17;
inline bool fmitcp_message::has_fmi2_import_cancel_step_res() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_cancel_step_res() {
  _has_bits_[0] |= 0x00010000u;
}
inline void fmitcp_message::clear_has_fmi2_import_cancel_step_res() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void fmitcp_message::clear_fmi2_import_cancel_step_res() {
  if (fmi2_import_cancel_step_res_ != NULL) fmi2_import_cancel_step_res_->::fmitcp_proto::fmi2_import_cancel_step_res::Clear();
  clear_has_fmi2_import_cancel_step_res();
}
inline const ::fmitcp_proto::fmi2_import_cancel_step_res& fmitcp_message::fmi2_import_cancel_step_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_cancel_step_res_ != NULL ? *fmi2_import_cancel_step_res_ : *default_instance().fmi2_import_cancel_step_res_;
#else
  return fmi2_import_cancel_step_res_ != NULL ? *fmi2_import_cancel_step_res_ : *default_instance_->fmi2_import_cancel_step_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_cancel_step_res* fmitcp_message::mutable_fmi2_import_cancel_step_res() {
  set_has_fmi2_import_cancel_step_res();
  if (fmi2_import_cancel_step_res_ == NULL) fmi2_import_cancel_step_res_ = new ::fmitcp_proto::fmi2_import_cancel_step_res;
  return fmi2_import_cancel_step_res_;
}
inline ::fmitcp_proto::fmi2_import_cancel_step_res* fmitcp_message::release_fmi2_import_cancel_step_res() {
  clear_has_fmi2_import_cancel_step_res();
  ::fmitcp_proto::fmi2_import_cancel_step_res* temp = fmi2_import_cancel_step_res_;
  fmi2_import_cancel_step_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_cancel_step_res(::fmitcp_proto::fmi2_import_cancel_step_res* fmi2_import_cancel_step_res) {
  delete fmi2_import_cancel_step_res_;
  fmi2_import_cancel_step_res_ = fmi2_import_cancel_step_res;
  if (fmi2_import_cancel_step_res) {
    set_has_fmi2_import_cancel_step_res();
  } else {
    clear_has_fmi2_import_cancel_step_res();
  }
}

// optional .fmitcp_proto.fmi2_import_do_step_req fmi2_import_do_step_req = 18;
inline bool fmitcp_message::has_fmi2_import_do_step_req() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_do_step_req() {
  _has_bits_[0] |= 0x00020000u;
}
inline void fmitcp_message::clear_has_fmi2_import_do_step_req() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void fmitcp_message::clear_fmi2_import_do_step_req() {
  if (fmi2_import_do_step_req_ != NULL) fmi2_import_do_step_req_->::fmitcp_proto::fmi2_import_do_step_req::Clear();
  clear_has_fmi2_import_do_step_req();
}
inline const ::fmitcp_proto::fmi2_import_do_step_req& fmitcp_message::fmi2_import_do_step_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_do_step_req_ != NULL ? *fmi2_import_do_step_req_ : *default_instance().fmi2_import_do_step_req_;
#else
  return fmi2_import_do_step_req_ != NULL ? *fmi2_import_do_step_req_ : *default_instance_->fmi2_import_do_step_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_do_step_req* fmitcp_message::mutable_fmi2_import_do_step_req() {
  set_has_fmi2_import_do_step_req();
  if (fmi2_import_do_step_req_ == NULL) fmi2_import_do_step_req_ = new ::fmitcp_proto::fmi2_import_do_step_req;
  return fmi2_import_do_step_req_;
}
inline ::fmitcp_proto::fmi2_import_do_step_req* fmitcp_message::release_fmi2_import_do_step_req() {
  clear_has_fmi2_import_do_step_req();
  ::fmitcp_proto::fmi2_import_do_step_req* temp = fmi2_import_do_step_req_;
  fmi2_import_do_step_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_do_step_req(::fmitcp_proto::fmi2_import_do_step_req* fmi2_import_do_step_req) {
  delete fmi2_import_do_step_req_;
  fmi2_import_do_step_req_ = fmi2_import_do_step_req;
  if (fmi2_import_do_step_req) {
    set_has_fmi2_import_do_step_req();
  } else {
    clear_has_fmi2_import_do_step_req();
  }
}

// optional .fmitcp_proto.fmi2_import_do_step_res fmi2_import_do_step_res = 19;
inline bool fmitcp_message::has_fmi2_import_do_step_res() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_do_step_res() {
  _has_bits_[0] |= 0x00040000u;
}
inline void fmitcp_message::clear_has_fmi2_import_do_step_res() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void fmitcp_message::clear_fmi2_import_do_step_res() {
  if (fmi2_import_do_step_res_ != NULL) fmi2_import_do_step_res_->::fmitcp_proto::fmi2_import_do_step_res::Clear();
  clear_has_fmi2_import_do_step_res();
}
inline const ::fmitcp_proto::fmi2_import_do_step_res& fmitcp_message::fmi2_import_do_step_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_do_step_res_ != NULL ? *fmi2_import_do_step_res_ : *default_instance().fmi2_import_do_step_res_;
#else
  return fmi2_import_do_step_res_ != NULL ? *fmi2_import_do_step_res_ : *default_instance_->fmi2_import_do_step_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_do_step_res* fmitcp_message::mutable_fmi2_import_do_step_res() {
  set_has_fmi2_import_do_step_res();
  if (fmi2_import_do_step_res_ == NULL) fmi2_import_do_step_res_ = new ::fmitcp_proto::fmi2_import_do_step_res;
  return fmi2_import_do_step_res_;
}
inline ::fmitcp_proto::fmi2_import_do_step_res* fmitcp_message::release_fmi2_import_do_step_res() {
  clear_has_fmi2_import_do_step_res();
  ::fmitcp_proto::fmi2_import_do_step_res* temp = fmi2_import_do_step_res_;
  fmi2_import_do_step_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_do_step_res(::fmitcp_proto::fmi2_import_do_step_res* fmi2_import_do_step_res) {
  delete fmi2_import_do_step_res_;
  fmi2_import_do_step_res_ = fmi2_import_do_step_res;
  if (fmi2_import_do_step_res) {
    set_has_fmi2_import_do_step_res();
  } else {
    clear_has_fmi2_import_do_step_res();
  }
}

// optional .fmitcp_proto.fmi2_import_get_status_req fmi2_import_get_status_req = 20;
inline bool fmitcp_message::has_fmi2_import_get_status_req() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_status_req() {
  _has_bits_[0] |= 0x00080000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_status_req() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void fmitcp_message::clear_fmi2_import_get_status_req() {
  if (fmi2_import_get_status_req_ != NULL) fmi2_import_get_status_req_->::fmitcp_proto::fmi2_import_get_status_req::Clear();
  clear_has_fmi2_import_get_status_req();
}
inline const ::fmitcp_proto::fmi2_import_get_status_req& fmitcp_message::fmi2_import_get_status_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_status_req_ != NULL ? *fmi2_import_get_status_req_ : *default_instance().fmi2_import_get_status_req_;
#else
  return fmi2_import_get_status_req_ != NULL ? *fmi2_import_get_status_req_ : *default_instance_->fmi2_import_get_status_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_status_req* fmitcp_message::mutable_fmi2_import_get_status_req() {
  set_has_fmi2_import_get_status_req();
  if (fmi2_import_get_status_req_ == NULL) fmi2_import_get_status_req_ = new ::fmitcp_proto::fmi2_import_get_status_req;
  return fmi2_import_get_status_req_;
}
inline ::fmitcp_proto::fmi2_import_get_status_req* fmitcp_message::release_fmi2_import_get_status_req() {
  clear_has_fmi2_import_get_status_req();
  ::fmitcp_proto::fmi2_import_get_status_req* temp = fmi2_import_get_status_req_;
  fmi2_import_get_status_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_status_req(::fmitcp_proto::fmi2_import_get_status_req* fmi2_import_get_status_req) {
  delete fmi2_import_get_status_req_;
  fmi2_import_get_status_req_ = fmi2_import_get_status_req;
  if (fmi2_import_get_status_req) {
    set_has_fmi2_import_get_status_req();
  } else {
    clear_has_fmi2_import_get_status_req();
  }
}

// optional .fmitcp_proto.fmi2_import_get_status_res fmi2_import_get_status_res = 21;
inline bool fmitcp_message::has_fmi2_import_get_status_res() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_status_res() {
  _has_bits_[0] |= 0x00100000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_status_res() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void fmitcp_message::clear_fmi2_import_get_status_res() {
  if (fmi2_import_get_status_res_ != NULL) fmi2_import_get_status_res_->::fmitcp_proto::fmi2_import_get_status_res::Clear();
  clear_has_fmi2_import_get_status_res();
}
inline const ::fmitcp_proto::fmi2_import_get_status_res& fmitcp_message::fmi2_import_get_status_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_status_res_ != NULL ? *fmi2_import_get_status_res_ : *default_instance().fmi2_import_get_status_res_;
#else
  return fmi2_import_get_status_res_ != NULL ? *fmi2_import_get_status_res_ : *default_instance_->fmi2_import_get_status_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_status_res* fmitcp_message::mutable_fmi2_import_get_status_res() {
  set_has_fmi2_import_get_status_res();
  if (fmi2_import_get_status_res_ == NULL) fmi2_import_get_status_res_ = new ::fmitcp_proto::fmi2_import_get_status_res;
  return fmi2_import_get_status_res_;
}
inline ::fmitcp_proto::fmi2_import_get_status_res* fmitcp_message::release_fmi2_import_get_status_res() {
  clear_has_fmi2_import_get_status_res();
  ::fmitcp_proto::fmi2_import_get_status_res* temp = fmi2_import_get_status_res_;
  fmi2_import_get_status_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_status_res(::fmitcp_proto::fmi2_import_get_status_res* fmi2_import_get_status_res) {
  delete fmi2_import_get_status_res_;
  fmi2_import_get_status_res_ = fmi2_import_get_status_res;
  if (fmi2_import_get_status_res) {
    set_has_fmi2_import_get_status_res();
  } else {
    clear_has_fmi2_import_get_status_res();
  }
}

// optional .fmitcp_proto.fmi2_import_get_real_status_req fmi2_import_get_real_status_req = 22;
inline bool fmitcp_message::has_fmi2_import_get_real_status_req() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_real_status_req() {
  _has_bits_[0] |= 0x00200000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_real_status_req() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void fmitcp_message::clear_fmi2_import_get_real_status_req() {
  if (fmi2_import_get_real_status_req_ != NULL) fmi2_import_get_real_status_req_->::fmitcp_proto::fmi2_import_get_real_status_req::Clear();
  clear_has_fmi2_import_get_real_status_req();
}
inline const ::fmitcp_proto::fmi2_import_get_real_status_req& fmitcp_message::fmi2_import_get_real_status_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_real_status_req_ != NULL ? *fmi2_import_get_real_status_req_ : *default_instance().fmi2_import_get_real_status_req_;
#else
  return fmi2_import_get_real_status_req_ != NULL ? *fmi2_import_get_real_status_req_ : *default_instance_->fmi2_import_get_real_status_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_real_status_req* fmitcp_message::mutable_fmi2_import_get_real_status_req() {
  set_has_fmi2_import_get_real_status_req();
  if (fmi2_import_get_real_status_req_ == NULL) fmi2_import_get_real_status_req_ = new ::fmitcp_proto::fmi2_import_get_real_status_req;
  return fmi2_import_get_real_status_req_;
}
inline ::fmitcp_proto::fmi2_import_get_real_status_req* fmitcp_message::release_fmi2_import_get_real_status_req() {
  clear_has_fmi2_import_get_real_status_req();
  ::fmitcp_proto::fmi2_import_get_real_status_req* temp = fmi2_import_get_real_status_req_;
  fmi2_import_get_real_status_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_real_status_req(::fmitcp_proto::fmi2_import_get_real_status_req* fmi2_import_get_real_status_req) {
  delete fmi2_import_get_real_status_req_;
  fmi2_import_get_real_status_req_ = fmi2_import_get_real_status_req;
  if (fmi2_import_get_real_status_req) {
    set_has_fmi2_import_get_real_status_req();
  } else {
    clear_has_fmi2_import_get_real_status_req();
  }
}

// optional .fmitcp_proto.fmi2_import_get_real_status_res fmi2_import_get_real_status_res = 23;
inline bool fmitcp_message::has_fmi2_import_get_real_status_res() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_real_status_res() {
  _has_bits_[0] |= 0x00400000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_real_status_res() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void fmitcp_message::clear_fmi2_import_get_real_status_res() {
  if (fmi2_import_get_real_status_res_ != NULL) fmi2_import_get_real_status_res_->::fmitcp_proto::fmi2_import_get_real_status_res::Clear();
  clear_has_fmi2_import_get_real_status_res();
}
inline const ::fmitcp_proto::fmi2_import_get_real_status_res& fmitcp_message::fmi2_import_get_real_status_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_real_status_res_ != NULL ? *fmi2_import_get_real_status_res_ : *default_instance().fmi2_import_get_real_status_res_;
#else
  return fmi2_import_get_real_status_res_ != NULL ? *fmi2_import_get_real_status_res_ : *default_instance_->fmi2_import_get_real_status_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_real_status_res* fmitcp_message::mutable_fmi2_import_get_real_status_res() {
  set_has_fmi2_import_get_real_status_res();
  if (fmi2_import_get_real_status_res_ == NULL) fmi2_import_get_real_status_res_ = new ::fmitcp_proto::fmi2_import_get_real_status_res;
  return fmi2_import_get_real_status_res_;
}
inline ::fmitcp_proto::fmi2_import_get_real_status_res* fmitcp_message::release_fmi2_import_get_real_status_res() {
  clear_has_fmi2_import_get_real_status_res();
  ::fmitcp_proto::fmi2_import_get_real_status_res* temp = fmi2_import_get_real_status_res_;
  fmi2_import_get_real_status_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_real_status_res(::fmitcp_proto::fmi2_import_get_real_status_res* fmi2_import_get_real_status_res) {
  delete fmi2_import_get_real_status_res_;
  fmi2_import_get_real_status_res_ = fmi2_import_get_real_status_res;
  if (fmi2_import_get_real_status_res) {
    set_has_fmi2_import_get_real_status_res();
  } else {
    clear_has_fmi2_import_get_real_status_res();
  }
}

// optional .fmitcp_proto.fmi2_import_get_integer_status_req fmi2_import_get_integer_status_req = 24;
inline bool fmitcp_message::has_fmi2_import_get_integer_status_req() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_integer_status_req() {
  _has_bits_[0] |= 0x00800000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_integer_status_req() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void fmitcp_message::clear_fmi2_import_get_integer_status_req() {
  if (fmi2_import_get_integer_status_req_ != NULL) fmi2_import_get_integer_status_req_->::fmitcp_proto::fmi2_import_get_integer_status_req::Clear();
  clear_has_fmi2_import_get_integer_status_req();
}
inline const ::fmitcp_proto::fmi2_import_get_integer_status_req& fmitcp_message::fmi2_import_get_integer_status_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_integer_status_req_ != NULL ? *fmi2_import_get_integer_status_req_ : *default_instance().fmi2_import_get_integer_status_req_;
#else
  return fmi2_import_get_integer_status_req_ != NULL ? *fmi2_import_get_integer_status_req_ : *default_instance_->fmi2_import_get_integer_status_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_integer_status_req* fmitcp_message::mutable_fmi2_import_get_integer_status_req() {
  set_has_fmi2_import_get_integer_status_req();
  if (fmi2_import_get_integer_status_req_ == NULL) fmi2_import_get_integer_status_req_ = new ::fmitcp_proto::fmi2_import_get_integer_status_req;
  return fmi2_import_get_integer_status_req_;
}
inline ::fmitcp_proto::fmi2_import_get_integer_status_req* fmitcp_message::release_fmi2_import_get_integer_status_req() {
  clear_has_fmi2_import_get_integer_status_req();
  ::fmitcp_proto::fmi2_import_get_integer_status_req* temp = fmi2_import_get_integer_status_req_;
  fmi2_import_get_integer_status_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_integer_status_req(::fmitcp_proto::fmi2_import_get_integer_status_req* fmi2_import_get_integer_status_req) {
  delete fmi2_import_get_integer_status_req_;
  fmi2_import_get_integer_status_req_ = fmi2_import_get_integer_status_req;
  if (fmi2_import_get_integer_status_req) {
    set_has_fmi2_import_get_integer_status_req();
  } else {
    clear_has_fmi2_import_get_integer_status_req();
  }
}

// optional .fmitcp_proto.fmi2_import_get_integer_status_res fmi2_import_get_integer_status_res = 25;
inline bool fmitcp_message::has_fmi2_import_get_integer_status_res() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_integer_status_res() {
  _has_bits_[0] |= 0x01000000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_integer_status_res() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void fmitcp_message::clear_fmi2_import_get_integer_status_res() {
  if (fmi2_import_get_integer_status_res_ != NULL) fmi2_import_get_integer_status_res_->::fmitcp_proto::fmi2_import_get_integer_status_res::Clear();
  clear_has_fmi2_import_get_integer_status_res();
}
inline const ::fmitcp_proto::fmi2_import_get_integer_status_res& fmitcp_message::fmi2_import_get_integer_status_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_integer_status_res_ != NULL ? *fmi2_import_get_integer_status_res_ : *default_instance().fmi2_import_get_integer_status_res_;
#else
  return fmi2_import_get_integer_status_res_ != NULL ? *fmi2_import_get_integer_status_res_ : *default_instance_->fmi2_import_get_integer_status_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_integer_status_res* fmitcp_message::mutable_fmi2_import_get_integer_status_res() {
  set_has_fmi2_import_get_integer_status_res();
  if (fmi2_import_get_integer_status_res_ == NULL) fmi2_import_get_integer_status_res_ = new ::fmitcp_proto::fmi2_import_get_integer_status_res;
  return fmi2_import_get_integer_status_res_;
}
inline ::fmitcp_proto::fmi2_import_get_integer_status_res* fmitcp_message::release_fmi2_import_get_integer_status_res() {
  clear_has_fmi2_import_get_integer_status_res();
  ::fmitcp_proto::fmi2_import_get_integer_status_res* temp = fmi2_import_get_integer_status_res_;
  fmi2_import_get_integer_status_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_integer_status_res(::fmitcp_proto::fmi2_import_get_integer_status_res* fmi2_import_get_integer_status_res) {
  delete fmi2_import_get_integer_status_res_;
  fmi2_import_get_integer_status_res_ = fmi2_import_get_integer_status_res;
  if (fmi2_import_get_integer_status_res) {
    set_has_fmi2_import_get_integer_status_res();
  } else {
    clear_has_fmi2_import_get_integer_status_res();
  }
}

// optional .fmitcp_proto.fmi2_import_get_boolean_status_req fmi2_import_get_boolean_status_req = 26;
inline bool fmitcp_message::has_fmi2_import_get_boolean_status_req() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_boolean_status_req() {
  _has_bits_[0] |= 0x02000000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_boolean_status_req() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void fmitcp_message::clear_fmi2_import_get_boolean_status_req() {
  if (fmi2_import_get_boolean_status_req_ != NULL) fmi2_import_get_boolean_status_req_->::fmitcp_proto::fmi2_import_get_boolean_status_req::Clear();
  clear_has_fmi2_import_get_boolean_status_req();
}
inline const ::fmitcp_proto::fmi2_import_get_boolean_status_req& fmitcp_message::fmi2_import_get_boolean_status_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_boolean_status_req_ != NULL ? *fmi2_import_get_boolean_status_req_ : *default_instance().fmi2_import_get_boolean_status_req_;
#else
  return fmi2_import_get_boolean_status_req_ != NULL ? *fmi2_import_get_boolean_status_req_ : *default_instance_->fmi2_import_get_boolean_status_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_boolean_status_req* fmitcp_message::mutable_fmi2_import_get_boolean_status_req() {
  set_has_fmi2_import_get_boolean_status_req();
  if (fmi2_import_get_boolean_status_req_ == NULL) fmi2_import_get_boolean_status_req_ = new ::fmitcp_proto::fmi2_import_get_boolean_status_req;
  return fmi2_import_get_boolean_status_req_;
}
inline ::fmitcp_proto::fmi2_import_get_boolean_status_req* fmitcp_message::release_fmi2_import_get_boolean_status_req() {
  clear_has_fmi2_import_get_boolean_status_req();
  ::fmitcp_proto::fmi2_import_get_boolean_status_req* temp = fmi2_import_get_boolean_status_req_;
  fmi2_import_get_boolean_status_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_boolean_status_req(::fmitcp_proto::fmi2_import_get_boolean_status_req* fmi2_import_get_boolean_status_req) {
  delete fmi2_import_get_boolean_status_req_;
  fmi2_import_get_boolean_status_req_ = fmi2_import_get_boolean_status_req;
  if (fmi2_import_get_boolean_status_req) {
    set_has_fmi2_import_get_boolean_status_req();
  } else {
    clear_has_fmi2_import_get_boolean_status_req();
  }
}

// optional .fmitcp_proto.fmi2_import_get_boolean_status_res fmi2_import_get_boolean_status_res = 27;
inline bool fmitcp_message::has_fmi2_import_get_boolean_status_res() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_boolean_status_res() {
  _has_bits_[0] |= 0x04000000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_boolean_status_res() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void fmitcp_message::clear_fmi2_import_get_boolean_status_res() {
  if (fmi2_import_get_boolean_status_res_ != NULL) fmi2_import_get_boolean_status_res_->::fmitcp_proto::fmi2_import_get_boolean_status_res::Clear();
  clear_has_fmi2_import_get_boolean_status_res();
}
inline const ::fmitcp_proto::fmi2_import_get_boolean_status_res& fmitcp_message::fmi2_import_get_boolean_status_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_boolean_status_res_ != NULL ? *fmi2_import_get_boolean_status_res_ : *default_instance().fmi2_import_get_boolean_status_res_;
#else
  return fmi2_import_get_boolean_status_res_ != NULL ? *fmi2_import_get_boolean_status_res_ : *default_instance_->fmi2_import_get_boolean_status_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_boolean_status_res* fmitcp_message::mutable_fmi2_import_get_boolean_status_res() {
  set_has_fmi2_import_get_boolean_status_res();
  if (fmi2_import_get_boolean_status_res_ == NULL) fmi2_import_get_boolean_status_res_ = new ::fmitcp_proto::fmi2_import_get_boolean_status_res;
  return fmi2_import_get_boolean_status_res_;
}
inline ::fmitcp_proto::fmi2_import_get_boolean_status_res* fmitcp_message::release_fmi2_import_get_boolean_status_res() {
  clear_has_fmi2_import_get_boolean_status_res();
  ::fmitcp_proto::fmi2_import_get_boolean_status_res* temp = fmi2_import_get_boolean_status_res_;
  fmi2_import_get_boolean_status_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_boolean_status_res(::fmitcp_proto::fmi2_import_get_boolean_status_res* fmi2_import_get_boolean_status_res) {
  delete fmi2_import_get_boolean_status_res_;
  fmi2_import_get_boolean_status_res_ = fmi2_import_get_boolean_status_res;
  if (fmi2_import_get_boolean_status_res) {
    set_has_fmi2_import_get_boolean_status_res();
  } else {
    clear_has_fmi2_import_get_boolean_status_res();
  }
}

// optional .fmitcp_proto.fmi2_import_get_string_status_req fmi2_import_get_string_status_req = 28;
inline bool fmitcp_message::has_fmi2_import_get_string_status_req() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_string_status_req() {
  _has_bits_[0] |= 0x08000000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_string_status_req() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void fmitcp_message::clear_fmi2_import_get_string_status_req() {
  if (fmi2_import_get_string_status_req_ != NULL) fmi2_import_get_string_status_req_->::fmitcp_proto::fmi2_import_get_string_status_req::Clear();
  clear_has_fmi2_import_get_string_status_req();
}
inline const ::fmitcp_proto::fmi2_import_get_string_status_req& fmitcp_message::fmi2_import_get_string_status_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_string_status_req_ != NULL ? *fmi2_import_get_string_status_req_ : *default_instance().fmi2_import_get_string_status_req_;
#else
  return fmi2_import_get_string_status_req_ != NULL ? *fmi2_import_get_string_status_req_ : *default_instance_->fmi2_import_get_string_status_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_string_status_req* fmitcp_message::mutable_fmi2_import_get_string_status_req() {
  set_has_fmi2_import_get_string_status_req();
  if (fmi2_import_get_string_status_req_ == NULL) fmi2_import_get_string_status_req_ = new ::fmitcp_proto::fmi2_import_get_string_status_req;
  return fmi2_import_get_string_status_req_;
}
inline ::fmitcp_proto::fmi2_import_get_string_status_req* fmitcp_message::release_fmi2_import_get_string_status_req() {
  clear_has_fmi2_import_get_string_status_req();
  ::fmitcp_proto::fmi2_import_get_string_status_req* temp = fmi2_import_get_string_status_req_;
  fmi2_import_get_string_status_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_string_status_req(::fmitcp_proto::fmi2_import_get_string_status_req* fmi2_import_get_string_status_req) {
  delete fmi2_import_get_string_status_req_;
  fmi2_import_get_string_status_req_ = fmi2_import_get_string_status_req;
  if (fmi2_import_get_string_status_req) {
    set_has_fmi2_import_get_string_status_req();
  } else {
    clear_has_fmi2_import_get_string_status_req();
  }
}

// optional .fmitcp_proto.fmi2_import_get_string_status_res fmi2_import_get_string_status_res = 29;
inline bool fmitcp_message::has_fmi2_import_get_string_status_res() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_string_status_res() {
  _has_bits_[0] |= 0x10000000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_string_status_res() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void fmitcp_message::clear_fmi2_import_get_string_status_res() {
  if (fmi2_import_get_string_status_res_ != NULL) fmi2_import_get_string_status_res_->::fmitcp_proto::fmi2_import_get_string_status_res::Clear();
  clear_has_fmi2_import_get_string_status_res();
}
inline const ::fmitcp_proto::fmi2_import_get_string_status_res& fmitcp_message::fmi2_import_get_string_status_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_string_status_res_ != NULL ? *fmi2_import_get_string_status_res_ : *default_instance().fmi2_import_get_string_status_res_;
#else
  return fmi2_import_get_string_status_res_ != NULL ? *fmi2_import_get_string_status_res_ : *default_instance_->fmi2_import_get_string_status_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_string_status_res* fmitcp_message::mutable_fmi2_import_get_string_status_res() {
  set_has_fmi2_import_get_string_status_res();
  if (fmi2_import_get_string_status_res_ == NULL) fmi2_import_get_string_status_res_ = new ::fmitcp_proto::fmi2_import_get_string_status_res;
  return fmi2_import_get_string_status_res_;
}
inline ::fmitcp_proto::fmi2_import_get_string_status_res* fmitcp_message::release_fmi2_import_get_string_status_res() {
  clear_has_fmi2_import_get_string_status_res();
  ::fmitcp_proto::fmi2_import_get_string_status_res* temp = fmi2_import_get_string_status_res_;
  fmi2_import_get_string_status_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_string_status_res(::fmitcp_proto::fmi2_import_get_string_status_res* fmi2_import_get_string_status_res) {
  delete fmi2_import_get_string_status_res_;
  fmi2_import_get_string_status_res_ = fmi2_import_get_string_status_res;
  if (fmi2_import_get_string_status_res) {
    set_has_fmi2_import_get_string_status_res();
  } else {
    clear_has_fmi2_import_get_string_status_res();
  }
}

// optional .fmitcp_proto.fmi2_import_instantiate_model_req fmi2_import_instantiate_model_req = 30;
inline bool fmitcp_message::has_fmi2_import_instantiate_model_req() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_instantiate_model_req() {
  _has_bits_[0] |= 0x20000000u;
}
inline void fmitcp_message::clear_has_fmi2_import_instantiate_model_req() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void fmitcp_message::clear_fmi2_import_instantiate_model_req() {
  if (fmi2_import_instantiate_model_req_ != NULL) fmi2_import_instantiate_model_req_->::fmitcp_proto::fmi2_import_instantiate_model_req::Clear();
  clear_has_fmi2_import_instantiate_model_req();
}
inline const ::fmitcp_proto::fmi2_import_instantiate_model_req& fmitcp_message::fmi2_import_instantiate_model_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_instantiate_model_req_ != NULL ? *fmi2_import_instantiate_model_req_ : *default_instance().fmi2_import_instantiate_model_req_;
#else
  return fmi2_import_instantiate_model_req_ != NULL ? *fmi2_import_instantiate_model_req_ : *default_instance_->fmi2_import_instantiate_model_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_instantiate_model_req* fmitcp_message::mutable_fmi2_import_instantiate_model_req() {
  set_has_fmi2_import_instantiate_model_req();
  if (fmi2_import_instantiate_model_req_ == NULL) fmi2_import_instantiate_model_req_ = new ::fmitcp_proto::fmi2_import_instantiate_model_req;
  return fmi2_import_instantiate_model_req_;
}
inline ::fmitcp_proto::fmi2_import_instantiate_model_req* fmitcp_message::release_fmi2_import_instantiate_model_req() {
  clear_has_fmi2_import_instantiate_model_req();
  ::fmitcp_proto::fmi2_import_instantiate_model_req* temp = fmi2_import_instantiate_model_req_;
  fmi2_import_instantiate_model_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_instantiate_model_req(::fmitcp_proto::fmi2_import_instantiate_model_req* fmi2_import_instantiate_model_req) {
  delete fmi2_import_instantiate_model_req_;
  fmi2_import_instantiate_model_req_ = fmi2_import_instantiate_model_req;
  if (fmi2_import_instantiate_model_req) {
    set_has_fmi2_import_instantiate_model_req();
  } else {
    clear_has_fmi2_import_instantiate_model_req();
  }
}

// optional .fmitcp_proto.fmi2_import_instantiate_model_res fmi2_import_instantiate_model_res = 31;
inline bool fmitcp_message::has_fmi2_import_instantiate_model_res() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_instantiate_model_res() {
  _has_bits_[0] |= 0x40000000u;
}
inline void fmitcp_message::clear_has_fmi2_import_instantiate_model_res() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void fmitcp_message::clear_fmi2_import_instantiate_model_res() {
  if (fmi2_import_instantiate_model_res_ != NULL) fmi2_import_instantiate_model_res_->::fmitcp_proto::fmi2_import_instantiate_model_res::Clear();
  clear_has_fmi2_import_instantiate_model_res();
}
inline const ::fmitcp_proto::fmi2_import_instantiate_model_res& fmitcp_message::fmi2_import_instantiate_model_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_instantiate_model_res_ != NULL ? *fmi2_import_instantiate_model_res_ : *default_instance().fmi2_import_instantiate_model_res_;
#else
  return fmi2_import_instantiate_model_res_ != NULL ? *fmi2_import_instantiate_model_res_ : *default_instance_->fmi2_import_instantiate_model_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_instantiate_model_res* fmitcp_message::mutable_fmi2_import_instantiate_model_res() {
  set_has_fmi2_import_instantiate_model_res();
  if (fmi2_import_instantiate_model_res_ == NULL) fmi2_import_instantiate_model_res_ = new ::fmitcp_proto::fmi2_import_instantiate_model_res;
  return fmi2_import_instantiate_model_res_;
}
inline ::fmitcp_proto::fmi2_import_instantiate_model_res* fmitcp_message::release_fmi2_import_instantiate_model_res() {
  clear_has_fmi2_import_instantiate_model_res();
  ::fmitcp_proto::fmi2_import_instantiate_model_res* temp = fmi2_import_instantiate_model_res_;
  fmi2_import_instantiate_model_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_instantiate_model_res(::fmitcp_proto::fmi2_import_instantiate_model_res* fmi2_import_instantiate_model_res) {
  delete fmi2_import_instantiate_model_res_;
  fmi2_import_instantiate_model_res_ = fmi2_import_instantiate_model_res;
  if (fmi2_import_instantiate_model_res) {
    set_has_fmi2_import_instantiate_model_res();
  } else {
    clear_has_fmi2_import_instantiate_model_res();
  }
}

// optional .fmitcp_proto.fmi2_import_free_model_instance_req fmi2_import_free_model_instance_req = 32;
inline bool fmitcp_message::has_fmi2_import_free_model_instance_req() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_free_model_instance_req() {
  _has_bits_[0] |= 0x80000000u;
}
inline void fmitcp_message::clear_has_fmi2_import_free_model_instance_req() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void fmitcp_message::clear_fmi2_import_free_model_instance_req() {
  if (fmi2_import_free_model_instance_req_ != NULL) fmi2_import_free_model_instance_req_->::fmitcp_proto::fmi2_import_free_model_instance_req::Clear();
  clear_has_fmi2_import_free_model_instance_req();
}
inline const ::fmitcp_proto::fmi2_import_free_model_instance_req& fmitcp_message::fmi2_import_free_model_instance_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_free_model_instance_req_ != NULL ? *fmi2_import_free_model_instance_req_ : *default_instance().fmi2_import_free_model_instance_req_;
#else
  return fmi2_import_free_model_instance_req_ != NULL ? *fmi2_import_free_model_instance_req_ : *default_instance_->fmi2_import_free_model_instance_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_free_model_instance_req* fmitcp_message::mutable_fmi2_import_free_model_instance_req() {
  set_has_fmi2_import_free_model_instance_req();
  if (fmi2_import_free_model_instance_req_ == NULL) fmi2_import_free_model_instance_req_ = new ::fmitcp_proto::fmi2_import_free_model_instance_req;
  return fmi2_import_free_model_instance_req_;
}
inline ::fmitcp_proto::fmi2_import_free_model_instance_req* fmitcp_message::release_fmi2_import_free_model_instance_req() {
  clear_has_fmi2_import_free_model_instance_req();
  ::fmitcp_proto::fmi2_import_free_model_instance_req* temp = fmi2_import_free_model_instance_req_;
  fmi2_import_free_model_instance_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_free_model_instance_req(::fmitcp_proto::fmi2_import_free_model_instance_req* fmi2_import_free_model_instance_req) {
  delete fmi2_import_free_model_instance_req_;
  fmi2_import_free_model_instance_req_ = fmi2_import_free_model_instance_req;
  if (fmi2_import_free_model_instance_req) {
    set_has_fmi2_import_free_model_instance_req();
  } else {
    clear_has_fmi2_import_free_model_instance_req();
  }
}

// optional .fmitcp_proto.fmi2_import_free_model_instance_res fmi2_import_free_model_instance_res = 33;
inline bool fmitcp_message::has_fmi2_import_free_model_instance_res() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_free_model_instance_res() {
  _has_bits_[1] |= 0x00000001u;
}
inline void fmitcp_message::clear_has_fmi2_import_free_model_instance_res() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void fmitcp_message::clear_fmi2_import_free_model_instance_res() {
  if (fmi2_import_free_model_instance_res_ != NULL) fmi2_import_free_model_instance_res_->::fmitcp_proto::fmi2_import_free_model_instance_res::Clear();
  clear_has_fmi2_import_free_model_instance_res();
}
inline const ::fmitcp_proto::fmi2_import_free_model_instance_res& fmitcp_message::fmi2_import_free_model_instance_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_free_model_instance_res_ != NULL ? *fmi2_import_free_model_instance_res_ : *default_instance().fmi2_import_free_model_instance_res_;
#else
  return fmi2_import_free_model_instance_res_ != NULL ? *fmi2_import_free_model_instance_res_ : *default_instance_->fmi2_import_free_model_instance_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_free_model_instance_res* fmitcp_message::mutable_fmi2_import_free_model_instance_res() {
  set_has_fmi2_import_free_model_instance_res();
  if (fmi2_import_free_model_instance_res_ == NULL) fmi2_import_free_model_instance_res_ = new ::fmitcp_proto::fmi2_import_free_model_instance_res;
  return fmi2_import_free_model_instance_res_;
}
inline ::fmitcp_proto::fmi2_import_free_model_instance_res* fmitcp_message::release_fmi2_import_free_model_instance_res() {
  clear_has_fmi2_import_free_model_instance_res();
  ::fmitcp_proto::fmi2_import_free_model_instance_res* temp = fmi2_import_free_model_instance_res_;
  fmi2_import_free_model_instance_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_free_model_instance_res(::fmitcp_proto::fmi2_import_free_model_instance_res* fmi2_import_free_model_instance_res) {
  delete fmi2_import_free_model_instance_res_;
  fmi2_import_free_model_instance_res_ = fmi2_import_free_model_instance_res;
  if (fmi2_import_free_model_instance_res) {
    set_has_fmi2_import_free_model_instance_res();
  } else {
    clear_has_fmi2_import_free_model_instance_res();
  }
}

// optional .fmitcp_proto.fmi2_import_set_time_req fmi2_import_set_time_req = 34;
inline bool fmitcp_message::has_fmi2_import_set_time_req() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_set_time_req() {
  _has_bits_[1] |= 0x00000002u;
}
inline void fmitcp_message::clear_has_fmi2_import_set_time_req() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void fmitcp_message::clear_fmi2_import_set_time_req() {
  if (fmi2_import_set_time_req_ != NULL) fmi2_import_set_time_req_->::fmitcp_proto::fmi2_import_set_time_req::Clear();
  clear_has_fmi2_import_set_time_req();
}
inline const ::fmitcp_proto::fmi2_import_set_time_req& fmitcp_message::fmi2_import_set_time_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_set_time_req_ != NULL ? *fmi2_import_set_time_req_ : *default_instance().fmi2_import_set_time_req_;
#else
  return fmi2_import_set_time_req_ != NULL ? *fmi2_import_set_time_req_ : *default_instance_->fmi2_import_set_time_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_set_time_req* fmitcp_message::mutable_fmi2_import_set_time_req() {
  set_has_fmi2_import_set_time_req();
  if (fmi2_import_set_time_req_ == NULL) fmi2_import_set_time_req_ = new ::fmitcp_proto::fmi2_import_set_time_req;
  return fmi2_import_set_time_req_;
}
inline ::fmitcp_proto::fmi2_import_set_time_req* fmitcp_message::release_fmi2_import_set_time_req() {
  clear_has_fmi2_import_set_time_req();
  ::fmitcp_proto::fmi2_import_set_time_req* temp = fmi2_import_set_time_req_;
  fmi2_import_set_time_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_set_time_req(::fmitcp_proto::fmi2_import_set_time_req* fmi2_import_set_time_req) {
  delete fmi2_import_set_time_req_;
  fmi2_import_set_time_req_ = fmi2_import_set_time_req;
  if (fmi2_import_set_time_req) {
    set_has_fmi2_import_set_time_req();
  } else {
    clear_has_fmi2_import_set_time_req();
  }
}

// optional .fmitcp_proto.fmi2_import_set_time_res fmi2_import_set_time_res = 35;
inline bool fmitcp_message::has_fmi2_import_set_time_res() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_set_time_res() {
  _has_bits_[1] |= 0x00000004u;
}
inline void fmitcp_message::clear_has_fmi2_import_set_time_res() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void fmitcp_message::clear_fmi2_import_set_time_res() {
  if (fmi2_import_set_time_res_ != NULL) fmi2_import_set_time_res_->::fmitcp_proto::fmi2_import_set_time_res::Clear();
  clear_has_fmi2_import_set_time_res();
}
inline const ::fmitcp_proto::fmi2_import_set_time_res& fmitcp_message::fmi2_import_set_time_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_set_time_res_ != NULL ? *fmi2_import_set_time_res_ : *default_instance().fmi2_import_set_time_res_;
#else
  return fmi2_import_set_time_res_ != NULL ? *fmi2_import_set_time_res_ : *default_instance_->fmi2_import_set_time_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_set_time_res* fmitcp_message::mutable_fmi2_import_set_time_res() {
  set_has_fmi2_import_set_time_res();
  if (fmi2_import_set_time_res_ == NULL) fmi2_import_set_time_res_ = new ::fmitcp_proto::fmi2_import_set_time_res;
  return fmi2_import_set_time_res_;
}
inline ::fmitcp_proto::fmi2_import_set_time_res* fmitcp_message::release_fmi2_import_set_time_res() {
  clear_has_fmi2_import_set_time_res();
  ::fmitcp_proto::fmi2_import_set_time_res* temp = fmi2_import_set_time_res_;
  fmi2_import_set_time_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_set_time_res(::fmitcp_proto::fmi2_import_set_time_res* fmi2_import_set_time_res) {
  delete fmi2_import_set_time_res_;
  fmi2_import_set_time_res_ = fmi2_import_set_time_res;
  if (fmi2_import_set_time_res) {
    set_has_fmi2_import_set_time_res();
  } else {
    clear_has_fmi2_import_set_time_res();
  }
}

// optional .fmitcp_proto.fmi2_import_set_continuous_states_req fmi2_import_set_continuous_states_req = 36;
inline bool fmitcp_message::has_fmi2_import_set_continuous_states_req() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_set_continuous_states_req() {
  _has_bits_[1] |= 0x00000008u;
}
inline void fmitcp_message::clear_has_fmi2_import_set_continuous_states_req() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void fmitcp_message::clear_fmi2_import_set_continuous_states_req() {
  if (fmi2_import_set_continuous_states_req_ != NULL) fmi2_import_set_continuous_states_req_->::fmitcp_proto::fmi2_import_set_continuous_states_req::Clear();
  clear_has_fmi2_import_set_continuous_states_req();
}
inline const ::fmitcp_proto::fmi2_import_set_continuous_states_req& fmitcp_message::fmi2_import_set_continuous_states_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_set_continuous_states_req_ != NULL ? *fmi2_import_set_continuous_states_req_ : *default_instance().fmi2_import_set_continuous_states_req_;
#else
  return fmi2_import_set_continuous_states_req_ != NULL ? *fmi2_import_set_continuous_states_req_ : *default_instance_->fmi2_import_set_continuous_states_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_set_continuous_states_req* fmitcp_message::mutable_fmi2_import_set_continuous_states_req() {
  set_has_fmi2_import_set_continuous_states_req();
  if (fmi2_import_set_continuous_states_req_ == NULL) fmi2_import_set_continuous_states_req_ = new ::fmitcp_proto::fmi2_import_set_continuous_states_req;
  return fmi2_import_set_continuous_states_req_;
}
inline ::fmitcp_proto::fmi2_import_set_continuous_states_req* fmitcp_message::release_fmi2_import_set_continuous_states_req() {
  clear_has_fmi2_import_set_continuous_states_req();
  ::fmitcp_proto::fmi2_import_set_continuous_states_req* temp = fmi2_import_set_continuous_states_req_;
  fmi2_import_set_continuous_states_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_set_continuous_states_req(::fmitcp_proto::fmi2_import_set_continuous_states_req* fmi2_import_set_continuous_states_req) {
  delete fmi2_import_set_continuous_states_req_;
  fmi2_import_set_continuous_states_req_ = fmi2_import_set_continuous_states_req;
  if (fmi2_import_set_continuous_states_req) {
    set_has_fmi2_import_set_continuous_states_req();
  } else {
    clear_has_fmi2_import_set_continuous_states_req();
  }
}

// optional .fmitcp_proto.fmi2_import_set_continuous_states_res fmi2_import_set_continuous_states_res = 37;
inline bool fmitcp_message::has_fmi2_import_set_continuous_states_res() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_set_continuous_states_res() {
  _has_bits_[1] |= 0x00000010u;
}
inline void fmitcp_message::clear_has_fmi2_import_set_continuous_states_res() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void fmitcp_message::clear_fmi2_import_set_continuous_states_res() {
  if (fmi2_import_set_continuous_states_res_ != NULL) fmi2_import_set_continuous_states_res_->::fmitcp_proto::fmi2_import_set_continuous_states_res::Clear();
  clear_has_fmi2_import_set_continuous_states_res();
}
inline const ::fmitcp_proto::fmi2_import_set_continuous_states_res& fmitcp_message::fmi2_import_set_continuous_states_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_set_continuous_states_res_ != NULL ? *fmi2_import_set_continuous_states_res_ : *default_instance().fmi2_import_set_continuous_states_res_;
#else
  return fmi2_import_set_continuous_states_res_ != NULL ? *fmi2_import_set_continuous_states_res_ : *default_instance_->fmi2_import_set_continuous_states_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_set_continuous_states_res* fmitcp_message::mutable_fmi2_import_set_continuous_states_res() {
  set_has_fmi2_import_set_continuous_states_res();
  if (fmi2_import_set_continuous_states_res_ == NULL) fmi2_import_set_continuous_states_res_ = new ::fmitcp_proto::fmi2_import_set_continuous_states_res;
  return fmi2_import_set_continuous_states_res_;
}
inline ::fmitcp_proto::fmi2_import_set_continuous_states_res* fmitcp_message::release_fmi2_import_set_continuous_states_res() {
  clear_has_fmi2_import_set_continuous_states_res();
  ::fmitcp_proto::fmi2_import_set_continuous_states_res* temp = fmi2_import_set_continuous_states_res_;
  fmi2_import_set_continuous_states_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_set_continuous_states_res(::fmitcp_proto::fmi2_import_set_continuous_states_res* fmi2_import_set_continuous_states_res) {
  delete fmi2_import_set_continuous_states_res_;
  fmi2_import_set_continuous_states_res_ = fmi2_import_set_continuous_states_res;
  if (fmi2_import_set_continuous_states_res) {
    set_has_fmi2_import_set_continuous_states_res();
  } else {
    clear_has_fmi2_import_set_continuous_states_res();
  }
}

// optional .fmitcp_proto.fmi2_import_completed_integrator_step_req fmi2_import_completed_integrator_step_req = 38;
inline bool fmitcp_message::has_fmi2_import_completed_integrator_step_req() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_completed_integrator_step_req() {
  _has_bits_[1] |= 0x00000020u;
}
inline void fmitcp_message::clear_has_fmi2_import_completed_integrator_step_req() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void fmitcp_message::clear_fmi2_import_completed_integrator_step_req() {
  if (fmi2_import_completed_integrator_step_req_ != NULL) fmi2_import_completed_integrator_step_req_->::fmitcp_proto::fmi2_import_completed_integrator_step_req::Clear();
  clear_has_fmi2_import_completed_integrator_step_req();
}
inline const ::fmitcp_proto::fmi2_import_completed_integrator_step_req& fmitcp_message::fmi2_import_completed_integrator_step_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_completed_integrator_step_req_ != NULL ? *fmi2_import_completed_integrator_step_req_ : *default_instance().fmi2_import_completed_integrator_step_req_;
#else
  return fmi2_import_completed_integrator_step_req_ != NULL ? *fmi2_import_completed_integrator_step_req_ : *default_instance_->fmi2_import_completed_integrator_step_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_completed_integrator_step_req* fmitcp_message::mutable_fmi2_import_completed_integrator_step_req() {
  set_has_fmi2_import_completed_integrator_step_req();
  if (fmi2_import_completed_integrator_step_req_ == NULL) fmi2_import_completed_integrator_step_req_ = new ::fmitcp_proto::fmi2_import_completed_integrator_step_req;
  return fmi2_import_completed_integrator_step_req_;
}
inline ::fmitcp_proto::fmi2_import_completed_integrator_step_req* fmitcp_message::release_fmi2_import_completed_integrator_step_req() {
  clear_has_fmi2_import_completed_integrator_step_req();
  ::fmitcp_proto::fmi2_import_completed_integrator_step_req* temp = fmi2_import_completed_integrator_step_req_;
  fmi2_import_completed_integrator_step_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_completed_integrator_step_req(::fmitcp_proto::fmi2_import_completed_integrator_step_req* fmi2_import_completed_integrator_step_req) {
  delete fmi2_import_completed_integrator_step_req_;
  fmi2_import_completed_integrator_step_req_ = fmi2_import_completed_integrator_step_req;
  if (fmi2_import_completed_integrator_step_req) {
    set_has_fmi2_import_completed_integrator_step_req();
  } else {
    clear_has_fmi2_import_completed_integrator_step_req();
  }
}

// optional .fmitcp_proto.fmi2_import_completed_integrator_step_res fmi2_import_completed_integrator_step_res = 39;
inline bool fmitcp_message::has_fmi2_import_completed_integrator_step_res() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_completed_integrator_step_res() {
  _has_bits_[1] |= 0x00000040u;
}
inline void fmitcp_message::clear_has_fmi2_import_completed_integrator_step_res() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void fmitcp_message::clear_fmi2_import_completed_integrator_step_res() {
  if (fmi2_import_completed_integrator_step_res_ != NULL) fmi2_import_completed_integrator_step_res_->::fmitcp_proto::fmi2_import_completed_integrator_step_res::Clear();
  clear_has_fmi2_import_completed_integrator_step_res();
}
inline const ::fmitcp_proto::fmi2_import_completed_integrator_step_res& fmitcp_message::fmi2_import_completed_integrator_step_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_completed_integrator_step_res_ != NULL ? *fmi2_import_completed_integrator_step_res_ : *default_instance().fmi2_import_completed_integrator_step_res_;
#else
  return fmi2_import_completed_integrator_step_res_ != NULL ? *fmi2_import_completed_integrator_step_res_ : *default_instance_->fmi2_import_completed_integrator_step_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_completed_integrator_step_res* fmitcp_message::mutable_fmi2_import_completed_integrator_step_res() {
  set_has_fmi2_import_completed_integrator_step_res();
  if (fmi2_import_completed_integrator_step_res_ == NULL) fmi2_import_completed_integrator_step_res_ = new ::fmitcp_proto::fmi2_import_completed_integrator_step_res;
  return fmi2_import_completed_integrator_step_res_;
}
inline ::fmitcp_proto::fmi2_import_completed_integrator_step_res* fmitcp_message::release_fmi2_import_completed_integrator_step_res() {
  clear_has_fmi2_import_completed_integrator_step_res();
  ::fmitcp_proto::fmi2_import_completed_integrator_step_res* temp = fmi2_import_completed_integrator_step_res_;
  fmi2_import_completed_integrator_step_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_completed_integrator_step_res(::fmitcp_proto::fmi2_import_completed_integrator_step_res* fmi2_import_completed_integrator_step_res) {
  delete fmi2_import_completed_integrator_step_res_;
  fmi2_import_completed_integrator_step_res_ = fmi2_import_completed_integrator_step_res;
  if (fmi2_import_completed_integrator_step_res) {
    set_has_fmi2_import_completed_integrator_step_res();
  } else {
    clear_has_fmi2_import_completed_integrator_step_res();
  }
}

// optional .fmitcp_proto.fmi2_import_initialize_model_req fmi2_import_initialize_model_req = 40;
inline bool fmitcp_message::has_fmi2_import_initialize_model_req() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_initialize_model_req() {
  _has_bits_[1] |= 0x00000080u;
}
inline void fmitcp_message::clear_has_fmi2_import_initialize_model_req() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void fmitcp_message::clear_fmi2_import_initialize_model_req() {
  if (fmi2_import_initialize_model_req_ != NULL) fmi2_import_initialize_model_req_->::fmitcp_proto::fmi2_import_initialize_model_req::Clear();
  clear_has_fmi2_import_initialize_model_req();
}
inline const ::fmitcp_proto::fmi2_import_initialize_model_req& fmitcp_message::fmi2_import_initialize_model_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_initialize_model_req_ != NULL ? *fmi2_import_initialize_model_req_ : *default_instance().fmi2_import_initialize_model_req_;
#else
  return fmi2_import_initialize_model_req_ != NULL ? *fmi2_import_initialize_model_req_ : *default_instance_->fmi2_import_initialize_model_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_initialize_model_req* fmitcp_message::mutable_fmi2_import_initialize_model_req() {
  set_has_fmi2_import_initialize_model_req();
  if (fmi2_import_initialize_model_req_ == NULL) fmi2_import_initialize_model_req_ = new ::fmitcp_proto::fmi2_import_initialize_model_req;
  return fmi2_import_initialize_model_req_;
}
inline ::fmitcp_proto::fmi2_import_initialize_model_req* fmitcp_message::release_fmi2_import_initialize_model_req() {
  clear_has_fmi2_import_initialize_model_req();
  ::fmitcp_proto::fmi2_import_initialize_model_req* temp = fmi2_import_initialize_model_req_;
  fmi2_import_initialize_model_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_initialize_model_req(::fmitcp_proto::fmi2_import_initialize_model_req* fmi2_import_initialize_model_req) {
  delete fmi2_import_initialize_model_req_;
  fmi2_import_initialize_model_req_ = fmi2_import_initialize_model_req;
  if (fmi2_import_initialize_model_req) {
    set_has_fmi2_import_initialize_model_req();
  } else {
    clear_has_fmi2_import_initialize_model_req();
  }
}

// optional .fmitcp_proto.fmi2_import_initialize_model_res fmi2_import_initialize_model_res = 41;
inline bool fmitcp_message::has_fmi2_import_initialize_model_res() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_initialize_model_res() {
  _has_bits_[1] |= 0x00000100u;
}
inline void fmitcp_message::clear_has_fmi2_import_initialize_model_res() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void fmitcp_message::clear_fmi2_import_initialize_model_res() {
  if (fmi2_import_initialize_model_res_ != NULL) fmi2_import_initialize_model_res_->::fmitcp_proto::fmi2_import_initialize_model_res::Clear();
  clear_has_fmi2_import_initialize_model_res();
}
inline const ::fmitcp_proto::fmi2_import_initialize_model_res& fmitcp_message::fmi2_import_initialize_model_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_initialize_model_res_ != NULL ? *fmi2_import_initialize_model_res_ : *default_instance().fmi2_import_initialize_model_res_;
#else
  return fmi2_import_initialize_model_res_ != NULL ? *fmi2_import_initialize_model_res_ : *default_instance_->fmi2_import_initialize_model_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_initialize_model_res* fmitcp_message::mutable_fmi2_import_initialize_model_res() {
  set_has_fmi2_import_initialize_model_res();
  if (fmi2_import_initialize_model_res_ == NULL) fmi2_import_initialize_model_res_ = new ::fmitcp_proto::fmi2_import_initialize_model_res;
  return fmi2_import_initialize_model_res_;
}
inline ::fmitcp_proto::fmi2_import_initialize_model_res* fmitcp_message::release_fmi2_import_initialize_model_res() {
  clear_has_fmi2_import_initialize_model_res();
  ::fmitcp_proto::fmi2_import_initialize_model_res* temp = fmi2_import_initialize_model_res_;
  fmi2_import_initialize_model_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_initialize_model_res(::fmitcp_proto::fmi2_import_initialize_model_res* fmi2_import_initialize_model_res) {
  delete fmi2_import_initialize_model_res_;
  fmi2_import_initialize_model_res_ = fmi2_import_initialize_model_res;
  if (fmi2_import_initialize_model_res) {
    set_has_fmi2_import_initialize_model_res();
  } else {
    clear_has_fmi2_import_initialize_model_res();
  }
}

// optional .fmitcp_proto.fmi2_import_get_derivatives_req fmi2_import_get_derivatives_req = 42;
inline bool fmitcp_message::has_fmi2_import_get_derivatives_req() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_derivatives_req() {
  _has_bits_[1] |= 0x00000200u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_derivatives_req() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void fmitcp_message::clear_fmi2_import_get_derivatives_req() {
  if (fmi2_import_get_derivatives_req_ != NULL) fmi2_import_get_derivatives_req_->::fmitcp_proto::fmi2_import_get_derivatives_req::Clear();
  clear_has_fmi2_import_get_derivatives_req();
}
inline const ::fmitcp_proto::fmi2_import_get_derivatives_req& fmitcp_message::fmi2_import_get_derivatives_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_derivatives_req_ != NULL ? *fmi2_import_get_derivatives_req_ : *default_instance().fmi2_import_get_derivatives_req_;
#else
  return fmi2_import_get_derivatives_req_ != NULL ? *fmi2_import_get_derivatives_req_ : *default_instance_->fmi2_import_get_derivatives_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_derivatives_req* fmitcp_message::mutable_fmi2_import_get_derivatives_req() {
  set_has_fmi2_import_get_derivatives_req();
  if (fmi2_import_get_derivatives_req_ == NULL) fmi2_import_get_derivatives_req_ = new ::fmitcp_proto::fmi2_import_get_derivatives_req;
  return fmi2_import_get_derivatives_req_;
}
inline ::fmitcp_proto::fmi2_import_get_derivatives_req* fmitcp_message::release_fmi2_import_get_derivatives_req() {
  clear_has_fmi2_import_get_derivatives_req();
  ::fmitcp_proto::fmi2_import_get_derivatives_req* temp = fmi2_import_get_derivatives_req_;
  fmi2_import_get_derivatives_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_derivatives_req(::fmitcp_proto::fmi2_import_get_derivatives_req* fmi2_import_get_derivatives_req) {
  delete fmi2_import_get_derivatives_req_;
  fmi2_import_get_derivatives_req_ = fmi2_import_get_derivatives_req;
  if (fmi2_import_get_derivatives_req) {
    set_has_fmi2_import_get_derivatives_req();
  } else {
    clear_has_fmi2_import_get_derivatives_req();
  }
}

// optional .fmitcp_proto.fmi2_import_get_derivatives_res fmi2_import_get_derivatives_res = 43;
inline bool fmitcp_message::has_fmi2_import_get_derivatives_res() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_derivatives_res() {
  _has_bits_[1] |= 0x00000400u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_derivatives_res() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void fmitcp_message::clear_fmi2_import_get_derivatives_res() {
  if (fmi2_import_get_derivatives_res_ != NULL) fmi2_import_get_derivatives_res_->::fmitcp_proto::fmi2_import_get_derivatives_res::Clear();
  clear_has_fmi2_import_get_derivatives_res();
}
inline const ::fmitcp_proto::fmi2_import_get_derivatives_res& fmitcp_message::fmi2_import_get_derivatives_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_derivatives_res_ != NULL ? *fmi2_import_get_derivatives_res_ : *default_instance().fmi2_import_get_derivatives_res_;
#else
  return fmi2_import_get_derivatives_res_ != NULL ? *fmi2_import_get_derivatives_res_ : *default_instance_->fmi2_import_get_derivatives_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_derivatives_res* fmitcp_message::mutable_fmi2_import_get_derivatives_res() {
  set_has_fmi2_import_get_derivatives_res();
  if (fmi2_import_get_derivatives_res_ == NULL) fmi2_import_get_derivatives_res_ = new ::fmitcp_proto::fmi2_import_get_derivatives_res;
  return fmi2_import_get_derivatives_res_;
}
inline ::fmitcp_proto::fmi2_import_get_derivatives_res* fmitcp_message::release_fmi2_import_get_derivatives_res() {
  clear_has_fmi2_import_get_derivatives_res();
  ::fmitcp_proto::fmi2_import_get_derivatives_res* temp = fmi2_import_get_derivatives_res_;
  fmi2_import_get_derivatives_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_derivatives_res(::fmitcp_proto::fmi2_import_get_derivatives_res* fmi2_import_get_derivatives_res) {
  delete fmi2_import_get_derivatives_res_;
  fmi2_import_get_derivatives_res_ = fmi2_import_get_derivatives_res;
  if (fmi2_import_get_derivatives_res) {
    set_has_fmi2_import_get_derivatives_res();
  } else {
    clear_has_fmi2_import_get_derivatives_res();
  }
}

// optional .fmitcp_proto.fmi2_import_get_event_indicators_req fmi2_import_get_event_indicators_req = 44;
inline bool fmitcp_message::has_fmi2_import_get_event_indicators_req() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_event_indicators_req() {
  _has_bits_[1] |= 0x00000800u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_event_indicators_req() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void fmitcp_message::clear_fmi2_import_get_event_indicators_req() {
  if (fmi2_import_get_event_indicators_req_ != NULL) fmi2_import_get_event_indicators_req_->::fmitcp_proto::fmi2_import_get_event_indicators_req::Clear();
  clear_has_fmi2_import_get_event_indicators_req();
}
inline const ::fmitcp_proto::fmi2_import_get_event_indicators_req& fmitcp_message::fmi2_import_get_event_indicators_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_event_indicators_req_ != NULL ? *fmi2_import_get_event_indicators_req_ : *default_instance().fmi2_import_get_event_indicators_req_;
#else
  return fmi2_import_get_event_indicators_req_ != NULL ? *fmi2_import_get_event_indicators_req_ : *default_instance_->fmi2_import_get_event_indicators_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_event_indicators_req* fmitcp_message::mutable_fmi2_import_get_event_indicators_req() {
  set_has_fmi2_import_get_event_indicators_req();
  if (fmi2_import_get_event_indicators_req_ == NULL) fmi2_import_get_event_indicators_req_ = new ::fmitcp_proto::fmi2_import_get_event_indicators_req;
  return fmi2_import_get_event_indicators_req_;
}
inline ::fmitcp_proto::fmi2_import_get_event_indicators_req* fmitcp_message::release_fmi2_import_get_event_indicators_req() {
  clear_has_fmi2_import_get_event_indicators_req();
  ::fmitcp_proto::fmi2_import_get_event_indicators_req* temp = fmi2_import_get_event_indicators_req_;
  fmi2_import_get_event_indicators_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_event_indicators_req(::fmitcp_proto::fmi2_import_get_event_indicators_req* fmi2_import_get_event_indicators_req) {
  delete fmi2_import_get_event_indicators_req_;
  fmi2_import_get_event_indicators_req_ = fmi2_import_get_event_indicators_req;
  if (fmi2_import_get_event_indicators_req) {
    set_has_fmi2_import_get_event_indicators_req();
  } else {
    clear_has_fmi2_import_get_event_indicators_req();
  }
}

// optional .fmitcp_proto.fmi2_import_get_event_indicators_res fmi2_import_get_event_indicators_res = 45;
inline bool fmitcp_message::has_fmi2_import_get_event_indicators_res() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_event_indicators_res() {
  _has_bits_[1] |= 0x00001000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_event_indicators_res() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void fmitcp_message::clear_fmi2_import_get_event_indicators_res() {
  if (fmi2_import_get_event_indicators_res_ != NULL) fmi2_import_get_event_indicators_res_->::fmitcp_proto::fmi2_import_get_event_indicators_res::Clear();
  clear_has_fmi2_import_get_event_indicators_res();
}
inline const ::fmitcp_proto::fmi2_import_get_event_indicators_res& fmitcp_message::fmi2_import_get_event_indicators_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_event_indicators_res_ != NULL ? *fmi2_import_get_event_indicators_res_ : *default_instance().fmi2_import_get_event_indicators_res_;
#else
  return fmi2_import_get_event_indicators_res_ != NULL ? *fmi2_import_get_event_indicators_res_ : *default_instance_->fmi2_import_get_event_indicators_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_event_indicators_res* fmitcp_message::mutable_fmi2_import_get_event_indicators_res() {
  set_has_fmi2_import_get_event_indicators_res();
  if (fmi2_import_get_event_indicators_res_ == NULL) fmi2_import_get_event_indicators_res_ = new ::fmitcp_proto::fmi2_import_get_event_indicators_res;
  return fmi2_import_get_event_indicators_res_;
}
inline ::fmitcp_proto::fmi2_import_get_event_indicators_res* fmitcp_message::release_fmi2_import_get_event_indicators_res() {
  clear_has_fmi2_import_get_event_indicators_res();
  ::fmitcp_proto::fmi2_import_get_event_indicators_res* temp = fmi2_import_get_event_indicators_res_;
  fmi2_import_get_event_indicators_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_event_indicators_res(::fmitcp_proto::fmi2_import_get_event_indicators_res* fmi2_import_get_event_indicators_res) {
  delete fmi2_import_get_event_indicators_res_;
  fmi2_import_get_event_indicators_res_ = fmi2_import_get_event_indicators_res;
  if (fmi2_import_get_event_indicators_res) {
    set_has_fmi2_import_get_event_indicators_res();
  } else {
    clear_has_fmi2_import_get_event_indicators_res();
  }
}

// optional .fmitcp_proto.fmi2_import_eventUpdate_req fmi2_import_eventUpdate_req = 46;
inline bool fmitcp_message::has_fmi2_import_eventupdate_req() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_eventupdate_req() {
  _has_bits_[1] |= 0x00002000u;
}
inline void fmitcp_message::clear_has_fmi2_import_eventupdate_req() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void fmitcp_message::clear_fmi2_import_eventupdate_req() {
  if (fmi2_import_eventupdate_req_ != NULL) fmi2_import_eventupdate_req_->::fmitcp_proto::fmi2_import_eventUpdate_req::Clear();
  clear_has_fmi2_import_eventupdate_req();
}
inline const ::fmitcp_proto::fmi2_import_eventUpdate_req& fmitcp_message::fmi2_import_eventupdate_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_eventupdate_req_ != NULL ? *fmi2_import_eventupdate_req_ : *default_instance().fmi2_import_eventupdate_req_;
#else
  return fmi2_import_eventupdate_req_ != NULL ? *fmi2_import_eventupdate_req_ : *default_instance_->fmi2_import_eventupdate_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_eventUpdate_req* fmitcp_message::mutable_fmi2_import_eventupdate_req() {
  set_has_fmi2_import_eventupdate_req();
  if (fmi2_import_eventupdate_req_ == NULL) fmi2_import_eventupdate_req_ = new ::fmitcp_proto::fmi2_import_eventUpdate_req;
  return fmi2_import_eventupdate_req_;
}
inline ::fmitcp_proto::fmi2_import_eventUpdate_req* fmitcp_message::release_fmi2_import_eventupdate_req() {
  clear_has_fmi2_import_eventupdate_req();
  ::fmitcp_proto::fmi2_import_eventUpdate_req* temp = fmi2_import_eventupdate_req_;
  fmi2_import_eventupdate_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_eventupdate_req(::fmitcp_proto::fmi2_import_eventUpdate_req* fmi2_import_eventupdate_req) {
  delete fmi2_import_eventupdate_req_;
  fmi2_import_eventupdate_req_ = fmi2_import_eventupdate_req;
  if (fmi2_import_eventupdate_req) {
    set_has_fmi2_import_eventupdate_req();
  } else {
    clear_has_fmi2_import_eventupdate_req();
  }
}

// optional .fmitcp_proto.fmi2_import_eventUpdate_res fmi2_import_eventUpdate_res = 47;
inline bool fmitcp_message::has_fmi2_import_eventupdate_res() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_eventupdate_res() {
  _has_bits_[1] |= 0x00004000u;
}
inline void fmitcp_message::clear_has_fmi2_import_eventupdate_res() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void fmitcp_message::clear_fmi2_import_eventupdate_res() {
  if (fmi2_import_eventupdate_res_ != NULL) fmi2_import_eventupdate_res_->::fmitcp_proto::fmi2_import_eventUpdate_res::Clear();
  clear_has_fmi2_import_eventupdate_res();
}
inline const ::fmitcp_proto::fmi2_import_eventUpdate_res& fmitcp_message::fmi2_import_eventupdate_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_eventupdate_res_ != NULL ? *fmi2_import_eventupdate_res_ : *default_instance().fmi2_import_eventupdate_res_;
#else
  return fmi2_import_eventupdate_res_ != NULL ? *fmi2_import_eventupdate_res_ : *default_instance_->fmi2_import_eventupdate_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_eventUpdate_res* fmitcp_message::mutable_fmi2_import_eventupdate_res() {
  set_has_fmi2_import_eventupdate_res();
  if (fmi2_import_eventupdate_res_ == NULL) fmi2_import_eventupdate_res_ = new ::fmitcp_proto::fmi2_import_eventUpdate_res;
  return fmi2_import_eventupdate_res_;
}
inline ::fmitcp_proto::fmi2_import_eventUpdate_res* fmitcp_message::release_fmi2_import_eventupdate_res() {
  clear_has_fmi2_import_eventupdate_res();
  ::fmitcp_proto::fmi2_import_eventUpdate_res* temp = fmi2_import_eventupdate_res_;
  fmi2_import_eventupdate_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_eventupdate_res(::fmitcp_proto::fmi2_import_eventUpdate_res* fmi2_import_eventupdate_res) {
  delete fmi2_import_eventupdate_res_;
  fmi2_import_eventupdate_res_ = fmi2_import_eventupdate_res;
  if (fmi2_import_eventupdate_res) {
    set_has_fmi2_import_eventupdate_res();
  } else {
    clear_has_fmi2_import_eventupdate_res();
  }
}

// optional .fmitcp_proto.fmi2_import_completed_event_iteration_req fmi2_import_completed_event_iteration_req = 48;
inline bool fmitcp_message::has_fmi2_import_completed_event_iteration_req() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_completed_event_iteration_req() {
  _has_bits_[1] |= 0x00008000u;
}
inline void fmitcp_message::clear_has_fmi2_import_completed_event_iteration_req() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void fmitcp_message::clear_fmi2_import_completed_event_iteration_req() {
  if (fmi2_import_completed_event_iteration_req_ != NULL) fmi2_import_completed_event_iteration_req_->::fmitcp_proto::fmi2_import_completed_event_iteration_req::Clear();
  clear_has_fmi2_import_completed_event_iteration_req();
}
inline const ::fmitcp_proto::fmi2_import_completed_event_iteration_req& fmitcp_message::fmi2_import_completed_event_iteration_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_completed_event_iteration_req_ != NULL ? *fmi2_import_completed_event_iteration_req_ : *default_instance().fmi2_import_completed_event_iteration_req_;
#else
  return fmi2_import_completed_event_iteration_req_ != NULL ? *fmi2_import_completed_event_iteration_req_ : *default_instance_->fmi2_import_completed_event_iteration_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_completed_event_iteration_req* fmitcp_message::mutable_fmi2_import_completed_event_iteration_req() {
  set_has_fmi2_import_completed_event_iteration_req();
  if (fmi2_import_completed_event_iteration_req_ == NULL) fmi2_import_completed_event_iteration_req_ = new ::fmitcp_proto::fmi2_import_completed_event_iteration_req;
  return fmi2_import_completed_event_iteration_req_;
}
inline ::fmitcp_proto::fmi2_import_completed_event_iteration_req* fmitcp_message::release_fmi2_import_completed_event_iteration_req() {
  clear_has_fmi2_import_completed_event_iteration_req();
  ::fmitcp_proto::fmi2_import_completed_event_iteration_req* temp = fmi2_import_completed_event_iteration_req_;
  fmi2_import_completed_event_iteration_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_completed_event_iteration_req(::fmitcp_proto::fmi2_import_completed_event_iteration_req* fmi2_import_completed_event_iteration_req) {
  delete fmi2_import_completed_event_iteration_req_;
  fmi2_import_completed_event_iteration_req_ = fmi2_import_completed_event_iteration_req;
  if (fmi2_import_completed_event_iteration_req) {
    set_has_fmi2_import_completed_event_iteration_req();
  } else {
    clear_has_fmi2_import_completed_event_iteration_req();
  }
}

// optional .fmitcp_proto.fmi2_import_completed_event_iteration_res fmi2_import_completed_event_iteration_res = 49;
inline bool fmitcp_message::has_fmi2_import_completed_event_iteration_res() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_completed_event_iteration_res() {
  _has_bits_[1] |= 0x00010000u;
}
inline void fmitcp_message::clear_has_fmi2_import_completed_event_iteration_res() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void fmitcp_message::clear_fmi2_import_completed_event_iteration_res() {
  if (fmi2_import_completed_event_iteration_res_ != NULL) fmi2_import_completed_event_iteration_res_->::fmitcp_proto::fmi2_import_completed_event_iteration_res::Clear();
  clear_has_fmi2_import_completed_event_iteration_res();
}
inline const ::fmitcp_proto::fmi2_import_completed_event_iteration_res& fmitcp_message::fmi2_import_completed_event_iteration_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_completed_event_iteration_res_ != NULL ? *fmi2_import_completed_event_iteration_res_ : *default_instance().fmi2_import_completed_event_iteration_res_;
#else
  return fmi2_import_completed_event_iteration_res_ != NULL ? *fmi2_import_completed_event_iteration_res_ : *default_instance_->fmi2_import_completed_event_iteration_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_completed_event_iteration_res* fmitcp_message::mutable_fmi2_import_completed_event_iteration_res() {
  set_has_fmi2_import_completed_event_iteration_res();
  if (fmi2_import_completed_event_iteration_res_ == NULL) fmi2_import_completed_event_iteration_res_ = new ::fmitcp_proto::fmi2_import_completed_event_iteration_res;
  return fmi2_import_completed_event_iteration_res_;
}
inline ::fmitcp_proto::fmi2_import_completed_event_iteration_res* fmitcp_message::release_fmi2_import_completed_event_iteration_res() {
  clear_has_fmi2_import_completed_event_iteration_res();
  ::fmitcp_proto::fmi2_import_completed_event_iteration_res* temp = fmi2_import_completed_event_iteration_res_;
  fmi2_import_completed_event_iteration_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_completed_event_iteration_res(::fmitcp_proto::fmi2_import_completed_event_iteration_res* fmi2_import_completed_event_iteration_res) {
  delete fmi2_import_completed_event_iteration_res_;
  fmi2_import_completed_event_iteration_res_ = fmi2_import_completed_event_iteration_res;
  if (fmi2_import_completed_event_iteration_res) {
    set_has_fmi2_import_completed_event_iteration_res();
  } else {
    clear_has_fmi2_import_completed_event_iteration_res();
  }
}

// optional .fmitcp_proto.fmi2_import_get_continuous_states_req fmi2_import_get_continuous_states_req = 50;
inline bool fmitcp_message::has_fmi2_import_get_continuous_states_req() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_continuous_states_req() {
  _has_bits_[1] |= 0x00020000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_continuous_states_req() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void fmitcp_message::clear_fmi2_import_get_continuous_states_req() {
  if (fmi2_import_get_continuous_states_req_ != NULL) fmi2_import_get_continuous_states_req_->::fmitcp_proto::fmi2_import_get_continuous_states_req::Clear();
  clear_has_fmi2_import_get_continuous_states_req();
}
inline const ::fmitcp_proto::fmi2_import_get_continuous_states_req& fmitcp_message::fmi2_import_get_continuous_states_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_continuous_states_req_ != NULL ? *fmi2_import_get_continuous_states_req_ : *default_instance().fmi2_import_get_continuous_states_req_;
#else
  return fmi2_import_get_continuous_states_req_ != NULL ? *fmi2_import_get_continuous_states_req_ : *default_instance_->fmi2_import_get_continuous_states_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_continuous_states_req* fmitcp_message::mutable_fmi2_import_get_continuous_states_req() {
  set_has_fmi2_import_get_continuous_states_req();
  if (fmi2_import_get_continuous_states_req_ == NULL) fmi2_import_get_continuous_states_req_ = new ::fmitcp_proto::fmi2_import_get_continuous_states_req;
  return fmi2_import_get_continuous_states_req_;
}
inline ::fmitcp_proto::fmi2_import_get_continuous_states_req* fmitcp_message::release_fmi2_import_get_continuous_states_req() {
  clear_has_fmi2_import_get_continuous_states_req();
  ::fmitcp_proto::fmi2_import_get_continuous_states_req* temp = fmi2_import_get_continuous_states_req_;
  fmi2_import_get_continuous_states_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_continuous_states_req(::fmitcp_proto::fmi2_import_get_continuous_states_req* fmi2_import_get_continuous_states_req) {
  delete fmi2_import_get_continuous_states_req_;
  fmi2_import_get_continuous_states_req_ = fmi2_import_get_continuous_states_req;
  if (fmi2_import_get_continuous_states_req) {
    set_has_fmi2_import_get_continuous_states_req();
  } else {
    clear_has_fmi2_import_get_continuous_states_req();
  }
}

// optional .fmitcp_proto.fmi2_import_get_continuous_states_res fmi2_import_get_continuous_states_res = 51;
inline bool fmitcp_message::has_fmi2_import_get_continuous_states_res() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_continuous_states_res() {
  _has_bits_[1] |= 0x00040000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_continuous_states_res() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void fmitcp_message::clear_fmi2_import_get_continuous_states_res() {
  if (fmi2_import_get_continuous_states_res_ != NULL) fmi2_import_get_continuous_states_res_->::fmitcp_proto::fmi2_import_get_continuous_states_res::Clear();
  clear_has_fmi2_import_get_continuous_states_res();
}
inline const ::fmitcp_proto::fmi2_import_get_continuous_states_res& fmitcp_message::fmi2_import_get_continuous_states_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_continuous_states_res_ != NULL ? *fmi2_import_get_continuous_states_res_ : *default_instance().fmi2_import_get_continuous_states_res_;
#else
  return fmi2_import_get_continuous_states_res_ != NULL ? *fmi2_import_get_continuous_states_res_ : *default_instance_->fmi2_import_get_continuous_states_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_continuous_states_res* fmitcp_message::mutable_fmi2_import_get_continuous_states_res() {
  set_has_fmi2_import_get_continuous_states_res();
  if (fmi2_import_get_continuous_states_res_ == NULL) fmi2_import_get_continuous_states_res_ = new ::fmitcp_proto::fmi2_import_get_continuous_states_res;
  return fmi2_import_get_continuous_states_res_;
}
inline ::fmitcp_proto::fmi2_import_get_continuous_states_res* fmitcp_message::release_fmi2_import_get_continuous_states_res() {
  clear_has_fmi2_import_get_continuous_states_res();
  ::fmitcp_proto::fmi2_import_get_continuous_states_res* temp = fmi2_import_get_continuous_states_res_;
  fmi2_import_get_continuous_states_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_continuous_states_res(::fmitcp_proto::fmi2_import_get_continuous_states_res* fmi2_import_get_continuous_states_res) {
  delete fmi2_import_get_continuous_states_res_;
  fmi2_import_get_continuous_states_res_ = fmi2_import_get_continuous_states_res;
  if (fmi2_import_get_continuous_states_res) {
    set_has_fmi2_import_get_continuous_states_res();
  } else {
    clear_has_fmi2_import_get_continuous_states_res();
  }
}

// optional .fmitcp_proto.fmi2_import_get_nominal_continuous_states_req fmi2_import_get_nominal_continuous_states_req = 52;
inline bool fmitcp_message::has_fmi2_import_get_nominal_continuous_states_req() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_nominal_continuous_states_req() {
  _has_bits_[1] |= 0x00080000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_nominal_continuous_states_req() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void fmitcp_message::clear_fmi2_import_get_nominal_continuous_states_req() {
  if (fmi2_import_get_nominal_continuous_states_req_ != NULL) fmi2_import_get_nominal_continuous_states_req_->::fmitcp_proto::fmi2_import_get_nominal_continuous_states_req::Clear();
  clear_has_fmi2_import_get_nominal_continuous_states_req();
}
inline const ::fmitcp_proto::fmi2_import_get_nominal_continuous_states_req& fmitcp_message::fmi2_import_get_nominal_continuous_states_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_nominal_continuous_states_req_ != NULL ? *fmi2_import_get_nominal_continuous_states_req_ : *default_instance().fmi2_import_get_nominal_continuous_states_req_;
#else
  return fmi2_import_get_nominal_continuous_states_req_ != NULL ? *fmi2_import_get_nominal_continuous_states_req_ : *default_instance_->fmi2_import_get_nominal_continuous_states_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_nominal_continuous_states_req* fmitcp_message::mutable_fmi2_import_get_nominal_continuous_states_req() {
  set_has_fmi2_import_get_nominal_continuous_states_req();
  if (fmi2_import_get_nominal_continuous_states_req_ == NULL) fmi2_import_get_nominal_continuous_states_req_ = new ::fmitcp_proto::fmi2_import_get_nominal_continuous_states_req;
  return fmi2_import_get_nominal_continuous_states_req_;
}
inline ::fmitcp_proto::fmi2_import_get_nominal_continuous_states_req* fmitcp_message::release_fmi2_import_get_nominal_continuous_states_req() {
  clear_has_fmi2_import_get_nominal_continuous_states_req();
  ::fmitcp_proto::fmi2_import_get_nominal_continuous_states_req* temp = fmi2_import_get_nominal_continuous_states_req_;
  fmi2_import_get_nominal_continuous_states_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_nominal_continuous_states_req(::fmitcp_proto::fmi2_import_get_nominal_continuous_states_req* fmi2_import_get_nominal_continuous_states_req) {
  delete fmi2_import_get_nominal_continuous_states_req_;
  fmi2_import_get_nominal_continuous_states_req_ = fmi2_import_get_nominal_continuous_states_req;
  if (fmi2_import_get_nominal_continuous_states_req) {
    set_has_fmi2_import_get_nominal_continuous_states_req();
  } else {
    clear_has_fmi2_import_get_nominal_continuous_states_req();
  }
}

// optional .fmitcp_proto.fmi2_import_get_nominal_continuous_states_res fmi2_import_get_nominal_continuous_states_res = 53;
inline bool fmitcp_message::has_fmi2_import_get_nominal_continuous_states_res() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_nominal_continuous_states_res() {
  _has_bits_[1] |= 0x00100000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_nominal_continuous_states_res() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void fmitcp_message::clear_fmi2_import_get_nominal_continuous_states_res() {
  if (fmi2_import_get_nominal_continuous_states_res_ != NULL) fmi2_import_get_nominal_continuous_states_res_->::fmitcp_proto::fmi2_import_get_nominal_continuous_states_res::Clear();
  clear_has_fmi2_import_get_nominal_continuous_states_res();
}
inline const ::fmitcp_proto::fmi2_import_get_nominal_continuous_states_res& fmitcp_message::fmi2_import_get_nominal_continuous_states_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_nominal_continuous_states_res_ != NULL ? *fmi2_import_get_nominal_continuous_states_res_ : *default_instance().fmi2_import_get_nominal_continuous_states_res_;
#else
  return fmi2_import_get_nominal_continuous_states_res_ != NULL ? *fmi2_import_get_nominal_continuous_states_res_ : *default_instance_->fmi2_import_get_nominal_continuous_states_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_nominal_continuous_states_res* fmitcp_message::mutable_fmi2_import_get_nominal_continuous_states_res() {
  set_has_fmi2_import_get_nominal_continuous_states_res();
  if (fmi2_import_get_nominal_continuous_states_res_ == NULL) fmi2_import_get_nominal_continuous_states_res_ = new ::fmitcp_proto::fmi2_import_get_nominal_continuous_states_res;
  return fmi2_import_get_nominal_continuous_states_res_;
}
inline ::fmitcp_proto::fmi2_import_get_nominal_continuous_states_res* fmitcp_message::release_fmi2_import_get_nominal_continuous_states_res() {
  clear_has_fmi2_import_get_nominal_continuous_states_res();
  ::fmitcp_proto::fmi2_import_get_nominal_continuous_states_res* temp = fmi2_import_get_nominal_continuous_states_res_;
  fmi2_import_get_nominal_continuous_states_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_nominal_continuous_states_res(::fmitcp_proto::fmi2_import_get_nominal_continuous_states_res* fmi2_import_get_nominal_continuous_states_res) {
  delete fmi2_import_get_nominal_continuous_states_res_;
  fmi2_import_get_nominal_continuous_states_res_ = fmi2_import_get_nominal_continuous_states_res;
  if (fmi2_import_get_nominal_continuous_states_res) {
    set_has_fmi2_import_get_nominal_continuous_states_res();
  } else {
    clear_has_fmi2_import_get_nominal_continuous_states_res();
  }
}

// optional .fmitcp_proto.fmi2_import_terminate_req fmi2_import_terminate_req = 54;
inline bool fmitcp_message::has_fmi2_import_terminate_req() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_terminate_req() {
  _has_bits_[1] |= 0x00200000u;
}
inline void fmitcp_message::clear_has_fmi2_import_terminate_req() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void fmitcp_message::clear_fmi2_import_terminate_req() {
  if (fmi2_import_terminate_req_ != NULL) fmi2_import_terminate_req_->::fmitcp_proto::fmi2_import_terminate_req::Clear();
  clear_has_fmi2_import_terminate_req();
}
inline const ::fmitcp_proto::fmi2_import_terminate_req& fmitcp_message::fmi2_import_terminate_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_terminate_req_ != NULL ? *fmi2_import_terminate_req_ : *default_instance().fmi2_import_terminate_req_;
#else
  return fmi2_import_terminate_req_ != NULL ? *fmi2_import_terminate_req_ : *default_instance_->fmi2_import_terminate_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_terminate_req* fmitcp_message::mutable_fmi2_import_terminate_req() {
  set_has_fmi2_import_terminate_req();
  if (fmi2_import_terminate_req_ == NULL) fmi2_import_terminate_req_ = new ::fmitcp_proto::fmi2_import_terminate_req;
  return fmi2_import_terminate_req_;
}
inline ::fmitcp_proto::fmi2_import_terminate_req* fmitcp_message::release_fmi2_import_terminate_req() {
  clear_has_fmi2_import_terminate_req();
  ::fmitcp_proto::fmi2_import_terminate_req* temp = fmi2_import_terminate_req_;
  fmi2_import_terminate_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_terminate_req(::fmitcp_proto::fmi2_import_terminate_req* fmi2_import_terminate_req) {
  delete fmi2_import_terminate_req_;
  fmi2_import_terminate_req_ = fmi2_import_terminate_req;
  if (fmi2_import_terminate_req) {
    set_has_fmi2_import_terminate_req();
  } else {
    clear_has_fmi2_import_terminate_req();
  }
}

// optional .fmitcp_proto.fmi2_import_terminate_res fmi2_import_terminate_res = 55;
inline bool fmitcp_message::has_fmi2_import_terminate_res() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_terminate_res() {
  _has_bits_[1] |= 0x00400000u;
}
inline void fmitcp_message::clear_has_fmi2_import_terminate_res() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void fmitcp_message::clear_fmi2_import_terminate_res() {
  if (fmi2_import_terminate_res_ != NULL) fmi2_import_terminate_res_->::fmitcp_proto::fmi2_import_terminate_res::Clear();
  clear_has_fmi2_import_terminate_res();
}
inline const ::fmitcp_proto::fmi2_import_terminate_res& fmitcp_message::fmi2_import_terminate_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_terminate_res_ != NULL ? *fmi2_import_terminate_res_ : *default_instance().fmi2_import_terminate_res_;
#else
  return fmi2_import_terminate_res_ != NULL ? *fmi2_import_terminate_res_ : *default_instance_->fmi2_import_terminate_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_terminate_res* fmitcp_message::mutable_fmi2_import_terminate_res() {
  set_has_fmi2_import_terminate_res();
  if (fmi2_import_terminate_res_ == NULL) fmi2_import_terminate_res_ = new ::fmitcp_proto::fmi2_import_terminate_res;
  return fmi2_import_terminate_res_;
}
inline ::fmitcp_proto::fmi2_import_terminate_res* fmitcp_message::release_fmi2_import_terminate_res() {
  clear_has_fmi2_import_terminate_res();
  ::fmitcp_proto::fmi2_import_terminate_res* temp = fmi2_import_terminate_res_;
  fmi2_import_terminate_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_terminate_res(::fmitcp_proto::fmi2_import_terminate_res* fmi2_import_terminate_res) {
  delete fmi2_import_terminate_res_;
  fmi2_import_terminate_res_ = fmi2_import_terminate_res;
  if (fmi2_import_terminate_res) {
    set_has_fmi2_import_terminate_res();
  } else {
    clear_has_fmi2_import_terminate_res();
  }
}

// optional .fmitcp_proto.fmi2_import_get_version_req fmi2_import_get_version_req = 56;
inline bool fmitcp_message::has_fmi2_import_get_version_req() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_version_req() {
  _has_bits_[1] |= 0x00800000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_version_req() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void fmitcp_message::clear_fmi2_import_get_version_req() {
  if (fmi2_import_get_version_req_ != NULL) fmi2_import_get_version_req_->::fmitcp_proto::fmi2_import_get_version_req::Clear();
  clear_has_fmi2_import_get_version_req();
}
inline const ::fmitcp_proto::fmi2_import_get_version_req& fmitcp_message::fmi2_import_get_version_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_version_req_ != NULL ? *fmi2_import_get_version_req_ : *default_instance().fmi2_import_get_version_req_;
#else
  return fmi2_import_get_version_req_ != NULL ? *fmi2_import_get_version_req_ : *default_instance_->fmi2_import_get_version_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_version_req* fmitcp_message::mutable_fmi2_import_get_version_req() {
  set_has_fmi2_import_get_version_req();
  if (fmi2_import_get_version_req_ == NULL) fmi2_import_get_version_req_ = new ::fmitcp_proto::fmi2_import_get_version_req;
  return fmi2_import_get_version_req_;
}
inline ::fmitcp_proto::fmi2_import_get_version_req* fmitcp_message::release_fmi2_import_get_version_req() {
  clear_has_fmi2_import_get_version_req();
  ::fmitcp_proto::fmi2_import_get_version_req* temp = fmi2_import_get_version_req_;
  fmi2_import_get_version_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_version_req(::fmitcp_proto::fmi2_import_get_version_req* fmi2_import_get_version_req) {
  delete fmi2_import_get_version_req_;
  fmi2_import_get_version_req_ = fmi2_import_get_version_req;
  if (fmi2_import_get_version_req) {
    set_has_fmi2_import_get_version_req();
  } else {
    clear_has_fmi2_import_get_version_req();
  }
}

// optional .fmitcp_proto.fmi2_import_get_version_res fmi2_import_get_version_res = 57;
inline bool fmitcp_message::has_fmi2_import_get_version_res() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_version_res() {
  _has_bits_[1] |= 0x01000000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_version_res() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void fmitcp_message::clear_fmi2_import_get_version_res() {
  if (fmi2_import_get_version_res_ != NULL) fmi2_import_get_version_res_->::fmitcp_proto::fmi2_import_get_version_res::Clear();
  clear_has_fmi2_import_get_version_res();
}
inline const ::fmitcp_proto::fmi2_import_get_version_res& fmitcp_message::fmi2_import_get_version_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_version_res_ != NULL ? *fmi2_import_get_version_res_ : *default_instance().fmi2_import_get_version_res_;
#else
  return fmi2_import_get_version_res_ != NULL ? *fmi2_import_get_version_res_ : *default_instance_->fmi2_import_get_version_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_version_res* fmitcp_message::mutable_fmi2_import_get_version_res() {
  set_has_fmi2_import_get_version_res();
  if (fmi2_import_get_version_res_ == NULL) fmi2_import_get_version_res_ = new ::fmitcp_proto::fmi2_import_get_version_res;
  return fmi2_import_get_version_res_;
}
inline ::fmitcp_proto::fmi2_import_get_version_res* fmitcp_message::release_fmi2_import_get_version_res() {
  clear_has_fmi2_import_get_version_res();
  ::fmitcp_proto::fmi2_import_get_version_res* temp = fmi2_import_get_version_res_;
  fmi2_import_get_version_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_version_res(::fmitcp_proto::fmi2_import_get_version_res* fmi2_import_get_version_res) {
  delete fmi2_import_get_version_res_;
  fmi2_import_get_version_res_ = fmi2_import_get_version_res;
  if (fmi2_import_get_version_res) {
    set_has_fmi2_import_get_version_res();
  } else {
    clear_has_fmi2_import_get_version_res();
  }
}

// optional .fmitcp_proto.fmi2_import_set_debug_logging_req fmi2_import_set_debug_logging_req = 58;
inline bool fmitcp_message::has_fmi2_import_set_debug_logging_req() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_set_debug_logging_req() {
  _has_bits_[1] |= 0x02000000u;
}
inline void fmitcp_message::clear_has_fmi2_import_set_debug_logging_req() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void fmitcp_message::clear_fmi2_import_set_debug_logging_req() {
  if (fmi2_import_set_debug_logging_req_ != NULL) fmi2_import_set_debug_logging_req_->::fmitcp_proto::fmi2_import_set_debug_logging_req::Clear();
  clear_has_fmi2_import_set_debug_logging_req();
}
inline const ::fmitcp_proto::fmi2_import_set_debug_logging_req& fmitcp_message::fmi2_import_set_debug_logging_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_set_debug_logging_req_ != NULL ? *fmi2_import_set_debug_logging_req_ : *default_instance().fmi2_import_set_debug_logging_req_;
#else
  return fmi2_import_set_debug_logging_req_ != NULL ? *fmi2_import_set_debug_logging_req_ : *default_instance_->fmi2_import_set_debug_logging_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_set_debug_logging_req* fmitcp_message::mutable_fmi2_import_set_debug_logging_req() {
  set_has_fmi2_import_set_debug_logging_req();
  if (fmi2_import_set_debug_logging_req_ == NULL) fmi2_import_set_debug_logging_req_ = new ::fmitcp_proto::fmi2_import_set_debug_logging_req;
  return fmi2_import_set_debug_logging_req_;
}
inline ::fmitcp_proto::fmi2_import_set_debug_logging_req* fmitcp_message::release_fmi2_import_set_debug_logging_req() {
  clear_has_fmi2_import_set_debug_logging_req();
  ::fmitcp_proto::fmi2_import_set_debug_logging_req* temp = fmi2_import_set_debug_logging_req_;
  fmi2_import_set_debug_logging_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_set_debug_logging_req(::fmitcp_proto::fmi2_import_set_debug_logging_req* fmi2_import_set_debug_logging_req) {
  delete fmi2_import_set_debug_logging_req_;
  fmi2_import_set_debug_logging_req_ = fmi2_import_set_debug_logging_req;
  if (fmi2_import_set_debug_logging_req) {
    set_has_fmi2_import_set_debug_logging_req();
  } else {
    clear_has_fmi2_import_set_debug_logging_req();
  }
}

// optional .fmitcp_proto.fmi2_import_set_debug_logging_res fmi2_import_set_debug_logging_res = 59;
inline bool fmitcp_message::has_fmi2_import_set_debug_logging_res() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_set_debug_logging_res() {
  _has_bits_[1] |= 0x04000000u;
}
inline void fmitcp_message::clear_has_fmi2_import_set_debug_logging_res() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void fmitcp_message::clear_fmi2_import_set_debug_logging_res() {
  if (fmi2_import_set_debug_logging_res_ != NULL) fmi2_import_set_debug_logging_res_->::fmitcp_proto::fmi2_import_set_debug_logging_res::Clear();
  clear_has_fmi2_import_set_debug_logging_res();
}
inline const ::fmitcp_proto::fmi2_import_set_debug_logging_res& fmitcp_message::fmi2_import_set_debug_logging_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_set_debug_logging_res_ != NULL ? *fmi2_import_set_debug_logging_res_ : *default_instance().fmi2_import_set_debug_logging_res_;
#else
  return fmi2_import_set_debug_logging_res_ != NULL ? *fmi2_import_set_debug_logging_res_ : *default_instance_->fmi2_import_set_debug_logging_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_set_debug_logging_res* fmitcp_message::mutable_fmi2_import_set_debug_logging_res() {
  set_has_fmi2_import_set_debug_logging_res();
  if (fmi2_import_set_debug_logging_res_ == NULL) fmi2_import_set_debug_logging_res_ = new ::fmitcp_proto::fmi2_import_set_debug_logging_res;
  return fmi2_import_set_debug_logging_res_;
}
inline ::fmitcp_proto::fmi2_import_set_debug_logging_res* fmitcp_message::release_fmi2_import_set_debug_logging_res() {
  clear_has_fmi2_import_set_debug_logging_res();
  ::fmitcp_proto::fmi2_import_set_debug_logging_res* temp = fmi2_import_set_debug_logging_res_;
  fmi2_import_set_debug_logging_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_set_debug_logging_res(::fmitcp_proto::fmi2_import_set_debug_logging_res* fmi2_import_set_debug_logging_res) {
  delete fmi2_import_set_debug_logging_res_;
  fmi2_import_set_debug_logging_res_ = fmi2_import_set_debug_logging_res;
  if (fmi2_import_set_debug_logging_res) {
    set_has_fmi2_import_set_debug_logging_res();
  } else {
    clear_has_fmi2_import_set_debug_logging_res();
  }
}

// optional .fmitcp_proto.fmi2_import_set_real_req fmi2_import_set_real_req = 60;
inline bool fmitcp_message::has_fmi2_import_set_real_req() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_set_real_req() {
  _has_bits_[1] |= 0x08000000u;
}
inline void fmitcp_message::clear_has_fmi2_import_set_real_req() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void fmitcp_message::clear_fmi2_import_set_real_req() {
  if (fmi2_import_set_real_req_ != NULL) fmi2_import_set_real_req_->::fmitcp_proto::fmi2_import_set_real_req::Clear();
  clear_has_fmi2_import_set_real_req();
}
inline const ::fmitcp_proto::fmi2_import_set_real_req& fmitcp_message::fmi2_import_set_real_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_set_real_req_ != NULL ? *fmi2_import_set_real_req_ : *default_instance().fmi2_import_set_real_req_;
#else
  return fmi2_import_set_real_req_ != NULL ? *fmi2_import_set_real_req_ : *default_instance_->fmi2_import_set_real_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_set_real_req* fmitcp_message::mutable_fmi2_import_set_real_req() {
  set_has_fmi2_import_set_real_req();
  if (fmi2_import_set_real_req_ == NULL) fmi2_import_set_real_req_ = new ::fmitcp_proto::fmi2_import_set_real_req;
  return fmi2_import_set_real_req_;
}
inline ::fmitcp_proto::fmi2_import_set_real_req* fmitcp_message::release_fmi2_import_set_real_req() {
  clear_has_fmi2_import_set_real_req();
  ::fmitcp_proto::fmi2_import_set_real_req* temp = fmi2_import_set_real_req_;
  fmi2_import_set_real_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_set_real_req(::fmitcp_proto::fmi2_import_set_real_req* fmi2_import_set_real_req) {
  delete fmi2_import_set_real_req_;
  fmi2_import_set_real_req_ = fmi2_import_set_real_req;
  if (fmi2_import_set_real_req) {
    set_has_fmi2_import_set_real_req();
  } else {
    clear_has_fmi2_import_set_real_req();
  }
}

// optional .fmitcp_proto.fmi2_import_set_real_res fmi2_import_set_real_res = 61;
inline bool fmitcp_message::has_fmi2_import_set_real_res() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_set_real_res() {
  _has_bits_[1] |= 0x10000000u;
}
inline void fmitcp_message::clear_has_fmi2_import_set_real_res() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void fmitcp_message::clear_fmi2_import_set_real_res() {
  if (fmi2_import_set_real_res_ != NULL) fmi2_import_set_real_res_->::fmitcp_proto::fmi2_import_set_real_res::Clear();
  clear_has_fmi2_import_set_real_res();
}
inline const ::fmitcp_proto::fmi2_import_set_real_res& fmitcp_message::fmi2_import_set_real_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_set_real_res_ != NULL ? *fmi2_import_set_real_res_ : *default_instance().fmi2_import_set_real_res_;
#else
  return fmi2_import_set_real_res_ != NULL ? *fmi2_import_set_real_res_ : *default_instance_->fmi2_import_set_real_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_set_real_res* fmitcp_message::mutable_fmi2_import_set_real_res() {
  set_has_fmi2_import_set_real_res();
  if (fmi2_import_set_real_res_ == NULL) fmi2_import_set_real_res_ = new ::fmitcp_proto::fmi2_import_set_real_res;
  return fmi2_import_set_real_res_;
}
inline ::fmitcp_proto::fmi2_import_set_real_res* fmitcp_message::release_fmi2_import_set_real_res() {
  clear_has_fmi2_import_set_real_res();
  ::fmitcp_proto::fmi2_import_set_real_res* temp = fmi2_import_set_real_res_;
  fmi2_import_set_real_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_set_real_res(::fmitcp_proto::fmi2_import_set_real_res* fmi2_import_set_real_res) {
  delete fmi2_import_set_real_res_;
  fmi2_import_set_real_res_ = fmi2_import_set_real_res;
  if (fmi2_import_set_real_res) {
    set_has_fmi2_import_set_real_res();
  } else {
    clear_has_fmi2_import_set_real_res();
  }
}

// optional .fmitcp_proto.fmi2_import_set_integer_req fmi2_import_set_integer_req = 62;
inline bool fmitcp_message::has_fmi2_import_set_integer_req() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_set_integer_req() {
  _has_bits_[1] |= 0x20000000u;
}
inline void fmitcp_message::clear_has_fmi2_import_set_integer_req() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void fmitcp_message::clear_fmi2_import_set_integer_req() {
  if (fmi2_import_set_integer_req_ != NULL) fmi2_import_set_integer_req_->::fmitcp_proto::fmi2_import_set_integer_req::Clear();
  clear_has_fmi2_import_set_integer_req();
}
inline const ::fmitcp_proto::fmi2_import_set_integer_req& fmitcp_message::fmi2_import_set_integer_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_set_integer_req_ != NULL ? *fmi2_import_set_integer_req_ : *default_instance().fmi2_import_set_integer_req_;
#else
  return fmi2_import_set_integer_req_ != NULL ? *fmi2_import_set_integer_req_ : *default_instance_->fmi2_import_set_integer_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_set_integer_req* fmitcp_message::mutable_fmi2_import_set_integer_req() {
  set_has_fmi2_import_set_integer_req();
  if (fmi2_import_set_integer_req_ == NULL) fmi2_import_set_integer_req_ = new ::fmitcp_proto::fmi2_import_set_integer_req;
  return fmi2_import_set_integer_req_;
}
inline ::fmitcp_proto::fmi2_import_set_integer_req* fmitcp_message::release_fmi2_import_set_integer_req() {
  clear_has_fmi2_import_set_integer_req();
  ::fmitcp_proto::fmi2_import_set_integer_req* temp = fmi2_import_set_integer_req_;
  fmi2_import_set_integer_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_set_integer_req(::fmitcp_proto::fmi2_import_set_integer_req* fmi2_import_set_integer_req) {
  delete fmi2_import_set_integer_req_;
  fmi2_import_set_integer_req_ = fmi2_import_set_integer_req;
  if (fmi2_import_set_integer_req) {
    set_has_fmi2_import_set_integer_req();
  } else {
    clear_has_fmi2_import_set_integer_req();
  }
}

// optional .fmitcp_proto.fmi2_import_set_integer_res fmi2_import_set_integer_res = 63;
inline bool fmitcp_message::has_fmi2_import_set_integer_res() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_set_integer_res() {
  _has_bits_[1] |= 0x40000000u;
}
inline void fmitcp_message::clear_has_fmi2_import_set_integer_res() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void fmitcp_message::clear_fmi2_import_set_integer_res() {
  if (fmi2_import_set_integer_res_ != NULL) fmi2_import_set_integer_res_->::fmitcp_proto::fmi2_import_set_integer_res::Clear();
  clear_has_fmi2_import_set_integer_res();
}
inline const ::fmitcp_proto::fmi2_import_set_integer_res& fmitcp_message::fmi2_import_set_integer_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_set_integer_res_ != NULL ? *fmi2_import_set_integer_res_ : *default_instance().fmi2_import_set_integer_res_;
#else
  return fmi2_import_set_integer_res_ != NULL ? *fmi2_import_set_integer_res_ : *default_instance_->fmi2_import_set_integer_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_set_integer_res* fmitcp_message::mutable_fmi2_import_set_integer_res() {
  set_has_fmi2_import_set_integer_res();
  if (fmi2_import_set_integer_res_ == NULL) fmi2_import_set_integer_res_ = new ::fmitcp_proto::fmi2_import_set_integer_res;
  return fmi2_import_set_integer_res_;
}
inline ::fmitcp_proto::fmi2_import_set_integer_res* fmitcp_message::release_fmi2_import_set_integer_res() {
  clear_has_fmi2_import_set_integer_res();
  ::fmitcp_proto::fmi2_import_set_integer_res* temp = fmi2_import_set_integer_res_;
  fmi2_import_set_integer_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_set_integer_res(::fmitcp_proto::fmi2_import_set_integer_res* fmi2_import_set_integer_res) {
  delete fmi2_import_set_integer_res_;
  fmi2_import_set_integer_res_ = fmi2_import_set_integer_res;
  if (fmi2_import_set_integer_res) {
    set_has_fmi2_import_set_integer_res();
  } else {
    clear_has_fmi2_import_set_integer_res();
  }
}

// optional .fmitcp_proto.fmi2_import_set_boolean_req fmi2_import_set_boolean_req = 64;
inline bool fmitcp_message::has_fmi2_import_set_boolean_req() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_set_boolean_req() {
  _has_bits_[1] |= 0x80000000u;
}
inline void fmitcp_message::clear_has_fmi2_import_set_boolean_req() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void fmitcp_message::clear_fmi2_import_set_boolean_req() {
  if (fmi2_import_set_boolean_req_ != NULL) fmi2_import_set_boolean_req_->::fmitcp_proto::fmi2_import_set_boolean_req::Clear();
  clear_has_fmi2_import_set_boolean_req();
}
inline const ::fmitcp_proto::fmi2_import_set_boolean_req& fmitcp_message::fmi2_import_set_boolean_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_set_boolean_req_ != NULL ? *fmi2_import_set_boolean_req_ : *default_instance().fmi2_import_set_boolean_req_;
#else
  return fmi2_import_set_boolean_req_ != NULL ? *fmi2_import_set_boolean_req_ : *default_instance_->fmi2_import_set_boolean_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_set_boolean_req* fmitcp_message::mutable_fmi2_import_set_boolean_req() {
  set_has_fmi2_import_set_boolean_req();
  if (fmi2_import_set_boolean_req_ == NULL) fmi2_import_set_boolean_req_ = new ::fmitcp_proto::fmi2_import_set_boolean_req;
  return fmi2_import_set_boolean_req_;
}
inline ::fmitcp_proto::fmi2_import_set_boolean_req* fmitcp_message::release_fmi2_import_set_boolean_req() {
  clear_has_fmi2_import_set_boolean_req();
  ::fmitcp_proto::fmi2_import_set_boolean_req* temp = fmi2_import_set_boolean_req_;
  fmi2_import_set_boolean_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_set_boolean_req(::fmitcp_proto::fmi2_import_set_boolean_req* fmi2_import_set_boolean_req) {
  delete fmi2_import_set_boolean_req_;
  fmi2_import_set_boolean_req_ = fmi2_import_set_boolean_req;
  if (fmi2_import_set_boolean_req) {
    set_has_fmi2_import_set_boolean_req();
  } else {
    clear_has_fmi2_import_set_boolean_req();
  }
}

// optional .fmitcp_proto.fmi2_import_set_boolean_res fmi2_import_set_boolean_res = 65;
inline bool fmitcp_message::has_fmi2_import_set_boolean_res() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_set_boolean_res() {
  _has_bits_[2] |= 0x00000001u;
}
inline void fmitcp_message::clear_has_fmi2_import_set_boolean_res() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void fmitcp_message::clear_fmi2_import_set_boolean_res() {
  if (fmi2_import_set_boolean_res_ != NULL) fmi2_import_set_boolean_res_->::fmitcp_proto::fmi2_import_set_boolean_res::Clear();
  clear_has_fmi2_import_set_boolean_res();
}
inline const ::fmitcp_proto::fmi2_import_set_boolean_res& fmitcp_message::fmi2_import_set_boolean_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_set_boolean_res_ != NULL ? *fmi2_import_set_boolean_res_ : *default_instance().fmi2_import_set_boolean_res_;
#else
  return fmi2_import_set_boolean_res_ != NULL ? *fmi2_import_set_boolean_res_ : *default_instance_->fmi2_import_set_boolean_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_set_boolean_res* fmitcp_message::mutable_fmi2_import_set_boolean_res() {
  set_has_fmi2_import_set_boolean_res();
  if (fmi2_import_set_boolean_res_ == NULL) fmi2_import_set_boolean_res_ = new ::fmitcp_proto::fmi2_import_set_boolean_res;
  return fmi2_import_set_boolean_res_;
}
inline ::fmitcp_proto::fmi2_import_set_boolean_res* fmitcp_message::release_fmi2_import_set_boolean_res() {
  clear_has_fmi2_import_set_boolean_res();
  ::fmitcp_proto::fmi2_import_set_boolean_res* temp = fmi2_import_set_boolean_res_;
  fmi2_import_set_boolean_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_set_boolean_res(::fmitcp_proto::fmi2_import_set_boolean_res* fmi2_import_set_boolean_res) {
  delete fmi2_import_set_boolean_res_;
  fmi2_import_set_boolean_res_ = fmi2_import_set_boolean_res;
  if (fmi2_import_set_boolean_res) {
    set_has_fmi2_import_set_boolean_res();
  } else {
    clear_has_fmi2_import_set_boolean_res();
  }
}

// optional .fmitcp_proto.fmi2_import_set_string_req fmi2_import_set_string_req = 66;
inline bool fmitcp_message::has_fmi2_import_set_string_req() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_set_string_req() {
  _has_bits_[2] |= 0x00000002u;
}
inline void fmitcp_message::clear_has_fmi2_import_set_string_req() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void fmitcp_message::clear_fmi2_import_set_string_req() {
  if (fmi2_import_set_string_req_ != NULL) fmi2_import_set_string_req_->::fmitcp_proto::fmi2_import_set_string_req::Clear();
  clear_has_fmi2_import_set_string_req();
}
inline const ::fmitcp_proto::fmi2_import_set_string_req& fmitcp_message::fmi2_import_set_string_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_set_string_req_ != NULL ? *fmi2_import_set_string_req_ : *default_instance().fmi2_import_set_string_req_;
#else
  return fmi2_import_set_string_req_ != NULL ? *fmi2_import_set_string_req_ : *default_instance_->fmi2_import_set_string_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_set_string_req* fmitcp_message::mutable_fmi2_import_set_string_req() {
  set_has_fmi2_import_set_string_req();
  if (fmi2_import_set_string_req_ == NULL) fmi2_import_set_string_req_ = new ::fmitcp_proto::fmi2_import_set_string_req;
  return fmi2_import_set_string_req_;
}
inline ::fmitcp_proto::fmi2_import_set_string_req* fmitcp_message::release_fmi2_import_set_string_req() {
  clear_has_fmi2_import_set_string_req();
  ::fmitcp_proto::fmi2_import_set_string_req* temp = fmi2_import_set_string_req_;
  fmi2_import_set_string_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_set_string_req(::fmitcp_proto::fmi2_import_set_string_req* fmi2_import_set_string_req) {
  delete fmi2_import_set_string_req_;
  fmi2_import_set_string_req_ = fmi2_import_set_string_req;
  if (fmi2_import_set_string_req) {
    set_has_fmi2_import_set_string_req();
  } else {
    clear_has_fmi2_import_set_string_req();
  }
}

// optional .fmitcp_proto.fmi2_import_set_string_res fmi2_import_set_string_res = 67;
inline bool fmitcp_message::has_fmi2_import_set_string_res() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_set_string_res() {
  _has_bits_[2] |= 0x00000004u;
}
inline void fmitcp_message::clear_has_fmi2_import_set_string_res() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void fmitcp_message::clear_fmi2_import_set_string_res() {
  if (fmi2_import_set_string_res_ != NULL) fmi2_import_set_string_res_->::fmitcp_proto::fmi2_import_set_string_res::Clear();
  clear_has_fmi2_import_set_string_res();
}
inline const ::fmitcp_proto::fmi2_import_set_string_res& fmitcp_message::fmi2_import_set_string_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_set_string_res_ != NULL ? *fmi2_import_set_string_res_ : *default_instance().fmi2_import_set_string_res_;
#else
  return fmi2_import_set_string_res_ != NULL ? *fmi2_import_set_string_res_ : *default_instance_->fmi2_import_set_string_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_set_string_res* fmitcp_message::mutable_fmi2_import_set_string_res() {
  set_has_fmi2_import_set_string_res();
  if (fmi2_import_set_string_res_ == NULL) fmi2_import_set_string_res_ = new ::fmitcp_proto::fmi2_import_set_string_res;
  return fmi2_import_set_string_res_;
}
inline ::fmitcp_proto::fmi2_import_set_string_res* fmitcp_message::release_fmi2_import_set_string_res() {
  clear_has_fmi2_import_set_string_res();
  ::fmitcp_proto::fmi2_import_set_string_res* temp = fmi2_import_set_string_res_;
  fmi2_import_set_string_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_set_string_res(::fmitcp_proto::fmi2_import_set_string_res* fmi2_import_set_string_res) {
  delete fmi2_import_set_string_res_;
  fmi2_import_set_string_res_ = fmi2_import_set_string_res;
  if (fmi2_import_set_string_res) {
    set_has_fmi2_import_set_string_res();
  } else {
    clear_has_fmi2_import_set_string_res();
  }
}

// optional .fmitcp_proto.fmi2_import_get_real_req fmi2_import_get_real_req = 68;
inline bool fmitcp_message::has_fmi2_import_get_real_req() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_real_req() {
  _has_bits_[2] |= 0x00000008u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_real_req() {
  _has_bits_[2] &= ~0x00000008u;
}
inline void fmitcp_message::clear_fmi2_import_get_real_req() {
  if (fmi2_import_get_real_req_ != NULL) fmi2_import_get_real_req_->::fmitcp_proto::fmi2_import_get_real_req::Clear();
  clear_has_fmi2_import_get_real_req();
}
inline const ::fmitcp_proto::fmi2_import_get_real_req& fmitcp_message::fmi2_import_get_real_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_real_req_ != NULL ? *fmi2_import_get_real_req_ : *default_instance().fmi2_import_get_real_req_;
#else
  return fmi2_import_get_real_req_ != NULL ? *fmi2_import_get_real_req_ : *default_instance_->fmi2_import_get_real_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_real_req* fmitcp_message::mutable_fmi2_import_get_real_req() {
  set_has_fmi2_import_get_real_req();
  if (fmi2_import_get_real_req_ == NULL) fmi2_import_get_real_req_ = new ::fmitcp_proto::fmi2_import_get_real_req;
  return fmi2_import_get_real_req_;
}
inline ::fmitcp_proto::fmi2_import_get_real_req* fmitcp_message::release_fmi2_import_get_real_req() {
  clear_has_fmi2_import_get_real_req();
  ::fmitcp_proto::fmi2_import_get_real_req* temp = fmi2_import_get_real_req_;
  fmi2_import_get_real_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_real_req(::fmitcp_proto::fmi2_import_get_real_req* fmi2_import_get_real_req) {
  delete fmi2_import_get_real_req_;
  fmi2_import_get_real_req_ = fmi2_import_get_real_req;
  if (fmi2_import_get_real_req) {
    set_has_fmi2_import_get_real_req();
  } else {
    clear_has_fmi2_import_get_real_req();
  }
}

// optional .fmitcp_proto.fmi2_import_get_real_res fmi2_import_get_real_res = 69;
inline bool fmitcp_message::has_fmi2_import_get_real_res() const {
  return (_has_bits_[2] & 0x00000010u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_real_res() {
  _has_bits_[2] |= 0x00000010u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_real_res() {
  _has_bits_[2] &= ~0x00000010u;
}
inline void fmitcp_message::clear_fmi2_import_get_real_res() {
  if (fmi2_import_get_real_res_ != NULL) fmi2_import_get_real_res_->::fmitcp_proto::fmi2_import_get_real_res::Clear();
  clear_has_fmi2_import_get_real_res();
}
inline const ::fmitcp_proto::fmi2_import_get_real_res& fmitcp_message::fmi2_import_get_real_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_real_res_ != NULL ? *fmi2_import_get_real_res_ : *default_instance().fmi2_import_get_real_res_;
#else
  return fmi2_import_get_real_res_ != NULL ? *fmi2_import_get_real_res_ : *default_instance_->fmi2_import_get_real_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_real_res* fmitcp_message::mutable_fmi2_import_get_real_res() {
  set_has_fmi2_import_get_real_res();
  if (fmi2_import_get_real_res_ == NULL) fmi2_import_get_real_res_ = new ::fmitcp_proto::fmi2_import_get_real_res;
  return fmi2_import_get_real_res_;
}
inline ::fmitcp_proto::fmi2_import_get_real_res* fmitcp_message::release_fmi2_import_get_real_res() {
  clear_has_fmi2_import_get_real_res();
  ::fmitcp_proto::fmi2_import_get_real_res* temp = fmi2_import_get_real_res_;
  fmi2_import_get_real_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_real_res(::fmitcp_proto::fmi2_import_get_real_res* fmi2_import_get_real_res) {
  delete fmi2_import_get_real_res_;
  fmi2_import_get_real_res_ = fmi2_import_get_real_res;
  if (fmi2_import_get_real_res) {
    set_has_fmi2_import_get_real_res();
  } else {
    clear_has_fmi2_import_get_real_res();
  }
}

// optional .fmitcp_proto.fmi2_import_get_integer_req fmi2_import_get_integer_req = 70;
inline bool fmitcp_message::has_fmi2_import_get_integer_req() const {
  return (_has_bits_[2] & 0x00000020u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_integer_req() {
  _has_bits_[2] |= 0x00000020u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_integer_req() {
  _has_bits_[2] &= ~0x00000020u;
}
inline void fmitcp_message::clear_fmi2_import_get_integer_req() {
  if (fmi2_import_get_integer_req_ != NULL) fmi2_import_get_integer_req_->::fmitcp_proto::fmi2_import_get_integer_req::Clear();
  clear_has_fmi2_import_get_integer_req();
}
inline const ::fmitcp_proto::fmi2_import_get_integer_req& fmitcp_message::fmi2_import_get_integer_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_integer_req_ != NULL ? *fmi2_import_get_integer_req_ : *default_instance().fmi2_import_get_integer_req_;
#else
  return fmi2_import_get_integer_req_ != NULL ? *fmi2_import_get_integer_req_ : *default_instance_->fmi2_import_get_integer_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_integer_req* fmitcp_message::mutable_fmi2_import_get_integer_req() {
  set_has_fmi2_import_get_integer_req();
  if (fmi2_import_get_integer_req_ == NULL) fmi2_import_get_integer_req_ = new ::fmitcp_proto::fmi2_import_get_integer_req;
  return fmi2_import_get_integer_req_;
}
inline ::fmitcp_proto::fmi2_import_get_integer_req* fmitcp_message::release_fmi2_import_get_integer_req() {
  clear_has_fmi2_import_get_integer_req();
  ::fmitcp_proto::fmi2_import_get_integer_req* temp = fmi2_import_get_integer_req_;
  fmi2_import_get_integer_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_integer_req(::fmitcp_proto::fmi2_import_get_integer_req* fmi2_import_get_integer_req) {
  delete fmi2_import_get_integer_req_;
  fmi2_import_get_integer_req_ = fmi2_import_get_integer_req;
  if (fmi2_import_get_integer_req) {
    set_has_fmi2_import_get_integer_req();
  } else {
    clear_has_fmi2_import_get_integer_req();
  }
}

// optional .fmitcp_proto.fmi2_import_get_integer_res fmi2_import_get_integer_res = 71;
inline bool fmitcp_message::has_fmi2_import_get_integer_res() const {
  return (_has_bits_[2] & 0x00000040u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_integer_res() {
  _has_bits_[2] |= 0x00000040u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_integer_res() {
  _has_bits_[2] &= ~0x00000040u;
}
inline void fmitcp_message::clear_fmi2_import_get_integer_res() {
  if (fmi2_import_get_integer_res_ != NULL) fmi2_import_get_integer_res_->::fmitcp_proto::fmi2_import_get_integer_res::Clear();
  clear_has_fmi2_import_get_integer_res();
}
inline const ::fmitcp_proto::fmi2_import_get_integer_res& fmitcp_message::fmi2_import_get_integer_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_integer_res_ != NULL ? *fmi2_import_get_integer_res_ : *default_instance().fmi2_import_get_integer_res_;
#else
  return fmi2_import_get_integer_res_ != NULL ? *fmi2_import_get_integer_res_ : *default_instance_->fmi2_import_get_integer_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_integer_res* fmitcp_message::mutable_fmi2_import_get_integer_res() {
  set_has_fmi2_import_get_integer_res();
  if (fmi2_import_get_integer_res_ == NULL) fmi2_import_get_integer_res_ = new ::fmitcp_proto::fmi2_import_get_integer_res;
  return fmi2_import_get_integer_res_;
}
inline ::fmitcp_proto::fmi2_import_get_integer_res* fmitcp_message::release_fmi2_import_get_integer_res() {
  clear_has_fmi2_import_get_integer_res();
  ::fmitcp_proto::fmi2_import_get_integer_res* temp = fmi2_import_get_integer_res_;
  fmi2_import_get_integer_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_integer_res(::fmitcp_proto::fmi2_import_get_integer_res* fmi2_import_get_integer_res) {
  delete fmi2_import_get_integer_res_;
  fmi2_import_get_integer_res_ = fmi2_import_get_integer_res;
  if (fmi2_import_get_integer_res) {
    set_has_fmi2_import_get_integer_res();
  } else {
    clear_has_fmi2_import_get_integer_res();
  }
}

// optional .fmitcp_proto.fmi2_import_get_boolean_req fmi2_import_get_boolean_req = 72;
inline bool fmitcp_message::has_fmi2_import_get_boolean_req() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_boolean_req() {
  _has_bits_[2] |= 0x00000080u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_boolean_req() {
  _has_bits_[2] &= ~0x00000080u;
}
inline void fmitcp_message::clear_fmi2_import_get_boolean_req() {
  if (fmi2_import_get_boolean_req_ != NULL) fmi2_import_get_boolean_req_->::fmitcp_proto::fmi2_import_get_boolean_req::Clear();
  clear_has_fmi2_import_get_boolean_req();
}
inline const ::fmitcp_proto::fmi2_import_get_boolean_req& fmitcp_message::fmi2_import_get_boolean_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_boolean_req_ != NULL ? *fmi2_import_get_boolean_req_ : *default_instance().fmi2_import_get_boolean_req_;
#else
  return fmi2_import_get_boolean_req_ != NULL ? *fmi2_import_get_boolean_req_ : *default_instance_->fmi2_import_get_boolean_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_boolean_req* fmitcp_message::mutable_fmi2_import_get_boolean_req() {
  set_has_fmi2_import_get_boolean_req();
  if (fmi2_import_get_boolean_req_ == NULL) fmi2_import_get_boolean_req_ = new ::fmitcp_proto::fmi2_import_get_boolean_req;
  return fmi2_import_get_boolean_req_;
}
inline ::fmitcp_proto::fmi2_import_get_boolean_req* fmitcp_message::release_fmi2_import_get_boolean_req() {
  clear_has_fmi2_import_get_boolean_req();
  ::fmitcp_proto::fmi2_import_get_boolean_req* temp = fmi2_import_get_boolean_req_;
  fmi2_import_get_boolean_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_boolean_req(::fmitcp_proto::fmi2_import_get_boolean_req* fmi2_import_get_boolean_req) {
  delete fmi2_import_get_boolean_req_;
  fmi2_import_get_boolean_req_ = fmi2_import_get_boolean_req;
  if (fmi2_import_get_boolean_req) {
    set_has_fmi2_import_get_boolean_req();
  } else {
    clear_has_fmi2_import_get_boolean_req();
  }
}

// optional .fmitcp_proto.fmi2_import_get_boolean_res fmi2_import_get_boolean_res = 73;
inline bool fmitcp_message::has_fmi2_import_get_boolean_res() const {
  return (_has_bits_[2] & 0x00000100u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_boolean_res() {
  _has_bits_[2] |= 0x00000100u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_boolean_res() {
  _has_bits_[2] &= ~0x00000100u;
}
inline void fmitcp_message::clear_fmi2_import_get_boolean_res() {
  if (fmi2_import_get_boolean_res_ != NULL) fmi2_import_get_boolean_res_->::fmitcp_proto::fmi2_import_get_boolean_res::Clear();
  clear_has_fmi2_import_get_boolean_res();
}
inline const ::fmitcp_proto::fmi2_import_get_boolean_res& fmitcp_message::fmi2_import_get_boolean_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_boolean_res_ != NULL ? *fmi2_import_get_boolean_res_ : *default_instance().fmi2_import_get_boolean_res_;
#else
  return fmi2_import_get_boolean_res_ != NULL ? *fmi2_import_get_boolean_res_ : *default_instance_->fmi2_import_get_boolean_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_boolean_res* fmitcp_message::mutable_fmi2_import_get_boolean_res() {
  set_has_fmi2_import_get_boolean_res();
  if (fmi2_import_get_boolean_res_ == NULL) fmi2_import_get_boolean_res_ = new ::fmitcp_proto::fmi2_import_get_boolean_res;
  return fmi2_import_get_boolean_res_;
}
inline ::fmitcp_proto::fmi2_import_get_boolean_res* fmitcp_message::release_fmi2_import_get_boolean_res() {
  clear_has_fmi2_import_get_boolean_res();
  ::fmitcp_proto::fmi2_import_get_boolean_res* temp = fmi2_import_get_boolean_res_;
  fmi2_import_get_boolean_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_boolean_res(::fmitcp_proto::fmi2_import_get_boolean_res* fmi2_import_get_boolean_res) {
  delete fmi2_import_get_boolean_res_;
  fmi2_import_get_boolean_res_ = fmi2_import_get_boolean_res;
  if (fmi2_import_get_boolean_res) {
    set_has_fmi2_import_get_boolean_res();
  } else {
    clear_has_fmi2_import_get_boolean_res();
  }
}

// optional .fmitcp_proto.fmi2_import_get_string_req fmi2_import_get_string_req = 74;
inline bool fmitcp_message::has_fmi2_import_get_string_req() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_string_req() {
  _has_bits_[2] |= 0x00000200u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_string_req() {
  _has_bits_[2] &= ~0x00000200u;
}
inline void fmitcp_message::clear_fmi2_import_get_string_req() {
  if (fmi2_import_get_string_req_ != NULL) fmi2_import_get_string_req_->::fmitcp_proto::fmi2_import_get_string_req::Clear();
  clear_has_fmi2_import_get_string_req();
}
inline const ::fmitcp_proto::fmi2_import_get_string_req& fmitcp_message::fmi2_import_get_string_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_string_req_ != NULL ? *fmi2_import_get_string_req_ : *default_instance().fmi2_import_get_string_req_;
#else
  return fmi2_import_get_string_req_ != NULL ? *fmi2_import_get_string_req_ : *default_instance_->fmi2_import_get_string_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_string_req* fmitcp_message::mutable_fmi2_import_get_string_req() {
  set_has_fmi2_import_get_string_req();
  if (fmi2_import_get_string_req_ == NULL) fmi2_import_get_string_req_ = new ::fmitcp_proto::fmi2_import_get_string_req;
  return fmi2_import_get_string_req_;
}
inline ::fmitcp_proto::fmi2_import_get_string_req* fmitcp_message::release_fmi2_import_get_string_req() {
  clear_has_fmi2_import_get_string_req();
  ::fmitcp_proto::fmi2_import_get_string_req* temp = fmi2_import_get_string_req_;
  fmi2_import_get_string_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_string_req(::fmitcp_proto::fmi2_import_get_string_req* fmi2_import_get_string_req) {
  delete fmi2_import_get_string_req_;
  fmi2_import_get_string_req_ = fmi2_import_get_string_req;
  if (fmi2_import_get_string_req) {
    set_has_fmi2_import_get_string_req();
  } else {
    clear_has_fmi2_import_get_string_req();
  }
}

// optional .fmitcp_proto.fmi2_import_get_string_res fmi2_import_get_string_res = 75;
inline bool fmitcp_message::has_fmi2_import_get_string_res() const {
  return (_has_bits_[2] & 0x00000400u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_string_res() {
  _has_bits_[2] |= 0x00000400u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_string_res() {
  _has_bits_[2] &= ~0x00000400u;
}
inline void fmitcp_message::clear_fmi2_import_get_string_res() {
  if (fmi2_import_get_string_res_ != NULL) fmi2_import_get_string_res_->::fmitcp_proto::fmi2_import_get_string_res::Clear();
  clear_has_fmi2_import_get_string_res();
}
inline const ::fmitcp_proto::fmi2_import_get_string_res& fmitcp_message::fmi2_import_get_string_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_string_res_ != NULL ? *fmi2_import_get_string_res_ : *default_instance().fmi2_import_get_string_res_;
#else
  return fmi2_import_get_string_res_ != NULL ? *fmi2_import_get_string_res_ : *default_instance_->fmi2_import_get_string_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_string_res* fmitcp_message::mutable_fmi2_import_get_string_res() {
  set_has_fmi2_import_get_string_res();
  if (fmi2_import_get_string_res_ == NULL) fmi2_import_get_string_res_ = new ::fmitcp_proto::fmi2_import_get_string_res;
  return fmi2_import_get_string_res_;
}
inline ::fmitcp_proto::fmi2_import_get_string_res* fmitcp_message::release_fmi2_import_get_string_res() {
  clear_has_fmi2_import_get_string_res();
  ::fmitcp_proto::fmi2_import_get_string_res* temp = fmi2_import_get_string_res_;
  fmi2_import_get_string_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_string_res(::fmitcp_proto::fmi2_import_get_string_res* fmi2_import_get_string_res) {
  delete fmi2_import_get_string_res_;
  fmi2_import_get_string_res_ = fmi2_import_get_string_res;
  if (fmi2_import_get_string_res) {
    set_has_fmi2_import_get_string_res();
  } else {
    clear_has_fmi2_import_get_string_res();
  }
}

// optional .fmitcp_proto.fmi2_import_get_fmu_state_req fmi2_import_get_fmu_state_req = 76;
inline bool fmitcp_message::has_fmi2_import_get_fmu_state_req() const {
  return (_has_bits_[2] & 0x00000800u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_fmu_state_req() {
  _has_bits_[2] |= 0x00000800u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_fmu_state_req() {
  _has_bits_[2] &= ~0x00000800u;
}
inline void fmitcp_message::clear_fmi2_import_get_fmu_state_req() {
  if (fmi2_import_get_fmu_state_req_ != NULL) fmi2_import_get_fmu_state_req_->::fmitcp_proto::fmi2_import_get_fmu_state_req::Clear();
  clear_has_fmi2_import_get_fmu_state_req();
}
inline const ::fmitcp_proto::fmi2_import_get_fmu_state_req& fmitcp_message::fmi2_import_get_fmu_state_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_fmu_state_req_ != NULL ? *fmi2_import_get_fmu_state_req_ : *default_instance().fmi2_import_get_fmu_state_req_;
#else
  return fmi2_import_get_fmu_state_req_ != NULL ? *fmi2_import_get_fmu_state_req_ : *default_instance_->fmi2_import_get_fmu_state_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_fmu_state_req* fmitcp_message::mutable_fmi2_import_get_fmu_state_req() {
  set_has_fmi2_import_get_fmu_state_req();
  if (fmi2_import_get_fmu_state_req_ == NULL) fmi2_import_get_fmu_state_req_ = new ::fmitcp_proto::fmi2_import_get_fmu_state_req;
  return fmi2_import_get_fmu_state_req_;
}
inline ::fmitcp_proto::fmi2_import_get_fmu_state_req* fmitcp_message::release_fmi2_import_get_fmu_state_req() {
  clear_has_fmi2_import_get_fmu_state_req();
  ::fmitcp_proto::fmi2_import_get_fmu_state_req* temp = fmi2_import_get_fmu_state_req_;
  fmi2_import_get_fmu_state_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_fmu_state_req(::fmitcp_proto::fmi2_import_get_fmu_state_req* fmi2_import_get_fmu_state_req) {
  delete fmi2_import_get_fmu_state_req_;
  fmi2_import_get_fmu_state_req_ = fmi2_import_get_fmu_state_req;
  if (fmi2_import_get_fmu_state_req) {
    set_has_fmi2_import_get_fmu_state_req();
  } else {
    clear_has_fmi2_import_get_fmu_state_req();
  }
}

// optional .fmitcp_proto.fmi2_import_get_fmu_state_res fmi2_import_get_fmu_state_res = 77;
inline bool fmitcp_message::has_fmi2_import_get_fmu_state_res() const {
  return (_has_bits_[2] & 0x00001000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_fmu_state_res() {
  _has_bits_[2] |= 0x00001000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_fmu_state_res() {
  _has_bits_[2] &= ~0x00001000u;
}
inline void fmitcp_message::clear_fmi2_import_get_fmu_state_res() {
  if (fmi2_import_get_fmu_state_res_ != NULL) fmi2_import_get_fmu_state_res_->::fmitcp_proto::fmi2_import_get_fmu_state_res::Clear();
  clear_has_fmi2_import_get_fmu_state_res();
}
inline const ::fmitcp_proto::fmi2_import_get_fmu_state_res& fmitcp_message::fmi2_import_get_fmu_state_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_fmu_state_res_ != NULL ? *fmi2_import_get_fmu_state_res_ : *default_instance().fmi2_import_get_fmu_state_res_;
#else
  return fmi2_import_get_fmu_state_res_ != NULL ? *fmi2_import_get_fmu_state_res_ : *default_instance_->fmi2_import_get_fmu_state_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_fmu_state_res* fmitcp_message::mutable_fmi2_import_get_fmu_state_res() {
  set_has_fmi2_import_get_fmu_state_res();
  if (fmi2_import_get_fmu_state_res_ == NULL) fmi2_import_get_fmu_state_res_ = new ::fmitcp_proto::fmi2_import_get_fmu_state_res;
  return fmi2_import_get_fmu_state_res_;
}
inline ::fmitcp_proto::fmi2_import_get_fmu_state_res* fmitcp_message::release_fmi2_import_get_fmu_state_res() {
  clear_has_fmi2_import_get_fmu_state_res();
  ::fmitcp_proto::fmi2_import_get_fmu_state_res* temp = fmi2_import_get_fmu_state_res_;
  fmi2_import_get_fmu_state_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_fmu_state_res(::fmitcp_proto::fmi2_import_get_fmu_state_res* fmi2_import_get_fmu_state_res) {
  delete fmi2_import_get_fmu_state_res_;
  fmi2_import_get_fmu_state_res_ = fmi2_import_get_fmu_state_res;
  if (fmi2_import_get_fmu_state_res) {
    set_has_fmi2_import_get_fmu_state_res();
  } else {
    clear_has_fmi2_import_get_fmu_state_res();
  }
}

// optional .fmitcp_proto.fmi2_import_set_fmu_state_req fmi2_import_set_fmu_state_req = 78;
inline bool fmitcp_message::has_fmi2_import_set_fmu_state_req() const {
  return (_has_bits_[2] & 0x00002000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_set_fmu_state_req() {
  _has_bits_[2] |= 0x00002000u;
}
inline void fmitcp_message::clear_has_fmi2_import_set_fmu_state_req() {
  _has_bits_[2] &= ~0x00002000u;
}
inline void fmitcp_message::clear_fmi2_import_set_fmu_state_req() {
  if (fmi2_import_set_fmu_state_req_ != NULL) fmi2_import_set_fmu_state_req_->::fmitcp_proto::fmi2_import_set_fmu_state_req::Clear();
  clear_has_fmi2_import_set_fmu_state_req();
}
inline const ::fmitcp_proto::fmi2_import_set_fmu_state_req& fmitcp_message::fmi2_import_set_fmu_state_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_set_fmu_state_req_ != NULL ? *fmi2_import_set_fmu_state_req_ : *default_instance().fmi2_import_set_fmu_state_req_;
#else
  return fmi2_import_set_fmu_state_req_ != NULL ? *fmi2_import_set_fmu_state_req_ : *default_instance_->fmi2_import_set_fmu_state_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_set_fmu_state_req* fmitcp_message::mutable_fmi2_import_set_fmu_state_req() {
  set_has_fmi2_import_set_fmu_state_req();
  if (fmi2_import_set_fmu_state_req_ == NULL) fmi2_import_set_fmu_state_req_ = new ::fmitcp_proto::fmi2_import_set_fmu_state_req;
  return fmi2_import_set_fmu_state_req_;
}
inline ::fmitcp_proto::fmi2_import_set_fmu_state_req* fmitcp_message::release_fmi2_import_set_fmu_state_req() {
  clear_has_fmi2_import_set_fmu_state_req();
  ::fmitcp_proto::fmi2_import_set_fmu_state_req* temp = fmi2_import_set_fmu_state_req_;
  fmi2_import_set_fmu_state_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_set_fmu_state_req(::fmitcp_proto::fmi2_import_set_fmu_state_req* fmi2_import_set_fmu_state_req) {
  delete fmi2_import_set_fmu_state_req_;
  fmi2_import_set_fmu_state_req_ = fmi2_import_set_fmu_state_req;
  if (fmi2_import_set_fmu_state_req) {
    set_has_fmi2_import_set_fmu_state_req();
  } else {
    clear_has_fmi2_import_set_fmu_state_req();
  }
}

// optional .fmitcp_proto.fmi2_import_set_fmu_state_res fmi2_import_set_fmu_state_res = 79;
inline bool fmitcp_message::has_fmi2_import_set_fmu_state_res() const {
  return (_has_bits_[2] & 0x00004000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_set_fmu_state_res() {
  _has_bits_[2] |= 0x00004000u;
}
inline void fmitcp_message::clear_has_fmi2_import_set_fmu_state_res() {
  _has_bits_[2] &= ~0x00004000u;
}
inline void fmitcp_message::clear_fmi2_import_set_fmu_state_res() {
  if (fmi2_import_set_fmu_state_res_ != NULL) fmi2_import_set_fmu_state_res_->::fmitcp_proto::fmi2_import_set_fmu_state_res::Clear();
  clear_has_fmi2_import_set_fmu_state_res();
}
inline const ::fmitcp_proto::fmi2_import_set_fmu_state_res& fmitcp_message::fmi2_import_set_fmu_state_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_set_fmu_state_res_ != NULL ? *fmi2_import_set_fmu_state_res_ : *default_instance().fmi2_import_set_fmu_state_res_;
#else
  return fmi2_import_set_fmu_state_res_ != NULL ? *fmi2_import_set_fmu_state_res_ : *default_instance_->fmi2_import_set_fmu_state_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_set_fmu_state_res* fmitcp_message::mutable_fmi2_import_set_fmu_state_res() {
  set_has_fmi2_import_set_fmu_state_res();
  if (fmi2_import_set_fmu_state_res_ == NULL) fmi2_import_set_fmu_state_res_ = new ::fmitcp_proto::fmi2_import_set_fmu_state_res;
  return fmi2_import_set_fmu_state_res_;
}
inline ::fmitcp_proto::fmi2_import_set_fmu_state_res* fmitcp_message::release_fmi2_import_set_fmu_state_res() {
  clear_has_fmi2_import_set_fmu_state_res();
  ::fmitcp_proto::fmi2_import_set_fmu_state_res* temp = fmi2_import_set_fmu_state_res_;
  fmi2_import_set_fmu_state_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_set_fmu_state_res(::fmitcp_proto::fmi2_import_set_fmu_state_res* fmi2_import_set_fmu_state_res) {
  delete fmi2_import_set_fmu_state_res_;
  fmi2_import_set_fmu_state_res_ = fmi2_import_set_fmu_state_res;
  if (fmi2_import_set_fmu_state_res) {
    set_has_fmi2_import_set_fmu_state_res();
  } else {
    clear_has_fmi2_import_set_fmu_state_res();
  }
}

// optional .fmitcp_proto.fmi2_import_free_fmu_state_req fmi2_import_free_fmu_state_req = 80;
inline bool fmitcp_message::has_fmi2_import_free_fmu_state_req() const {
  return (_has_bits_[2] & 0x00008000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_free_fmu_state_req() {
  _has_bits_[2] |= 0x00008000u;
}
inline void fmitcp_message::clear_has_fmi2_import_free_fmu_state_req() {
  _has_bits_[2] &= ~0x00008000u;
}
inline void fmitcp_message::clear_fmi2_import_free_fmu_state_req() {
  if (fmi2_import_free_fmu_state_req_ != NULL) fmi2_import_free_fmu_state_req_->::fmitcp_proto::fmi2_import_free_fmu_state_req::Clear();
  clear_has_fmi2_import_free_fmu_state_req();
}
inline const ::fmitcp_proto::fmi2_import_free_fmu_state_req& fmitcp_message::fmi2_import_free_fmu_state_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_free_fmu_state_req_ != NULL ? *fmi2_import_free_fmu_state_req_ : *default_instance().fmi2_import_free_fmu_state_req_;
#else
  return fmi2_import_free_fmu_state_req_ != NULL ? *fmi2_import_free_fmu_state_req_ : *default_instance_->fmi2_import_free_fmu_state_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_free_fmu_state_req* fmitcp_message::mutable_fmi2_import_free_fmu_state_req() {
  set_has_fmi2_import_free_fmu_state_req();
  if (fmi2_import_free_fmu_state_req_ == NULL) fmi2_import_free_fmu_state_req_ = new ::fmitcp_proto::fmi2_import_free_fmu_state_req;
  return fmi2_import_free_fmu_state_req_;
}
inline ::fmitcp_proto::fmi2_import_free_fmu_state_req* fmitcp_message::release_fmi2_import_free_fmu_state_req() {
  clear_has_fmi2_import_free_fmu_state_req();
  ::fmitcp_proto::fmi2_import_free_fmu_state_req* temp = fmi2_import_free_fmu_state_req_;
  fmi2_import_free_fmu_state_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_free_fmu_state_req(::fmitcp_proto::fmi2_import_free_fmu_state_req* fmi2_import_free_fmu_state_req) {
  delete fmi2_import_free_fmu_state_req_;
  fmi2_import_free_fmu_state_req_ = fmi2_import_free_fmu_state_req;
  if (fmi2_import_free_fmu_state_req) {
    set_has_fmi2_import_free_fmu_state_req();
  } else {
    clear_has_fmi2_import_free_fmu_state_req();
  }
}

// optional .fmitcp_proto.fmi2_import_free_fmu_state_res fmi2_import_free_fmu_state_res = 81;
inline bool fmitcp_message::has_fmi2_import_free_fmu_state_res() const {
  return (_has_bits_[2] & 0x00010000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_free_fmu_state_res() {
  _has_bits_[2] |= 0x00010000u;
}
inline void fmitcp_message::clear_has_fmi2_import_free_fmu_state_res() {
  _has_bits_[2] &= ~0x00010000u;
}
inline void fmitcp_message::clear_fmi2_import_free_fmu_state_res() {
  if (fmi2_import_free_fmu_state_res_ != NULL) fmi2_import_free_fmu_state_res_->::fmitcp_proto::fmi2_import_free_fmu_state_res::Clear();
  clear_has_fmi2_import_free_fmu_state_res();
}
inline const ::fmitcp_proto::fmi2_import_free_fmu_state_res& fmitcp_message::fmi2_import_free_fmu_state_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_free_fmu_state_res_ != NULL ? *fmi2_import_free_fmu_state_res_ : *default_instance().fmi2_import_free_fmu_state_res_;
#else
  return fmi2_import_free_fmu_state_res_ != NULL ? *fmi2_import_free_fmu_state_res_ : *default_instance_->fmi2_import_free_fmu_state_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_free_fmu_state_res* fmitcp_message::mutable_fmi2_import_free_fmu_state_res() {
  set_has_fmi2_import_free_fmu_state_res();
  if (fmi2_import_free_fmu_state_res_ == NULL) fmi2_import_free_fmu_state_res_ = new ::fmitcp_proto::fmi2_import_free_fmu_state_res;
  return fmi2_import_free_fmu_state_res_;
}
inline ::fmitcp_proto::fmi2_import_free_fmu_state_res* fmitcp_message::release_fmi2_import_free_fmu_state_res() {
  clear_has_fmi2_import_free_fmu_state_res();
  ::fmitcp_proto::fmi2_import_free_fmu_state_res* temp = fmi2_import_free_fmu_state_res_;
  fmi2_import_free_fmu_state_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_free_fmu_state_res(::fmitcp_proto::fmi2_import_free_fmu_state_res* fmi2_import_free_fmu_state_res) {
  delete fmi2_import_free_fmu_state_res_;
  fmi2_import_free_fmu_state_res_ = fmi2_import_free_fmu_state_res;
  if (fmi2_import_free_fmu_state_res) {
    set_has_fmi2_import_free_fmu_state_res();
  } else {
    clear_has_fmi2_import_free_fmu_state_res();
  }
}

// optional .fmitcp_proto.fmi2_import_get_directional_derivative_req fmi2_import_get_directional_derivative_req = 88;
inline bool fmitcp_message::has_fmi2_import_get_directional_derivative_req() const {
  return (_has_bits_[2] & 0x00020000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_directional_derivative_req() {
  _has_bits_[2] |= 0x00020000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_directional_derivative_req() {
  _has_bits_[2] &= ~0x00020000u;
}
inline void fmitcp_message::clear_fmi2_import_get_directional_derivative_req() {
  if (fmi2_import_get_directional_derivative_req_ != NULL) fmi2_import_get_directional_derivative_req_->::fmitcp_proto::fmi2_import_get_directional_derivative_req::Clear();
  clear_has_fmi2_import_get_directional_derivative_req();
}
inline const ::fmitcp_proto::fmi2_import_get_directional_derivative_req& fmitcp_message::fmi2_import_get_directional_derivative_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_directional_derivative_req_ != NULL ? *fmi2_import_get_directional_derivative_req_ : *default_instance().fmi2_import_get_directional_derivative_req_;
#else
  return fmi2_import_get_directional_derivative_req_ != NULL ? *fmi2_import_get_directional_derivative_req_ : *default_instance_->fmi2_import_get_directional_derivative_req_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_directional_derivative_req* fmitcp_message::mutable_fmi2_import_get_directional_derivative_req() {
  set_has_fmi2_import_get_directional_derivative_req();
  if (fmi2_import_get_directional_derivative_req_ == NULL) fmi2_import_get_directional_derivative_req_ = new ::fmitcp_proto::fmi2_import_get_directional_derivative_req;
  return fmi2_import_get_directional_derivative_req_;
}
inline ::fmitcp_proto::fmi2_import_get_directional_derivative_req* fmitcp_message::release_fmi2_import_get_directional_derivative_req() {
  clear_has_fmi2_import_get_directional_derivative_req();
  ::fmitcp_proto::fmi2_import_get_directional_derivative_req* temp = fmi2_import_get_directional_derivative_req_;
  fmi2_import_get_directional_derivative_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_directional_derivative_req(::fmitcp_proto::fmi2_import_get_directional_derivative_req* fmi2_import_get_directional_derivative_req) {
  delete fmi2_import_get_directional_derivative_req_;
  fmi2_import_get_directional_derivative_req_ = fmi2_import_get_directional_derivative_req;
  if (fmi2_import_get_directional_derivative_req) {
    set_has_fmi2_import_get_directional_derivative_req();
  } else {
    clear_has_fmi2_import_get_directional_derivative_req();
  }
}

// optional .fmitcp_proto.fmi2_import_get_directional_derivative_res fmi2_import_get_directional_derivative_res = 89;
inline bool fmitcp_message::has_fmi2_import_get_directional_derivative_res() const {
  return (_has_bits_[2] & 0x00040000u) != 0;
}
inline void fmitcp_message::set_has_fmi2_import_get_directional_derivative_res() {
  _has_bits_[2] |= 0x00040000u;
}
inline void fmitcp_message::clear_has_fmi2_import_get_directional_derivative_res() {
  _has_bits_[2] &= ~0x00040000u;
}
inline void fmitcp_message::clear_fmi2_import_get_directional_derivative_res() {
  if (fmi2_import_get_directional_derivative_res_ != NULL) fmi2_import_get_directional_derivative_res_->::fmitcp_proto::fmi2_import_get_directional_derivative_res::Clear();
  clear_has_fmi2_import_get_directional_derivative_res();
}
inline const ::fmitcp_proto::fmi2_import_get_directional_derivative_res& fmitcp_message::fmi2_import_get_directional_derivative_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fmi2_import_get_directional_derivative_res_ != NULL ? *fmi2_import_get_directional_derivative_res_ : *default_instance().fmi2_import_get_directional_derivative_res_;
#else
  return fmi2_import_get_directional_derivative_res_ != NULL ? *fmi2_import_get_directional_derivative_res_ : *default_instance_->fmi2_import_get_directional_derivative_res_;
#endif
}
inline ::fmitcp_proto::fmi2_import_get_directional_derivative_res* fmitcp_message::mutable_fmi2_import_get_directional_derivative_res() {
  set_has_fmi2_import_get_directional_derivative_res();
  if (fmi2_import_get_directional_derivative_res_ == NULL) fmi2_import_get_directional_derivative_res_ = new ::fmitcp_proto::fmi2_import_get_directional_derivative_res;
  return fmi2_import_get_directional_derivative_res_;
}
inline ::fmitcp_proto::fmi2_import_get_directional_derivative_res* fmitcp_message::release_fmi2_import_get_directional_derivative_res() {
  clear_has_fmi2_import_get_directional_derivative_res();
  ::fmitcp_proto::fmi2_import_get_directional_derivative_res* temp = fmi2_import_get_directional_derivative_res_;
  fmi2_import_get_directional_derivative_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_fmi2_import_get_directional_derivative_res(::fmitcp_proto::fmi2_import_get_directional_derivative_res* fmi2_import_get_directional_derivative_res) {
  delete fmi2_import_get_directional_derivative_res_;
  fmi2_import_get_directional_derivative_res_ = fmi2_import_get_directional_derivative_res;
  if (fmi2_import_get_directional_derivative_res) {
    set_has_fmi2_import_get_directional_derivative_res();
  } else {
    clear_has_fmi2_import_get_directional_derivative_res();
  }
}

// optional .fmitcp_proto.get_xml_req get_xml_req = 90;
inline bool fmitcp_message::has_get_xml_req() const {
  return (_has_bits_[2] & 0x00080000u) != 0;
}
inline void fmitcp_message::set_has_get_xml_req() {
  _has_bits_[2] |= 0x00080000u;
}
inline void fmitcp_message::clear_has_get_xml_req() {
  _has_bits_[2] &= ~0x00080000u;
}
inline void fmitcp_message::clear_get_xml_req() {
  if (get_xml_req_ != NULL) get_xml_req_->::fmitcp_proto::get_xml_req::Clear();
  clear_has_get_xml_req();
}
inline const ::fmitcp_proto::get_xml_req& fmitcp_message::get_xml_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return get_xml_req_ != NULL ? *get_xml_req_ : *default_instance().get_xml_req_;
#else
  return get_xml_req_ != NULL ? *get_xml_req_ : *default_instance_->get_xml_req_;
#endif
}
inline ::fmitcp_proto::get_xml_req* fmitcp_message::mutable_get_xml_req() {
  set_has_get_xml_req();
  if (get_xml_req_ == NULL) get_xml_req_ = new ::fmitcp_proto::get_xml_req;
  return get_xml_req_;
}
inline ::fmitcp_proto::get_xml_req* fmitcp_message::release_get_xml_req() {
  clear_has_get_xml_req();
  ::fmitcp_proto::get_xml_req* temp = get_xml_req_;
  get_xml_req_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_get_xml_req(::fmitcp_proto::get_xml_req* get_xml_req) {
  delete get_xml_req_;
  get_xml_req_ = get_xml_req;
  if (get_xml_req) {
    set_has_get_xml_req();
  } else {
    clear_has_get_xml_req();
  }
}

// optional .fmitcp_proto.get_xml_res get_xml_res = 91;
inline bool fmitcp_message::has_get_xml_res() const {
  return (_has_bits_[2] & 0x00100000u) != 0;
}
inline void fmitcp_message::set_has_get_xml_res() {
  _has_bits_[2] |= 0x00100000u;
}
inline void fmitcp_message::clear_has_get_xml_res() {
  _has_bits_[2] &= ~0x00100000u;
}
inline void fmitcp_message::clear_get_xml_res() {
  if (get_xml_res_ != NULL) get_xml_res_->::fmitcp_proto::get_xml_res::Clear();
  clear_has_get_xml_res();
}
inline const ::fmitcp_proto::get_xml_res& fmitcp_message::get_xml_res() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return get_xml_res_ != NULL ? *get_xml_res_ : *default_instance().get_xml_res_;
#else
  return get_xml_res_ != NULL ? *get_xml_res_ : *default_instance_->get_xml_res_;
#endif
}
inline ::fmitcp_proto::get_xml_res* fmitcp_message::mutable_get_xml_res() {
  set_has_get_xml_res();
  if (get_xml_res_ == NULL) get_xml_res_ = new ::fmitcp_proto::get_xml_res;
  return get_xml_res_;
}
inline ::fmitcp_proto::get_xml_res* fmitcp_message::release_get_xml_res() {
  clear_has_get_xml_res();
  ::fmitcp_proto::get_xml_res* temp = get_xml_res_;
  get_xml_res_ = NULL;
  return temp;
}
inline void fmitcp_message::set_allocated_get_xml_res(::fmitcp_proto::get_xml_res* get_xml_res) {
  delete get_xml_res_;
  get_xml_res_ = get_xml_res;
  if (get_xml_res) {
    set_has_get_xml_res();
  } else {
    clear_has_get_xml_res();
  }
}

// -------------------------------------------------------------------

// fmi2_event_info_t

// required bool iterationConverged = 1;
inline bool fmi2_event_info_t::has_iterationconverged() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_event_info_t::set_has_iterationconverged() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_event_info_t::clear_has_iterationconverged() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_event_info_t::clear_iterationconverged() {
  iterationconverged_ = false;
  clear_has_iterationconverged();
}
inline bool fmi2_event_info_t::iterationconverged() const {
  return iterationconverged_;
}
inline void fmi2_event_info_t::set_iterationconverged(bool value) {
  set_has_iterationconverged();
  iterationconverged_ = value;
}

// required bool stateValueReferencesChanged = 2;
inline bool fmi2_event_info_t::has_statevaluereferenceschanged() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_event_info_t::set_has_statevaluereferenceschanged() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_event_info_t::clear_has_statevaluereferenceschanged() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_event_info_t::clear_statevaluereferenceschanged() {
  statevaluereferenceschanged_ = false;
  clear_has_statevaluereferenceschanged();
}
inline bool fmi2_event_info_t::statevaluereferenceschanged() const {
  return statevaluereferenceschanged_;
}
inline void fmi2_event_info_t::set_statevaluereferenceschanged(bool value) {
  set_has_statevaluereferenceschanged();
  statevaluereferenceschanged_ = value;
}

// required bool stateValuesChanged = 3;
inline bool fmi2_event_info_t::has_statevalueschanged() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_event_info_t::set_has_statevalueschanged() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_event_info_t::clear_has_statevalueschanged() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_event_info_t::clear_statevalueschanged() {
  statevalueschanged_ = false;
  clear_has_statevalueschanged();
}
inline bool fmi2_event_info_t::statevalueschanged() const {
  return statevalueschanged_;
}
inline void fmi2_event_info_t::set_statevalueschanged(bool value) {
  set_has_statevalueschanged();
  statevalueschanged_ = value;
}

// required bool terminateSimulation = 4;
inline bool fmi2_event_info_t::has_terminatesimulation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fmi2_event_info_t::set_has_terminatesimulation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fmi2_event_info_t::clear_has_terminatesimulation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fmi2_event_info_t::clear_terminatesimulation() {
  terminatesimulation_ = false;
  clear_has_terminatesimulation();
}
inline bool fmi2_event_info_t::terminatesimulation() const {
  return terminatesimulation_;
}
inline void fmi2_event_info_t::set_terminatesimulation(bool value) {
  set_has_terminatesimulation();
  terminatesimulation_ = value;
}

// required bool upcomingTimeEvent = 5;
inline bool fmi2_event_info_t::has_upcomingtimeevent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fmi2_event_info_t::set_has_upcomingtimeevent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void fmi2_event_info_t::clear_has_upcomingtimeevent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void fmi2_event_info_t::clear_upcomingtimeevent() {
  upcomingtimeevent_ = false;
  clear_has_upcomingtimeevent();
}
inline bool fmi2_event_info_t::upcomingtimeevent() const {
  return upcomingtimeevent_;
}
inline void fmi2_event_info_t::set_upcomingtimeevent(bool value) {
  set_has_upcomingtimeevent();
  upcomingtimeevent_ = value;
}

// required double nextEventTime = 6;
inline bool fmi2_event_info_t::has_nexteventtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void fmi2_event_info_t::set_has_nexteventtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void fmi2_event_info_t::clear_has_nexteventtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void fmi2_event_info_t::clear_nexteventtime() {
  nexteventtime_ = 0;
  clear_has_nexteventtime();
}
inline double fmi2_event_info_t::nexteventtime() const {
  return nexteventtime_;
}
inline void fmi2_event_info_t::set_nexteventtime(double value) {
  set_has_nexteventtime();
  nexteventtime_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_instantiate_req

// required int32 message_id = 1;
inline bool fmi2_import_instantiate_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_instantiate_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_instantiate_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_instantiate_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_instantiate_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_instantiate_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// optional bool visible = 2;
inline bool fmi2_import_instantiate_req::has_visible() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_instantiate_req::set_has_visible() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_instantiate_req::clear_has_visible() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_instantiate_req::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool fmi2_import_instantiate_req::visible() const {
  return visible_;
}
inline void fmi2_import_instantiate_req::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_instantiate_res

// required int32 message_id = 1;
inline bool fmi2_import_instantiate_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_instantiate_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_instantiate_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_instantiate_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_instantiate_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_instantiate_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.jm_status_enu_t status = 2;
inline bool fmi2_import_instantiate_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_instantiate_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_instantiate_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_instantiate_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::jm_status_enu_t fmi2_import_instantiate_res::status() const {
  return static_cast< ::fmitcp_proto::jm_status_enu_t >(status_);
}
inline void fmi2_import_instantiate_res::set_status(::fmitcp_proto::jm_status_enu_t value) {
  assert(::fmitcp_proto::jm_status_enu_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_initialize_slave_req

// required int32 message_id = 1;
inline bool fmi2_import_initialize_slave_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_initialize_slave_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_initialize_slave_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_initialize_slave_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_initialize_slave_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_initialize_slave_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_initialize_slave_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_initialize_slave_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_initialize_slave_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_initialize_slave_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_initialize_slave_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_initialize_slave_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// required bool toleranceDefined = 3;
inline bool fmi2_import_initialize_slave_req::has_tolerancedefined() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_initialize_slave_req::set_has_tolerancedefined() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_initialize_slave_req::clear_has_tolerancedefined() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_initialize_slave_req::clear_tolerancedefined() {
  tolerancedefined_ = false;
  clear_has_tolerancedefined();
}
inline bool fmi2_import_initialize_slave_req::tolerancedefined() const {
  return tolerancedefined_;
}
inline void fmi2_import_initialize_slave_req::set_tolerancedefined(bool value) {
  set_has_tolerancedefined();
  tolerancedefined_ = value;
}

// required double tolerance = 4;
inline bool fmi2_import_initialize_slave_req::has_tolerance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fmi2_import_initialize_slave_req::set_has_tolerance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fmi2_import_initialize_slave_req::clear_has_tolerance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fmi2_import_initialize_slave_req::clear_tolerance() {
  tolerance_ = 0;
  clear_has_tolerance();
}
inline double fmi2_import_initialize_slave_req::tolerance() const {
  return tolerance_;
}
inline void fmi2_import_initialize_slave_req::set_tolerance(double value) {
  set_has_tolerance();
  tolerance_ = value;
}

// required double startTime = 5;
inline bool fmi2_import_initialize_slave_req::has_starttime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fmi2_import_initialize_slave_req::set_has_starttime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void fmi2_import_initialize_slave_req::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void fmi2_import_initialize_slave_req::clear_starttime() {
  starttime_ = 0;
  clear_has_starttime();
}
inline double fmi2_import_initialize_slave_req::starttime() const {
  return starttime_;
}
inline void fmi2_import_initialize_slave_req::set_starttime(double value) {
  set_has_starttime();
  starttime_ = value;
}

// required bool stopTimeDefined = 6;
inline bool fmi2_import_initialize_slave_req::has_stoptimedefined() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void fmi2_import_initialize_slave_req::set_has_stoptimedefined() {
  _has_bits_[0] |= 0x00000020u;
}
inline void fmi2_import_initialize_slave_req::clear_has_stoptimedefined() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void fmi2_import_initialize_slave_req::clear_stoptimedefined() {
  stoptimedefined_ = false;
  clear_has_stoptimedefined();
}
inline bool fmi2_import_initialize_slave_req::stoptimedefined() const {
  return stoptimedefined_;
}
inline void fmi2_import_initialize_slave_req::set_stoptimedefined(bool value) {
  set_has_stoptimedefined();
  stoptimedefined_ = value;
}

// required double stopTime = 7;
inline bool fmi2_import_initialize_slave_req::has_stoptime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void fmi2_import_initialize_slave_req::set_has_stoptime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void fmi2_import_initialize_slave_req::clear_has_stoptime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void fmi2_import_initialize_slave_req::clear_stoptime() {
  stoptime_ = 0;
  clear_has_stoptime();
}
inline double fmi2_import_initialize_slave_req::stoptime() const {
  return stoptime_;
}
inline void fmi2_import_initialize_slave_req::set_stoptime(double value) {
  set_has_stoptime();
  stoptime_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_initialize_slave_res

// required int32 message_id = 1;
inline bool fmi2_import_initialize_slave_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_initialize_slave_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_initialize_slave_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_initialize_slave_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_initialize_slave_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_initialize_slave_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 2;
inline bool fmi2_import_initialize_slave_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_initialize_slave_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_initialize_slave_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_initialize_slave_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_initialize_slave_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_initialize_slave_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_terminate_slave_req

// required int32 message_id = 1;
inline bool fmi2_import_terminate_slave_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_terminate_slave_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_terminate_slave_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_terminate_slave_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_terminate_slave_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_terminate_slave_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_terminate_slave_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_terminate_slave_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_terminate_slave_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_terminate_slave_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_terminate_slave_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_terminate_slave_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_terminate_slave_res

// required int32 message_id = 1;
inline bool fmi2_import_terminate_slave_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_terminate_slave_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_terminate_slave_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_terminate_slave_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_terminate_slave_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_terminate_slave_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 2;
inline bool fmi2_import_terminate_slave_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_terminate_slave_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_terminate_slave_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_terminate_slave_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_terminate_slave_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_terminate_slave_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_reset_slave_req

// required int32 message_id = 1;
inline bool fmi2_import_reset_slave_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_reset_slave_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_reset_slave_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_reset_slave_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_reset_slave_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_reset_slave_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_reset_slave_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_reset_slave_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_reset_slave_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_reset_slave_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_reset_slave_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_reset_slave_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_reset_slave_res

// required int32 message_id = 1;
inline bool fmi2_import_reset_slave_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_reset_slave_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_reset_slave_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_reset_slave_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_reset_slave_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_reset_slave_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 2;
inline bool fmi2_import_reset_slave_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_reset_slave_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_reset_slave_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_reset_slave_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_reset_slave_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_reset_slave_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_free_slave_instance_req

// required int32 message_id = 1;
inline bool fmi2_import_free_slave_instance_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_free_slave_instance_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_free_slave_instance_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_free_slave_instance_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_free_slave_instance_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_free_slave_instance_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_free_slave_instance_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_free_slave_instance_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_free_slave_instance_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_free_slave_instance_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_free_slave_instance_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_free_slave_instance_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_free_slave_instance_res

// required int32 message_id = 1;
inline bool fmi2_import_free_slave_instance_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_free_slave_instance_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_free_slave_instance_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_free_slave_instance_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_free_slave_instance_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_free_slave_instance_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_set_real_input_derivatives_req

// required int32 message_id = 1;
inline bool fmi2_import_set_real_input_derivatives_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_set_real_input_derivatives_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_set_real_input_derivatives_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_set_real_input_derivatives_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_set_real_input_derivatives_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_set_real_input_derivatives_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_set_real_input_derivatives_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_set_real_input_derivatives_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_set_real_input_derivatives_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_set_real_input_derivatives_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_set_real_input_derivatives_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_set_real_input_derivatives_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// repeated int32 valueReferences = 3 [packed = true];
inline int fmi2_import_set_real_input_derivatives_req::valuereferences_size() const {
  return valuereferences_.size();
}
inline void fmi2_import_set_real_input_derivatives_req::clear_valuereferences() {
  valuereferences_.Clear();
}
inline ::google::protobuf::int32 fmi2_import_set_real_input_derivatives_req::valuereferences(int index) const {
  return valuereferences_.Get(index);
}
inline void fmi2_import_set_real_input_derivatives_req::set_valuereferences(int index, ::google::protobuf::int32 value) {
  valuereferences_.Set(index, value);
}
inline void fmi2_import_set_real_input_derivatives_req::add_valuereferences(::google::protobuf::int32 value) {
  valuereferences_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
fmi2_import_set_real_input_derivatives_req::valuereferences() const {
  return valuereferences_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
fmi2_import_set_real_input_derivatives_req::mutable_valuereferences() {
  return &valuereferences_;
}

// repeated int32 orders = 4 [packed = true];
inline int fmi2_import_set_real_input_derivatives_req::orders_size() const {
  return orders_.size();
}
inline void fmi2_import_set_real_input_derivatives_req::clear_orders() {
  orders_.Clear();
}
inline ::google::protobuf::int32 fmi2_import_set_real_input_derivatives_req::orders(int index) const {
  return orders_.Get(index);
}
inline void fmi2_import_set_real_input_derivatives_req::set_orders(int index, ::google::protobuf::int32 value) {
  orders_.Set(index, value);
}
inline void fmi2_import_set_real_input_derivatives_req::add_orders(::google::protobuf::int32 value) {
  orders_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
fmi2_import_set_real_input_derivatives_req::orders() const {
  return orders_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
fmi2_import_set_real_input_derivatives_req::mutable_orders() {
  return &orders_;
}

// repeated double values = 5 [packed = true];
inline int fmi2_import_set_real_input_derivatives_req::values_size() const {
  return values_.size();
}
inline void fmi2_import_set_real_input_derivatives_req::clear_values() {
  values_.Clear();
}
inline double fmi2_import_set_real_input_derivatives_req::values(int index) const {
  return values_.Get(index);
}
inline void fmi2_import_set_real_input_derivatives_req::set_values(int index, double value) {
  values_.Set(index, value);
}
inline void fmi2_import_set_real_input_derivatives_req::add_values(double value) {
  values_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fmi2_import_set_real_input_derivatives_req::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedField< double >*
fmi2_import_set_real_input_derivatives_req::mutable_values() {
  return &values_;
}

// -------------------------------------------------------------------

// fmi2_import_set_real_input_derivatives_res

// required int32 message_id = 1;
inline bool fmi2_import_set_real_input_derivatives_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_set_real_input_derivatives_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_set_real_input_derivatives_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_set_real_input_derivatives_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_set_real_input_derivatives_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_set_real_input_derivatives_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 2;
inline bool fmi2_import_set_real_input_derivatives_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_set_real_input_derivatives_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_set_real_input_derivatives_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_set_real_input_derivatives_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_set_real_input_derivatives_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_set_real_input_derivatives_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_real_output_derivatives_req

// required int32 message_id = 1;
inline bool fmi2_import_get_real_output_derivatives_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_real_output_derivatives_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_real_output_derivatives_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_real_output_derivatives_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_real_output_derivatives_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_real_output_derivatives_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_get_real_output_derivatives_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_real_output_derivatives_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_real_output_derivatives_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_real_output_derivatives_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_get_real_output_derivatives_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_get_real_output_derivatives_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// repeated int32 valueReferences = 3 [packed = true];
inline int fmi2_import_get_real_output_derivatives_req::valuereferences_size() const {
  return valuereferences_.size();
}
inline void fmi2_import_get_real_output_derivatives_req::clear_valuereferences() {
  valuereferences_.Clear();
}
inline ::google::protobuf::int32 fmi2_import_get_real_output_derivatives_req::valuereferences(int index) const {
  return valuereferences_.Get(index);
}
inline void fmi2_import_get_real_output_derivatives_req::set_valuereferences(int index, ::google::protobuf::int32 value) {
  valuereferences_.Set(index, value);
}
inline void fmi2_import_get_real_output_derivatives_req::add_valuereferences(::google::protobuf::int32 value) {
  valuereferences_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
fmi2_import_get_real_output_derivatives_req::valuereferences() const {
  return valuereferences_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
fmi2_import_get_real_output_derivatives_req::mutable_valuereferences() {
  return &valuereferences_;
}

// repeated int32 orders = 4 [packed = true];
inline int fmi2_import_get_real_output_derivatives_req::orders_size() const {
  return orders_.size();
}
inline void fmi2_import_get_real_output_derivatives_req::clear_orders() {
  orders_.Clear();
}
inline ::google::protobuf::int32 fmi2_import_get_real_output_derivatives_req::orders(int index) const {
  return orders_.Get(index);
}
inline void fmi2_import_get_real_output_derivatives_req::set_orders(int index, ::google::protobuf::int32 value) {
  orders_.Set(index, value);
}
inline void fmi2_import_get_real_output_derivatives_req::add_orders(::google::protobuf::int32 value) {
  orders_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
fmi2_import_get_real_output_derivatives_req::orders() const {
  return orders_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
fmi2_import_get_real_output_derivatives_req::mutable_orders() {
  return &orders_;
}

// -------------------------------------------------------------------

// fmi2_import_get_real_output_derivatives_res

// required int32 message_id = 1;
inline bool fmi2_import_get_real_output_derivatives_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_real_output_derivatives_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_real_output_derivatives_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_real_output_derivatives_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_real_output_derivatives_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_real_output_derivatives_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 2;
inline bool fmi2_import_get_real_output_derivatives_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_real_output_derivatives_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_real_output_derivatives_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_real_output_derivatives_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_get_real_output_derivatives_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_get_real_output_derivatives_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// repeated double values = 3 [packed = true];
inline int fmi2_import_get_real_output_derivatives_res::values_size() const {
  return values_.size();
}
inline void fmi2_import_get_real_output_derivatives_res::clear_values() {
  values_.Clear();
}
inline double fmi2_import_get_real_output_derivatives_res::values(int index) const {
  return values_.Get(index);
}
inline void fmi2_import_get_real_output_derivatives_res::set_values(int index, double value) {
  values_.Set(index, value);
}
inline void fmi2_import_get_real_output_derivatives_res::add_values(double value) {
  values_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fmi2_import_get_real_output_derivatives_res::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedField< double >*
fmi2_import_get_real_output_derivatives_res::mutable_values() {
  return &values_;
}

// -------------------------------------------------------------------

// fmi2_import_cancel_step_req

// required int32 message_id = 1;
inline bool fmi2_import_cancel_step_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_cancel_step_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_cancel_step_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_cancel_step_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_cancel_step_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_cancel_step_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_cancel_step_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_cancel_step_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_cancel_step_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_cancel_step_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_cancel_step_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_cancel_step_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_cancel_step_res

// required int32 message_id = 1;
inline bool fmi2_import_cancel_step_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_cancel_step_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_cancel_step_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_cancel_step_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_cancel_step_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_cancel_step_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 2;
inline bool fmi2_import_cancel_step_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_cancel_step_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_cancel_step_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_cancel_step_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_cancel_step_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_cancel_step_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_do_step_req

// required int32 message_id = 1;
inline bool fmi2_import_do_step_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_do_step_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_do_step_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_do_step_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_do_step_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_do_step_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_do_step_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_do_step_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_do_step_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_do_step_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_do_step_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_do_step_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// required double currentCommunicationPoint = 3;
inline bool fmi2_import_do_step_req::has_currentcommunicationpoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_do_step_req::set_has_currentcommunicationpoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_do_step_req::clear_has_currentcommunicationpoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_do_step_req::clear_currentcommunicationpoint() {
  currentcommunicationpoint_ = 0;
  clear_has_currentcommunicationpoint();
}
inline double fmi2_import_do_step_req::currentcommunicationpoint() const {
  return currentcommunicationpoint_;
}
inline void fmi2_import_do_step_req::set_currentcommunicationpoint(double value) {
  set_has_currentcommunicationpoint();
  currentcommunicationpoint_ = value;
}

// required double communicationStepSize = 4;
inline bool fmi2_import_do_step_req::has_communicationstepsize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fmi2_import_do_step_req::set_has_communicationstepsize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fmi2_import_do_step_req::clear_has_communicationstepsize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fmi2_import_do_step_req::clear_communicationstepsize() {
  communicationstepsize_ = 0;
  clear_has_communicationstepsize();
}
inline double fmi2_import_do_step_req::communicationstepsize() const {
  return communicationstepsize_;
}
inline void fmi2_import_do_step_req::set_communicationstepsize(double value) {
  set_has_communicationstepsize();
  communicationstepsize_ = value;
}

// required bool newStep = 5;
inline bool fmi2_import_do_step_req::has_newstep() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fmi2_import_do_step_req::set_has_newstep() {
  _has_bits_[0] |= 0x00000010u;
}
inline void fmi2_import_do_step_req::clear_has_newstep() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void fmi2_import_do_step_req::clear_newstep() {
  newstep_ = false;
  clear_has_newstep();
}
inline bool fmi2_import_do_step_req::newstep() const {
  return newstep_;
}
inline void fmi2_import_do_step_req::set_newstep(bool value) {
  set_has_newstep();
  newstep_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_do_step_res

// required int32 message_id = 1;
inline bool fmi2_import_do_step_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_do_step_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_do_step_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_do_step_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_do_step_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_do_step_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 2;
inline bool fmi2_import_do_step_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_do_step_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_do_step_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_do_step_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_do_step_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_do_step_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_status_req

// required int32 message_id = 1;
inline bool fmi2_import_get_status_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_status_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_status_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_status_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_status_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_status_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_get_status_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_status_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_status_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_status_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_get_status_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_get_status_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// required .fmitcp_proto.fmi2_status_kind_t status = 3;
inline bool fmi2_import_get_status_req::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_get_status_req::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_get_status_req::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_get_status_req::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_kind_t fmi2_import_get_status_req::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_kind_t >(status_);
}
inline void fmi2_import_get_status_req::set_status(::fmitcp_proto::fmi2_status_kind_t value) {
  assert(::fmitcp_proto::fmi2_status_kind_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_status_res

// required int32 message_id = 1;
inline bool fmi2_import_get_status_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_status_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_status_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_status_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_status_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_status_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_status_t value = 2;
inline bool fmi2_import_get_status_res::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_status_res::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_status_res::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_status_res::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_get_status_res::value() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(value_);
}
inline void fmi2_import_get_status_res::set_value(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_real_status_req

// required int32 message_id = 1;
inline bool fmi2_import_get_real_status_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_real_status_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_real_status_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_real_status_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_real_status_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_real_status_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_get_real_status_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_real_status_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_real_status_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_real_status_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_get_real_status_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_get_real_status_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// required .fmitcp_proto.fmi2_status_kind_t kind = 3;
inline bool fmi2_import_get_real_status_req::has_kind() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_get_real_status_req::set_has_kind() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_get_real_status_req::clear_has_kind() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_get_real_status_req::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::fmitcp_proto::fmi2_status_kind_t fmi2_import_get_real_status_req::kind() const {
  return static_cast< ::fmitcp_proto::fmi2_status_kind_t >(kind_);
}
inline void fmi2_import_get_real_status_req::set_kind(::fmitcp_proto::fmi2_status_kind_t value) {
  assert(::fmitcp_proto::fmi2_status_kind_t_IsValid(value));
  set_has_kind();
  kind_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_real_status_res

// required int32 message_id = 1;
inline bool fmi2_import_get_real_status_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_real_status_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_real_status_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_real_status_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_real_status_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_real_status_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required double value = 2;
inline bool fmi2_import_get_real_status_res::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_real_status_res::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_real_status_res::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_real_status_res::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double fmi2_import_get_real_status_res::value() const {
  return value_;
}
inline void fmi2_import_get_real_status_res::set_value(double value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_integer_status_req

// required int32 message_id = 1;
inline bool fmi2_import_get_integer_status_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_integer_status_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_integer_status_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_integer_status_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_integer_status_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_integer_status_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_get_integer_status_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_integer_status_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_integer_status_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_integer_status_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_get_integer_status_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_get_integer_status_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// required .fmitcp_proto.fmi2_status_kind_t kind = 3;
inline bool fmi2_import_get_integer_status_req::has_kind() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_get_integer_status_req::set_has_kind() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_get_integer_status_req::clear_has_kind() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_get_integer_status_req::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::fmitcp_proto::fmi2_status_kind_t fmi2_import_get_integer_status_req::kind() const {
  return static_cast< ::fmitcp_proto::fmi2_status_kind_t >(kind_);
}
inline void fmi2_import_get_integer_status_req::set_kind(::fmitcp_proto::fmi2_status_kind_t value) {
  assert(::fmitcp_proto::fmi2_status_kind_t_IsValid(value));
  set_has_kind();
  kind_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_integer_status_res

// required int32 message_id = 1;
inline bool fmi2_import_get_integer_status_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_integer_status_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_integer_status_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_integer_status_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_integer_status_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_integer_status_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 value = 2;
inline bool fmi2_import_get_integer_status_res::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_integer_status_res::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_integer_status_res::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_integer_status_res::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 fmi2_import_get_integer_status_res::value() const {
  return value_;
}
inline void fmi2_import_get_integer_status_res::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_boolean_status_req

// required int32 message_id = 1;
inline bool fmi2_import_get_boolean_status_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_boolean_status_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_boolean_status_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_boolean_status_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_boolean_status_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_boolean_status_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_get_boolean_status_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_boolean_status_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_boolean_status_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_boolean_status_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_get_boolean_status_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_get_boolean_status_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// required .fmitcp_proto.fmi2_status_kind_t kind = 3;
inline bool fmi2_import_get_boolean_status_req::has_kind() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_get_boolean_status_req::set_has_kind() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_get_boolean_status_req::clear_has_kind() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_get_boolean_status_req::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::fmitcp_proto::fmi2_status_kind_t fmi2_import_get_boolean_status_req::kind() const {
  return static_cast< ::fmitcp_proto::fmi2_status_kind_t >(kind_);
}
inline void fmi2_import_get_boolean_status_req::set_kind(::fmitcp_proto::fmi2_status_kind_t value) {
  assert(::fmitcp_proto::fmi2_status_kind_t_IsValid(value));
  set_has_kind();
  kind_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_boolean_status_res

// required int32 message_id = 1;
inline bool fmi2_import_get_boolean_status_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_boolean_status_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_boolean_status_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_boolean_status_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_boolean_status_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_boolean_status_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required bool value = 2;
inline bool fmi2_import_get_boolean_status_res::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_boolean_status_res::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_boolean_status_res::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_boolean_status_res::clear_value() {
  value_ = false;
  clear_has_value();
}
inline bool fmi2_import_get_boolean_status_res::value() const {
  return value_;
}
inline void fmi2_import_get_boolean_status_res::set_value(bool value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_string_status_req

// required int32 message_id = 1;
inline bool fmi2_import_get_string_status_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_string_status_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_string_status_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_string_status_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_string_status_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_string_status_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_get_string_status_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_string_status_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_string_status_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_string_status_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_get_string_status_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_get_string_status_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// required .fmitcp_proto.fmi2_status_kind_t kind = 3;
inline bool fmi2_import_get_string_status_req::has_kind() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_get_string_status_req::set_has_kind() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_get_string_status_req::clear_has_kind() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_get_string_status_req::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::fmitcp_proto::fmi2_status_kind_t fmi2_import_get_string_status_req::kind() const {
  return static_cast< ::fmitcp_proto::fmi2_status_kind_t >(kind_);
}
inline void fmi2_import_get_string_status_req::set_kind(::fmitcp_proto::fmi2_status_kind_t value) {
  assert(::fmitcp_proto::fmi2_status_kind_t_IsValid(value));
  set_has_kind();
  kind_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_string_status_res

// required int32 message_id = 1;
inline bool fmi2_import_get_string_status_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_string_status_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_string_status_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_string_status_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_string_status_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_string_status_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required string value = 2;
inline bool fmi2_import_get_string_status_res::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_string_status_res::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_string_status_res::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_string_status_res::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& fmi2_import_get_string_status_res::value() const {
  return *value_;
}
inline void fmi2_import_get_string_status_res::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void fmi2_import_get_string_status_res::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void fmi2_import_get_string_status_res::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fmi2_import_get_string_status_res::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* fmi2_import_get_string_status_res::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void fmi2_import_get_string_status_res::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// fmi2_import_instantiate_model_req

// required int32 message_id = 1;
inline bool fmi2_import_instantiate_model_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_instantiate_model_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_instantiate_model_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_instantiate_model_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_instantiate_model_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_instantiate_model_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_instantiate_model_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_instantiate_model_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_instantiate_model_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_instantiate_model_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_instantiate_model_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_instantiate_model_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// required string instanceName = 3;
inline bool fmi2_import_instantiate_model_req::has_instancename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_instantiate_model_req::set_has_instancename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_instantiate_model_req::clear_has_instancename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_instantiate_model_req::clear_instancename() {
  if (instancename_ != &::google::protobuf::internal::kEmptyString) {
    instancename_->clear();
  }
  clear_has_instancename();
}
inline const ::std::string& fmi2_import_instantiate_model_req::instancename() const {
  return *instancename_;
}
inline void fmi2_import_instantiate_model_req::set_instancename(const ::std::string& value) {
  set_has_instancename();
  if (instancename_ == &::google::protobuf::internal::kEmptyString) {
    instancename_ = new ::std::string;
  }
  instancename_->assign(value);
}
inline void fmi2_import_instantiate_model_req::set_instancename(const char* value) {
  set_has_instancename();
  if (instancename_ == &::google::protobuf::internal::kEmptyString) {
    instancename_ = new ::std::string;
  }
  instancename_->assign(value);
}
inline void fmi2_import_instantiate_model_req::set_instancename(const char* value, size_t size) {
  set_has_instancename();
  if (instancename_ == &::google::protobuf::internal::kEmptyString) {
    instancename_ = new ::std::string;
  }
  instancename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fmi2_import_instantiate_model_req::mutable_instancename() {
  set_has_instancename();
  if (instancename_ == &::google::protobuf::internal::kEmptyString) {
    instancename_ = new ::std::string;
  }
  return instancename_;
}
inline ::std::string* fmi2_import_instantiate_model_req::release_instancename() {
  clear_has_instancename();
  if (instancename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instancename_;
    instancename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void fmi2_import_instantiate_model_req::set_allocated_instancename(::std::string* instancename) {
  if (instancename_ != &::google::protobuf::internal::kEmptyString) {
    delete instancename_;
  }
  if (instancename) {
    set_has_instancename();
    instancename_ = instancename;
  } else {
    clear_has_instancename();
    instancename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string resourceLocation = 4;
inline bool fmi2_import_instantiate_model_req::has_resourcelocation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fmi2_import_instantiate_model_req::set_has_resourcelocation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fmi2_import_instantiate_model_req::clear_has_resourcelocation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fmi2_import_instantiate_model_req::clear_resourcelocation() {
  if (resourcelocation_ != &::google::protobuf::internal::kEmptyString) {
    resourcelocation_->clear();
  }
  clear_has_resourcelocation();
}
inline const ::std::string& fmi2_import_instantiate_model_req::resourcelocation() const {
  return *resourcelocation_;
}
inline void fmi2_import_instantiate_model_req::set_resourcelocation(const ::std::string& value) {
  set_has_resourcelocation();
  if (resourcelocation_ == &::google::protobuf::internal::kEmptyString) {
    resourcelocation_ = new ::std::string;
  }
  resourcelocation_->assign(value);
}
inline void fmi2_import_instantiate_model_req::set_resourcelocation(const char* value) {
  set_has_resourcelocation();
  if (resourcelocation_ == &::google::protobuf::internal::kEmptyString) {
    resourcelocation_ = new ::std::string;
  }
  resourcelocation_->assign(value);
}
inline void fmi2_import_instantiate_model_req::set_resourcelocation(const char* value, size_t size) {
  set_has_resourcelocation();
  if (resourcelocation_ == &::google::protobuf::internal::kEmptyString) {
    resourcelocation_ = new ::std::string;
  }
  resourcelocation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fmi2_import_instantiate_model_req::mutable_resourcelocation() {
  set_has_resourcelocation();
  if (resourcelocation_ == &::google::protobuf::internal::kEmptyString) {
    resourcelocation_ = new ::std::string;
  }
  return resourcelocation_;
}
inline ::std::string* fmi2_import_instantiate_model_req::release_resourcelocation() {
  clear_has_resourcelocation();
  if (resourcelocation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resourcelocation_;
    resourcelocation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void fmi2_import_instantiate_model_req::set_allocated_resourcelocation(::std::string* resourcelocation) {
  if (resourcelocation_ != &::google::protobuf::internal::kEmptyString) {
    delete resourcelocation_;
  }
  if (resourcelocation) {
    set_has_resourcelocation();
    resourcelocation_ = resourcelocation;
  } else {
    clear_has_resourcelocation();
    resourcelocation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool visible = 5;
inline bool fmi2_import_instantiate_model_req::has_visible() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fmi2_import_instantiate_model_req::set_has_visible() {
  _has_bits_[0] |= 0x00000010u;
}
inline void fmi2_import_instantiate_model_req::clear_has_visible() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void fmi2_import_instantiate_model_req::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool fmi2_import_instantiate_model_req::visible() const {
  return visible_;
}
inline void fmi2_import_instantiate_model_req::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_instantiate_model_res

// required int32 message_id = 1;
inline bool fmi2_import_instantiate_model_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_instantiate_model_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_instantiate_model_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_instantiate_model_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_instantiate_model_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_instantiate_model_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.jm_status_enu_t status = 2;
inline bool fmi2_import_instantiate_model_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_instantiate_model_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_instantiate_model_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_instantiate_model_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::jm_status_enu_t fmi2_import_instantiate_model_res::status() const {
  return static_cast< ::fmitcp_proto::jm_status_enu_t >(status_);
}
inline void fmi2_import_instantiate_model_res::set_status(::fmitcp_proto::jm_status_enu_t value) {
  assert(::fmitcp_proto::jm_status_enu_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_free_model_instance_req

// required int32 message_id = 1;
inline bool fmi2_import_free_model_instance_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_free_model_instance_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_free_model_instance_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_free_model_instance_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_free_model_instance_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_free_model_instance_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_free_model_instance_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_free_model_instance_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_free_model_instance_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_free_model_instance_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_free_model_instance_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_free_model_instance_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_free_model_instance_res

// required int32 message_id = 1;
inline bool fmi2_import_free_model_instance_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_free_model_instance_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_free_model_instance_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_free_model_instance_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_free_model_instance_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_free_model_instance_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_set_time_req

// required int32 message_id = 1;
inline bool fmi2_import_set_time_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_set_time_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_set_time_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_set_time_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_set_time_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_set_time_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_set_time_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_set_time_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_set_time_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_set_time_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_set_time_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_set_time_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// required double time = 3;
inline bool fmi2_import_set_time_req::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_set_time_req::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_set_time_req::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_set_time_req::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double fmi2_import_set_time_req::time() const {
  return time_;
}
inline void fmi2_import_set_time_req::set_time(double value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_set_time_res

// required int32 message_id = 1;
inline bool fmi2_import_set_time_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_set_time_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_set_time_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_set_time_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_set_time_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_set_time_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 2;
inline bool fmi2_import_set_time_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_set_time_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_set_time_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_set_time_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_set_time_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_set_time_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_set_continuous_states_req

// required int32 message_id = 1;
inline bool fmi2_import_set_continuous_states_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_set_continuous_states_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_set_continuous_states_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_set_continuous_states_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_set_continuous_states_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_set_continuous_states_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_set_continuous_states_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_set_continuous_states_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_set_continuous_states_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_set_continuous_states_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_set_continuous_states_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_set_continuous_states_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// repeated double x = 3 [packed = true];
inline int fmi2_import_set_continuous_states_req::x_size() const {
  return x_.size();
}
inline void fmi2_import_set_continuous_states_req::clear_x() {
  x_.Clear();
}
inline double fmi2_import_set_continuous_states_req::x(int index) const {
  return x_.Get(index);
}
inline void fmi2_import_set_continuous_states_req::set_x(int index, double value) {
  x_.Set(index, value);
}
inline void fmi2_import_set_continuous_states_req::add_x(double value) {
  x_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fmi2_import_set_continuous_states_req::x() const {
  return x_;
}
inline ::google::protobuf::RepeatedField< double >*
fmi2_import_set_continuous_states_req::mutable_x() {
  return &x_;
}

// -------------------------------------------------------------------

// fmi2_import_set_continuous_states_res

// required int32 message_id = 1;
inline bool fmi2_import_set_continuous_states_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_set_continuous_states_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_set_continuous_states_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_set_continuous_states_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_set_continuous_states_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_set_continuous_states_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 2;
inline bool fmi2_import_set_continuous_states_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_set_continuous_states_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_set_continuous_states_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_set_continuous_states_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_set_continuous_states_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_set_continuous_states_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_completed_integrator_step_req

// required int32 message_id = 1;
inline bool fmi2_import_completed_integrator_step_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_completed_integrator_step_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_completed_integrator_step_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_completed_integrator_step_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_completed_integrator_step_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_completed_integrator_step_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_completed_integrator_step_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_completed_integrator_step_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_completed_integrator_step_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_completed_integrator_step_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_completed_integrator_step_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_completed_integrator_step_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_completed_integrator_step_res

// required int32 message_id = 1;
inline bool fmi2_import_completed_integrator_step_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_completed_integrator_step_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_completed_integrator_step_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_completed_integrator_step_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_completed_integrator_step_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_completed_integrator_step_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required bool callEventUpdate = 2;
inline bool fmi2_import_completed_integrator_step_res::has_calleventupdate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_completed_integrator_step_res::set_has_calleventupdate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_completed_integrator_step_res::clear_has_calleventupdate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_completed_integrator_step_res::clear_calleventupdate() {
  calleventupdate_ = false;
  clear_has_calleventupdate();
}
inline bool fmi2_import_completed_integrator_step_res::calleventupdate() const {
  return calleventupdate_;
}
inline void fmi2_import_completed_integrator_step_res::set_calleventupdate(bool value) {
  set_has_calleventupdate();
  calleventupdate_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 3;
inline bool fmi2_import_completed_integrator_step_res::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_completed_integrator_step_res::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_completed_integrator_step_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_completed_integrator_step_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_completed_integrator_step_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_completed_integrator_step_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_initialize_model_req

// required int32 message_id = 1;
inline bool fmi2_import_initialize_model_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_initialize_model_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_initialize_model_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_initialize_model_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_initialize_model_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_initialize_model_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_initialize_model_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_initialize_model_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_initialize_model_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_initialize_model_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_initialize_model_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_initialize_model_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// required bool toleranceControlled = 3;
inline bool fmi2_import_initialize_model_req::has_tolerancecontrolled() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_initialize_model_req::set_has_tolerancecontrolled() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_initialize_model_req::clear_has_tolerancecontrolled() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_initialize_model_req::clear_tolerancecontrolled() {
  tolerancecontrolled_ = false;
  clear_has_tolerancecontrolled();
}
inline bool fmi2_import_initialize_model_req::tolerancecontrolled() const {
  return tolerancecontrolled_;
}
inline void fmi2_import_initialize_model_req::set_tolerancecontrolled(bool value) {
  set_has_tolerancecontrolled();
  tolerancecontrolled_ = value;
}

// required double relativeTolerance = 4;
inline bool fmi2_import_initialize_model_req::has_relativetolerance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fmi2_import_initialize_model_req::set_has_relativetolerance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fmi2_import_initialize_model_req::clear_has_relativetolerance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fmi2_import_initialize_model_req::clear_relativetolerance() {
  relativetolerance_ = 0;
  clear_has_relativetolerance();
}
inline double fmi2_import_initialize_model_req::relativetolerance() const {
  return relativetolerance_;
}
inline void fmi2_import_initialize_model_req::set_relativetolerance(double value) {
  set_has_relativetolerance();
  relativetolerance_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_initialize_model_res

// required int32 message_id = 1;
inline bool fmi2_import_initialize_model_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_initialize_model_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_initialize_model_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_initialize_model_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_initialize_model_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_initialize_model_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_event_info_t eventInfo = 2;
inline bool fmi2_import_initialize_model_res::has_eventinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_initialize_model_res::set_has_eventinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_initialize_model_res::clear_has_eventinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_initialize_model_res::clear_eventinfo() {
  if (eventinfo_ != NULL) eventinfo_->::fmitcp_proto::fmi2_event_info_t::Clear();
  clear_has_eventinfo();
}
inline const ::fmitcp_proto::fmi2_event_info_t& fmi2_import_initialize_model_res::eventinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return eventinfo_ != NULL ? *eventinfo_ : *default_instance().eventinfo_;
#else
  return eventinfo_ != NULL ? *eventinfo_ : *default_instance_->eventinfo_;
#endif
}
inline ::fmitcp_proto::fmi2_event_info_t* fmi2_import_initialize_model_res::mutable_eventinfo() {
  set_has_eventinfo();
  if (eventinfo_ == NULL) eventinfo_ = new ::fmitcp_proto::fmi2_event_info_t;
  return eventinfo_;
}
inline ::fmitcp_proto::fmi2_event_info_t* fmi2_import_initialize_model_res::release_eventinfo() {
  clear_has_eventinfo();
  ::fmitcp_proto::fmi2_event_info_t* temp = eventinfo_;
  eventinfo_ = NULL;
  return temp;
}
inline void fmi2_import_initialize_model_res::set_allocated_eventinfo(::fmitcp_proto::fmi2_event_info_t* eventinfo) {
  delete eventinfo_;
  eventinfo_ = eventinfo;
  if (eventinfo) {
    set_has_eventinfo();
  } else {
    clear_has_eventinfo();
  }
}

// required .fmitcp_proto.fmi2_status_t status = 3;
inline bool fmi2_import_initialize_model_res::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_initialize_model_res::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_initialize_model_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_initialize_model_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_initialize_model_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_initialize_model_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_derivatives_req

// required int32 message_id = 1;
inline bool fmi2_import_get_derivatives_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_derivatives_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_derivatives_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_derivatives_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_derivatives_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_derivatives_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_get_derivatives_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_derivatives_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_derivatives_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_derivatives_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_get_derivatives_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_get_derivatives_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_derivatives_res

// required int32 message_id = 1;
inline bool fmi2_import_get_derivatives_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_derivatives_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_derivatives_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_derivatives_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_derivatives_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_derivatives_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// repeated double derivatives = 2 [packed = true];
inline int fmi2_import_get_derivatives_res::derivatives_size() const {
  return derivatives_.size();
}
inline void fmi2_import_get_derivatives_res::clear_derivatives() {
  derivatives_.Clear();
}
inline double fmi2_import_get_derivatives_res::derivatives(int index) const {
  return derivatives_.Get(index);
}
inline void fmi2_import_get_derivatives_res::set_derivatives(int index, double value) {
  derivatives_.Set(index, value);
}
inline void fmi2_import_get_derivatives_res::add_derivatives(double value) {
  derivatives_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fmi2_import_get_derivatives_res::derivatives() const {
  return derivatives_;
}
inline ::google::protobuf::RepeatedField< double >*
fmi2_import_get_derivatives_res::mutable_derivatives() {
  return &derivatives_;
}

// required .fmitcp_proto.fmi2_status_t status = 3;
inline bool fmi2_import_get_derivatives_res::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_get_derivatives_res::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_get_derivatives_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_get_derivatives_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_get_derivatives_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_get_derivatives_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_event_indicators_req

// required int32 message_id = 1;
inline bool fmi2_import_get_event_indicators_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_event_indicators_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_event_indicators_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_event_indicators_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_event_indicators_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_event_indicators_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_get_event_indicators_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_event_indicators_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_event_indicators_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_event_indicators_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_get_event_indicators_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_get_event_indicators_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_event_indicators_res

// required int32 message_id = 1;
inline bool fmi2_import_get_event_indicators_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_event_indicators_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_event_indicators_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_event_indicators_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_event_indicators_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_event_indicators_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// repeated double eventIndicators = 2 [packed = true];
inline int fmi2_import_get_event_indicators_res::eventindicators_size() const {
  return eventindicators_.size();
}
inline void fmi2_import_get_event_indicators_res::clear_eventindicators() {
  eventindicators_.Clear();
}
inline double fmi2_import_get_event_indicators_res::eventindicators(int index) const {
  return eventindicators_.Get(index);
}
inline void fmi2_import_get_event_indicators_res::set_eventindicators(int index, double value) {
  eventindicators_.Set(index, value);
}
inline void fmi2_import_get_event_indicators_res::add_eventindicators(double value) {
  eventindicators_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fmi2_import_get_event_indicators_res::eventindicators() const {
  return eventindicators_;
}
inline ::google::protobuf::RepeatedField< double >*
fmi2_import_get_event_indicators_res::mutable_eventindicators() {
  return &eventindicators_;
}

// required .fmitcp_proto.fmi2_status_t status = 3;
inline bool fmi2_import_get_event_indicators_res::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_get_event_indicators_res::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_get_event_indicators_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_get_event_indicators_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_get_event_indicators_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_get_event_indicators_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_eventUpdate_req

// required int32 message_id = 1;
inline bool fmi2_import_eventUpdate_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_eventUpdate_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_eventUpdate_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_eventUpdate_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_eventUpdate_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_eventUpdate_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_eventUpdate_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_eventUpdate_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_eventUpdate_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_eventUpdate_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_eventUpdate_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_eventUpdate_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// required bool intermediateResults = 3;
inline bool fmi2_import_eventUpdate_req::has_intermediateresults() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_eventUpdate_req::set_has_intermediateresults() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_eventUpdate_req::clear_has_intermediateresults() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_eventUpdate_req::clear_intermediateresults() {
  intermediateresults_ = false;
  clear_has_intermediateresults();
}
inline bool fmi2_import_eventUpdate_req::intermediateresults() const {
  return intermediateresults_;
}
inline void fmi2_import_eventUpdate_req::set_intermediateresults(bool value) {
  set_has_intermediateresults();
  intermediateresults_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_eventUpdate_res

// required int32 message_id = 1;
inline bool fmi2_import_eventUpdate_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_eventUpdate_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_eventUpdate_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_eventUpdate_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_eventUpdate_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_eventUpdate_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_event_info_t eventInfo = 2;
inline bool fmi2_import_eventUpdate_res::has_eventinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_eventUpdate_res::set_has_eventinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_eventUpdate_res::clear_has_eventinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_eventUpdate_res::clear_eventinfo() {
  if (eventinfo_ != NULL) eventinfo_->::fmitcp_proto::fmi2_event_info_t::Clear();
  clear_has_eventinfo();
}
inline const ::fmitcp_proto::fmi2_event_info_t& fmi2_import_eventUpdate_res::eventinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return eventinfo_ != NULL ? *eventinfo_ : *default_instance().eventinfo_;
#else
  return eventinfo_ != NULL ? *eventinfo_ : *default_instance_->eventinfo_;
#endif
}
inline ::fmitcp_proto::fmi2_event_info_t* fmi2_import_eventUpdate_res::mutable_eventinfo() {
  set_has_eventinfo();
  if (eventinfo_ == NULL) eventinfo_ = new ::fmitcp_proto::fmi2_event_info_t;
  return eventinfo_;
}
inline ::fmitcp_proto::fmi2_event_info_t* fmi2_import_eventUpdate_res::release_eventinfo() {
  clear_has_eventinfo();
  ::fmitcp_proto::fmi2_event_info_t* temp = eventinfo_;
  eventinfo_ = NULL;
  return temp;
}
inline void fmi2_import_eventUpdate_res::set_allocated_eventinfo(::fmitcp_proto::fmi2_event_info_t* eventinfo) {
  delete eventinfo_;
  eventinfo_ = eventinfo;
  if (eventinfo) {
    set_has_eventinfo();
  } else {
    clear_has_eventinfo();
  }
}

// required .fmitcp_proto.fmi2_status_t status = 3;
inline bool fmi2_import_eventUpdate_res::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_eventUpdate_res::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_eventUpdate_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_eventUpdate_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_eventUpdate_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_eventUpdate_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_completed_event_iteration_req

// required int32 message_id = 1;
inline bool fmi2_import_completed_event_iteration_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_completed_event_iteration_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_completed_event_iteration_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_completed_event_iteration_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_completed_event_iteration_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_completed_event_iteration_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_completed_event_iteration_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_completed_event_iteration_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_completed_event_iteration_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_completed_event_iteration_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_completed_event_iteration_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_completed_event_iteration_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_completed_event_iteration_res

// required int32 message_id = 1;
inline bool fmi2_import_completed_event_iteration_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_completed_event_iteration_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_completed_event_iteration_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_completed_event_iteration_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_completed_event_iteration_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_completed_event_iteration_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 2;
inline bool fmi2_import_completed_event_iteration_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_completed_event_iteration_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_completed_event_iteration_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_completed_event_iteration_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_completed_event_iteration_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_completed_event_iteration_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_continuous_states_req

// required int32 message_id = 1;
inline bool fmi2_import_get_continuous_states_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_continuous_states_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_continuous_states_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_continuous_states_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_continuous_states_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_continuous_states_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_get_continuous_states_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_continuous_states_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_continuous_states_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_continuous_states_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_get_continuous_states_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_get_continuous_states_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_continuous_states_res

// required int32 message_id = 1;
inline bool fmi2_import_get_continuous_states_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_continuous_states_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_continuous_states_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_continuous_states_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_continuous_states_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_continuous_states_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// repeated double states = 2 [packed = true];
inline int fmi2_import_get_continuous_states_res::states_size() const {
  return states_.size();
}
inline void fmi2_import_get_continuous_states_res::clear_states() {
  states_.Clear();
}
inline double fmi2_import_get_continuous_states_res::states(int index) const {
  return states_.Get(index);
}
inline void fmi2_import_get_continuous_states_res::set_states(int index, double value) {
  states_.Set(index, value);
}
inline void fmi2_import_get_continuous_states_res::add_states(double value) {
  states_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fmi2_import_get_continuous_states_res::states() const {
  return states_;
}
inline ::google::protobuf::RepeatedField< double >*
fmi2_import_get_continuous_states_res::mutable_states() {
  return &states_;
}

// required .fmitcp_proto.fmi2_status_t status = 3;
inline bool fmi2_import_get_continuous_states_res::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_get_continuous_states_res::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_get_continuous_states_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_get_continuous_states_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_get_continuous_states_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_get_continuous_states_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_nominal_continuous_states_req

// required int32 message_id = 1;
inline bool fmi2_import_get_nominal_continuous_states_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_nominal_continuous_states_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_nominal_continuous_states_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_nominal_continuous_states_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_nominal_continuous_states_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_nominal_continuous_states_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_get_nominal_continuous_states_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_nominal_continuous_states_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_nominal_continuous_states_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_nominal_continuous_states_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_get_nominal_continuous_states_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_get_nominal_continuous_states_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_nominal_continuous_states_res

// required int32 message_id = 1;
inline bool fmi2_import_get_nominal_continuous_states_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_nominal_continuous_states_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_nominal_continuous_states_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_nominal_continuous_states_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_nominal_continuous_states_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_nominal_continuous_states_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// repeated double nominal = 2 [packed = true];
inline int fmi2_import_get_nominal_continuous_states_res::nominal_size() const {
  return nominal_.size();
}
inline void fmi2_import_get_nominal_continuous_states_res::clear_nominal() {
  nominal_.Clear();
}
inline double fmi2_import_get_nominal_continuous_states_res::nominal(int index) const {
  return nominal_.Get(index);
}
inline void fmi2_import_get_nominal_continuous_states_res::set_nominal(int index, double value) {
  nominal_.Set(index, value);
}
inline void fmi2_import_get_nominal_continuous_states_res::add_nominal(double value) {
  nominal_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fmi2_import_get_nominal_continuous_states_res::nominal() const {
  return nominal_;
}
inline ::google::protobuf::RepeatedField< double >*
fmi2_import_get_nominal_continuous_states_res::mutable_nominal() {
  return &nominal_;
}

// required .fmitcp_proto.fmi2_status_t status = 3;
inline bool fmi2_import_get_nominal_continuous_states_res::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_get_nominal_continuous_states_res::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_get_nominal_continuous_states_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_get_nominal_continuous_states_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_get_nominal_continuous_states_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_get_nominal_continuous_states_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_terminate_req

// required int32 message_id = 1;
inline bool fmi2_import_terminate_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_terminate_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_terminate_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_terminate_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_terminate_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_terminate_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_terminate_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_terminate_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_terminate_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_terminate_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_terminate_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_terminate_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_terminate_res

// required int32 message_id = 1;
inline bool fmi2_import_terminate_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_terminate_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_terminate_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_terminate_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_terminate_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_terminate_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 2;
inline bool fmi2_import_terminate_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_terminate_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_terminate_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_terminate_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_terminate_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_terminate_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_version_req

// required int32 message_id = 1;
inline bool fmi2_import_get_version_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_version_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_version_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_version_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_version_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_version_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_get_version_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_version_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_version_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_version_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_get_version_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_get_version_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_version_res

// required int32 message_id = 1;
inline bool fmi2_import_get_version_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_version_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_version_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_version_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_version_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_version_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required string version = 2;
inline bool fmi2_import_get_version_res::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_version_res::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_version_res::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_version_res::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& fmi2_import_get_version_res::version() const {
  return *version_;
}
inline void fmi2_import_get_version_res::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void fmi2_import_get_version_res::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void fmi2_import_get_version_res::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fmi2_import_get_version_res::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* fmi2_import_get_version_res::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void fmi2_import_get_version_res::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// fmi2_import_set_debug_logging_req

// required int32 message_id = 1;
inline bool fmi2_import_set_debug_logging_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_set_debug_logging_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_set_debug_logging_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_set_debug_logging_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_set_debug_logging_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_set_debug_logging_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_set_debug_logging_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_set_debug_logging_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_set_debug_logging_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_set_debug_logging_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_set_debug_logging_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_set_debug_logging_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// required bool loggingOn = 3;
inline bool fmi2_import_set_debug_logging_req::has_loggingon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_set_debug_logging_req::set_has_loggingon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_set_debug_logging_req::clear_has_loggingon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_set_debug_logging_req::clear_loggingon() {
  loggingon_ = false;
  clear_has_loggingon();
}
inline bool fmi2_import_set_debug_logging_req::loggingon() const {
  return loggingon_;
}
inline void fmi2_import_set_debug_logging_req::set_loggingon(bool value) {
  set_has_loggingon();
  loggingon_ = value;
}

// repeated string categories = 4;
inline int fmi2_import_set_debug_logging_req::categories_size() const {
  return categories_.size();
}
inline void fmi2_import_set_debug_logging_req::clear_categories() {
  categories_.Clear();
}
inline const ::std::string& fmi2_import_set_debug_logging_req::categories(int index) const {
  return categories_.Get(index);
}
inline ::std::string* fmi2_import_set_debug_logging_req::mutable_categories(int index) {
  return categories_.Mutable(index);
}
inline void fmi2_import_set_debug_logging_req::set_categories(int index, const ::std::string& value) {
  categories_.Mutable(index)->assign(value);
}
inline void fmi2_import_set_debug_logging_req::set_categories(int index, const char* value) {
  categories_.Mutable(index)->assign(value);
}
inline void fmi2_import_set_debug_logging_req::set_categories(int index, const char* value, size_t size) {
  categories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fmi2_import_set_debug_logging_req::add_categories() {
  return categories_.Add();
}
inline void fmi2_import_set_debug_logging_req::add_categories(const ::std::string& value) {
  categories_.Add()->assign(value);
}
inline void fmi2_import_set_debug_logging_req::add_categories(const char* value) {
  categories_.Add()->assign(value);
}
inline void fmi2_import_set_debug_logging_req::add_categories(const char* value, size_t size) {
  categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
fmi2_import_set_debug_logging_req::categories() const {
  return categories_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
fmi2_import_set_debug_logging_req::mutable_categories() {
  return &categories_;
}

// -------------------------------------------------------------------

// fmi2_import_set_debug_logging_res

// required int32 message_id = 1;
inline bool fmi2_import_set_debug_logging_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_set_debug_logging_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_set_debug_logging_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_set_debug_logging_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_set_debug_logging_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_set_debug_logging_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 2;
inline bool fmi2_import_set_debug_logging_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_set_debug_logging_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_set_debug_logging_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_set_debug_logging_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_set_debug_logging_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_set_debug_logging_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_set_real_req

// required int32 message_id = 1;
inline bool fmi2_import_set_real_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_set_real_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_set_real_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_set_real_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_set_real_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_set_real_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_set_real_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_set_real_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_set_real_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_set_real_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_set_real_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_set_real_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// repeated int32 valueReferences = 3 [packed = true];
inline int fmi2_import_set_real_req::valuereferences_size() const {
  return valuereferences_.size();
}
inline void fmi2_import_set_real_req::clear_valuereferences() {
  valuereferences_.Clear();
}
inline ::google::protobuf::int32 fmi2_import_set_real_req::valuereferences(int index) const {
  return valuereferences_.Get(index);
}
inline void fmi2_import_set_real_req::set_valuereferences(int index, ::google::protobuf::int32 value) {
  valuereferences_.Set(index, value);
}
inline void fmi2_import_set_real_req::add_valuereferences(::google::protobuf::int32 value) {
  valuereferences_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
fmi2_import_set_real_req::valuereferences() const {
  return valuereferences_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
fmi2_import_set_real_req::mutable_valuereferences() {
  return &valuereferences_;
}

// repeated double values = 4 [packed = true];
inline int fmi2_import_set_real_req::values_size() const {
  return values_.size();
}
inline void fmi2_import_set_real_req::clear_values() {
  values_.Clear();
}
inline double fmi2_import_set_real_req::values(int index) const {
  return values_.Get(index);
}
inline void fmi2_import_set_real_req::set_values(int index, double value) {
  values_.Set(index, value);
}
inline void fmi2_import_set_real_req::add_values(double value) {
  values_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fmi2_import_set_real_req::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedField< double >*
fmi2_import_set_real_req::mutable_values() {
  return &values_;
}

// -------------------------------------------------------------------

// fmi2_import_set_real_res

// required int32 message_id = 1;
inline bool fmi2_import_set_real_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_set_real_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_set_real_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_set_real_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_set_real_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_set_real_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 2;
inline bool fmi2_import_set_real_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_set_real_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_set_real_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_set_real_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_set_real_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_set_real_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_set_integer_req

// required int32 message_id = 1;
inline bool fmi2_import_set_integer_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_set_integer_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_set_integer_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_set_integer_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_set_integer_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_set_integer_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_set_integer_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_set_integer_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_set_integer_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_set_integer_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_set_integer_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_set_integer_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// repeated int32 valueReferences = 3 [packed = true];
inline int fmi2_import_set_integer_req::valuereferences_size() const {
  return valuereferences_.size();
}
inline void fmi2_import_set_integer_req::clear_valuereferences() {
  valuereferences_.Clear();
}
inline ::google::protobuf::int32 fmi2_import_set_integer_req::valuereferences(int index) const {
  return valuereferences_.Get(index);
}
inline void fmi2_import_set_integer_req::set_valuereferences(int index, ::google::protobuf::int32 value) {
  valuereferences_.Set(index, value);
}
inline void fmi2_import_set_integer_req::add_valuereferences(::google::protobuf::int32 value) {
  valuereferences_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
fmi2_import_set_integer_req::valuereferences() const {
  return valuereferences_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
fmi2_import_set_integer_req::mutable_valuereferences() {
  return &valuereferences_;
}

// repeated int32 values = 4 [packed = true];
inline int fmi2_import_set_integer_req::values_size() const {
  return values_.size();
}
inline void fmi2_import_set_integer_req::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::int32 fmi2_import_set_integer_req::values(int index) const {
  return values_.Get(index);
}
inline void fmi2_import_set_integer_req::set_values(int index, ::google::protobuf::int32 value) {
  values_.Set(index, value);
}
inline void fmi2_import_set_integer_req::add_values(::google::protobuf::int32 value) {
  values_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
fmi2_import_set_integer_req::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
fmi2_import_set_integer_req::mutable_values() {
  return &values_;
}

// -------------------------------------------------------------------

// fmi2_import_set_integer_res

// required int32 message_id = 1;
inline bool fmi2_import_set_integer_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_set_integer_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_set_integer_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_set_integer_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_set_integer_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_set_integer_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 2;
inline bool fmi2_import_set_integer_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_set_integer_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_set_integer_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_set_integer_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_set_integer_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_set_integer_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_set_boolean_req

// required int32 message_id = 1;
inline bool fmi2_import_set_boolean_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_set_boolean_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_set_boolean_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_set_boolean_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_set_boolean_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_set_boolean_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_set_boolean_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_set_boolean_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_set_boolean_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_set_boolean_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_set_boolean_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_set_boolean_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// repeated int32 valueReferences = 3 [packed = true];
inline int fmi2_import_set_boolean_req::valuereferences_size() const {
  return valuereferences_.size();
}
inline void fmi2_import_set_boolean_req::clear_valuereferences() {
  valuereferences_.Clear();
}
inline ::google::protobuf::int32 fmi2_import_set_boolean_req::valuereferences(int index) const {
  return valuereferences_.Get(index);
}
inline void fmi2_import_set_boolean_req::set_valuereferences(int index, ::google::protobuf::int32 value) {
  valuereferences_.Set(index, value);
}
inline void fmi2_import_set_boolean_req::add_valuereferences(::google::protobuf::int32 value) {
  valuereferences_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
fmi2_import_set_boolean_req::valuereferences() const {
  return valuereferences_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
fmi2_import_set_boolean_req::mutable_valuereferences() {
  return &valuereferences_;
}

// repeated bool values = 4 [packed = true];
inline int fmi2_import_set_boolean_req::values_size() const {
  return values_.size();
}
inline void fmi2_import_set_boolean_req::clear_values() {
  values_.Clear();
}
inline bool fmi2_import_set_boolean_req::values(int index) const {
  return values_.Get(index);
}
inline void fmi2_import_set_boolean_req::set_values(int index, bool value) {
  values_.Set(index, value);
}
inline void fmi2_import_set_boolean_req::add_values(bool value) {
  values_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
fmi2_import_set_boolean_req::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedField< bool >*
fmi2_import_set_boolean_req::mutable_values() {
  return &values_;
}

// -------------------------------------------------------------------

// fmi2_import_set_boolean_res

// required int32 message_id = 1;
inline bool fmi2_import_set_boolean_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_set_boolean_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_set_boolean_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_set_boolean_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_set_boolean_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_set_boolean_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 2;
inline bool fmi2_import_set_boolean_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_set_boolean_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_set_boolean_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_set_boolean_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_set_boolean_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_set_boolean_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_set_string_req

// required int32 message_id = 1;
inline bool fmi2_import_set_string_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_set_string_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_set_string_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_set_string_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_set_string_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_set_string_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_set_string_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_set_string_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_set_string_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_set_string_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_set_string_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_set_string_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// repeated int32 valueReferences = 3 [packed = true];
inline int fmi2_import_set_string_req::valuereferences_size() const {
  return valuereferences_.size();
}
inline void fmi2_import_set_string_req::clear_valuereferences() {
  valuereferences_.Clear();
}
inline ::google::protobuf::int32 fmi2_import_set_string_req::valuereferences(int index) const {
  return valuereferences_.Get(index);
}
inline void fmi2_import_set_string_req::set_valuereferences(int index, ::google::protobuf::int32 value) {
  valuereferences_.Set(index, value);
}
inline void fmi2_import_set_string_req::add_valuereferences(::google::protobuf::int32 value) {
  valuereferences_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
fmi2_import_set_string_req::valuereferences() const {
  return valuereferences_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
fmi2_import_set_string_req::mutable_valuereferences() {
  return &valuereferences_;
}

// repeated string values = 4;
inline int fmi2_import_set_string_req::values_size() const {
  return values_.size();
}
inline void fmi2_import_set_string_req::clear_values() {
  values_.Clear();
}
inline const ::std::string& fmi2_import_set_string_req::values(int index) const {
  return values_.Get(index);
}
inline ::std::string* fmi2_import_set_string_req::mutable_values(int index) {
  return values_.Mutable(index);
}
inline void fmi2_import_set_string_req::set_values(int index, const ::std::string& value) {
  values_.Mutable(index)->assign(value);
}
inline void fmi2_import_set_string_req::set_values(int index, const char* value) {
  values_.Mutable(index)->assign(value);
}
inline void fmi2_import_set_string_req::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fmi2_import_set_string_req::add_values() {
  return values_.Add();
}
inline void fmi2_import_set_string_req::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
}
inline void fmi2_import_set_string_req::add_values(const char* value) {
  values_.Add()->assign(value);
}
inline void fmi2_import_set_string_req::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
fmi2_import_set_string_req::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
fmi2_import_set_string_req::mutable_values() {
  return &values_;
}

// -------------------------------------------------------------------

// fmi2_import_set_string_res

// required int32 message_id = 1;
inline bool fmi2_import_set_string_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_set_string_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_set_string_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_set_string_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_set_string_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_set_string_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 2;
inline bool fmi2_import_set_string_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_set_string_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_set_string_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_set_string_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_set_string_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_set_string_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_real_req

// required int32 message_id = 1;
inline bool fmi2_import_get_real_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_real_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_real_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_real_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_real_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_real_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_get_real_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_real_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_real_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_real_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_get_real_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_get_real_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// repeated int32 valueReferences = 3 [packed = true];
inline int fmi2_import_get_real_req::valuereferences_size() const {
  return valuereferences_.size();
}
inline void fmi2_import_get_real_req::clear_valuereferences() {
  valuereferences_.Clear();
}
inline ::google::protobuf::int32 fmi2_import_get_real_req::valuereferences(int index) const {
  return valuereferences_.Get(index);
}
inline void fmi2_import_get_real_req::set_valuereferences(int index, ::google::protobuf::int32 value) {
  valuereferences_.Set(index, value);
}
inline void fmi2_import_get_real_req::add_valuereferences(::google::protobuf::int32 value) {
  valuereferences_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
fmi2_import_get_real_req::valuereferences() const {
  return valuereferences_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
fmi2_import_get_real_req::mutable_valuereferences() {
  return &valuereferences_;
}

// -------------------------------------------------------------------

// fmi2_import_get_real_res

// required int32 message_id = 1;
inline bool fmi2_import_get_real_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_real_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_real_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_real_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_real_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_real_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// repeated double values = 2 [packed = true];
inline int fmi2_import_get_real_res::values_size() const {
  return values_.size();
}
inline void fmi2_import_get_real_res::clear_values() {
  values_.Clear();
}
inline double fmi2_import_get_real_res::values(int index) const {
  return values_.Get(index);
}
inline void fmi2_import_get_real_res::set_values(int index, double value) {
  values_.Set(index, value);
}
inline void fmi2_import_get_real_res::add_values(double value) {
  values_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fmi2_import_get_real_res::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedField< double >*
fmi2_import_get_real_res::mutable_values() {
  return &values_;
}

// required .fmitcp_proto.fmi2_status_t status = 3;
inline bool fmi2_import_get_real_res::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_get_real_res::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_get_real_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_get_real_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_get_real_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_get_real_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_integer_req

// required int32 message_id = 1;
inline bool fmi2_import_get_integer_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_integer_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_integer_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_integer_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_integer_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_integer_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_get_integer_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_integer_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_integer_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_integer_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_get_integer_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_get_integer_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// repeated int32 valueReferences = 3 [packed = true];
inline int fmi2_import_get_integer_req::valuereferences_size() const {
  return valuereferences_.size();
}
inline void fmi2_import_get_integer_req::clear_valuereferences() {
  valuereferences_.Clear();
}
inline ::google::protobuf::int32 fmi2_import_get_integer_req::valuereferences(int index) const {
  return valuereferences_.Get(index);
}
inline void fmi2_import_get_integer_req::set_valuereferences(int index, ::google::protobuf::int32 value) {
  valuereferences_.Set(index, value);
}
inline void fmi2_import_get_integer_req::add_valuereferences(::google::protobuf::int32 value) {
  valuereferences_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
fmi2_import_get_integer_req::valuereferences() const {
  return valuereferences_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
fmi2_import_get_integer_req::mutable_valuereferences() {
  return &valuereferences_;
}

// -------------------------------------------------------------------

// fmi2_import_get_integer_res

// required int32 message_id = 1;
inline bool fmi2_import_get_integer_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_integer_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_integer_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_integer_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_integer_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_integer_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// repeated int32 values = 2 [packed = true];
inline int fmi2_import_get_integer_res::values_size() const {
  return values_.size();
}
inline void fmi2_import_get_integer_res::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::int32 fmi2_import_get_integer_res::values(int index) const {
  return values_.Get(index);
}
inline void fmi2_import_get_integer_res::set_values(int index, ::google::protobuf::int32 value) {
  values_.Set(index, value);
}
inline void fmi2_import_get_integer_res::add_values(::google::protobuf::int32 value) {
  values_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
fmi2_import_get_integer_res::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
fmi2_import_get_integer_res::mutable_values() {
  return &values_;
}

// required .fmitcp_proto.fmi2_status_t status = 3;
inline bool fmi2_import_get_integer_res::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_get_integer_res::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_get_integer_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_get_integer_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_get_integer_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_get_integer_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_boolean_req

// required int32 message_id = 1;
inline bool fmi2_import_get_boolean_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_boolean_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_boolean_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_boolean_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_boolean_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_boolean_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_get_boolean_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_boolean_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_boolean_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_boolean_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_get_boolean_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_get_boolean_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// repeated int32 valueReferences = 3 [packed = true];
inline int fmi2_import_get_boolean_req::valuereferences_size() const {
  return valuereferences_.size();
}
inline void fmi2_import_get_boolean_req::clear_valuereferences() {
  valuereferences_.Clear();
}
inline ::google::protobuf::int32 fmi2_import_get_boolean_req::valuereferences(int index) const {
  return valuereferences_.Get(index);
}
inline void fmi2_import_get_boolean_req::set_valuereferences(int index, ::google::protobuf::int32 value) {
  valuereferences_.Set(index, value);
}
inline void fmi2_import_get_boolean_req::add_valuereferences(::google::protobuf::int32 value) {
  valuereferences_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
fmi2_import_get_boolean_req::valuereferences() const {
  return valuereferences_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
fmi2_import_get_boolean_req::mutable_valuereferences() {
  return &valuereferences_;
}

// -------------------------------------------------------------------

// fmi2_import_get_boolean_res

// required int32 message_id = 1;
inline bool fmi2_import_get_boolean_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_boolean_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_boolean_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_boolean_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_boolean_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_boolean_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// repeated bool values = 2 [packed = true];
inline int fmi2_import_get_boolean_res::values_size() const {
  return values_.size();
}
inline void fmi2_import_get_boolean_res::clear_values() {
  values_.Clear();
}
inline bool fmi2_import_get_boolean_res::values(int index) const {
  return values_.Get(index);
}
inline void fmi2_import_get_boolean_res::set_values(int index, bool value) {
  values_.Set(index, value);
}
inline void fmi2_import_get_boolean_res::add_values(bool value) {
  values_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
fmi2_import_get_boolean_res::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedField< bool >*
fmi2_import_get_boolean_res::mutable_values() {
  return &values_;
}

// required .fmitcp_proto.fmi2_status_t status = 3;
inline bool fmi2_import_get_boolean_res::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_get_boolean_res::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_get_boolean_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_get_boolean_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_get_boolean_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_get_boolean_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_string_req

// required int32 message_id = 1;
inline bool fmi2_import_get_string_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_string_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_string_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_string_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_string_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_string_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_get_string_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_string_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_string_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_string_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_get_string_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_get_string_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// repeated int32 valueReferences = 3 [packed = true];
inline int fmi2_import_get_string_req::valuereferences_size() const {
  return valuereferences_.size();
}
inline void fmi2_import_get_string_req::clear_valuereferences() {
  valuereferences_.Clear();
}
inline ::google::protobuf::int32 fmi2_import_get_string_req::valuereferences(int index) const {
  return valuereferences_.Get(index);
}
inline void fmi2_import_get_string_req::set_valuereferences(int index, ::google::protobuf::int32 value) {
  valuereferences_.Set(index, value);
}
inline void fmi2_import_get_string_req::add_valuereferences(::google::protobuf::int32 value) {
  valuereferences_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
fmi2_import_get_string_req::valuereferences() const {
  return valuereferences_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
fmi2_import_get_string_req::mutable_valuereferences() {
  return &valuereferences_;
}

// -------------------------------------------------------------------

// fmi2_import_get_string_res

// required int32 message_id = 1;
inline bool fmi2_import_get_string_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_string_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_string_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_string_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_string_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_string_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// repeated string values = 2;
inline int fmi2_import_get_string_res::values_size() const {
  return values_.size();
}
inline void fmi2_import_get_string_res::clear_values() {
  values_.Clear();
}
inline const ::std::string& fmi2_import_get_string_res::values(int index) const {
  return values_.Get(index);
}
inline ::std::string* fmi2_import_get_string_res::mutable_values(int index) {
  return values_.Mutable(index);
}
inline void fmi2_import_get_string_res::set_values(int index, const ::std::string& value) {
  values_.Mutable(index)->assign(value);
}
inline void fmi2_import_get_string_res::set_values(int index, const char* value) {
  values_.Mutable(index)->assign(value);
}
inline void fmi2_import_get_string_res::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fmi2_import_get_string_res::add_values() {
  return values_.Add();
}
inline void fmi2_import_get_string_res::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
}
inline void fmi2_import_get_string_res::add_values(const char* value) {
  values_.Add()->assign(value);
}
inline void fmi2_import_get_string_res::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
fmi2_import_get_string_res::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
fmi2_import_get_string_res::mutable_values() {
  return &values_;
}

// required .fmitcp_proto.fmi2_status_t status = 3;
inline bool fmi2_import_get_string_res::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_get_string_res::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_get_string_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_get_string_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_get_string_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_get_string_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// char_req

// -------------------------------------------------------------------

// char_res

// -------------------------------------------------------------------

// fmi2_import_get_fmu_state_req

// required int32 message_id = 1;
inline bool fmi2_import_get_fmu_state_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_fmu_state_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_fmu_state_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_fmu_state_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_fmu_state_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_fmu_state_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_get_fmu_state_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_fmu_state_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_fmu_state_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_fmu_state_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_get_fmu_state_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_get_fmu_state_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_fmu_state_res

// required int32 message_id = 1;
inline bool fmi2_import_get_fmu_state_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_fmu_state_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_fmu_state_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_fmu_state_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_fmu_state_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_fmu_state_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 stateId = 2;
inline bool fmi2_import_get_fmu_state_res::has_stateid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_fmu_state_res::set_has_stateid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_fmu_state_res::clear_has_stateid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_fmu_state_res::clear_stateid() {
  stateid_ = 0;
  clear_has_stateid();
}
inline ::google::protobuf::int32 fmi2_import_get_fmu_state_res::stateid() const {
  return stateid_;
}
inline void fmi2_import_get_fmu_state_res::set_stateid(::google::protobuf::int32 value) {
  set_has_stateid();
  stateid_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 3;
inline bool fmi2_import_get_fmu_state_res::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_get_fmu_state_res::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_get_fmu_state_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_get_fmu_state_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_get_fmu_state_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_get_fmu_state_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_set_fmu_state_req

// required int32 message_id = 1;
inline bool fmi2_import_set_fmu_state_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_set_fmu_state_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_set_fmu_state_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_set_fmu_state_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_set_fmu_state_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_set_fmu_state_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_set_fmu_state_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_set_fmu_state_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_set_fmu_state_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_set_fmu_state_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_set_fmu_state_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_set_fmu_state_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// required int32 stateId = 3;
inline bool fmi2_import_set_fmu_state_req::has_stateid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_set_fmu_state_req::set_has_stateid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_set_fmu_state_req::clear_has_stateid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_set_fmu_state_req::clear_stateid() {
  stateid_ = 0;
  clear_has_stateid();
}
inline ::google::protobuf::int32 fmi2_import_set_fmu_state_req::stateid() const {
  return stateid_;
}
inline void fmi2_import_set_fmu_state_req::set_stateid(::google::protobuf::int32 value) {
  set_has_stateid();
  stateid_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_set_fmu_state_res

// required int32 message_id = 1;
inline bool fmi2_import_set_fmu_state_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_set_fmu_state_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_set_fmu_state_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_set_fmu_state_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_set_fmu_state_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_set_fmu_state_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 2;
inline bool fmi2_import_set_fmu_state_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_set_fmu_state_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_set_fmu_state_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_set_fmu_state_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_set_fmu_state_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_set_fmu_state_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_free_fmu_state_req

// required int32 message_id = 1;
inline bool fmi2_import_free_fmu_state_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_free_fmu_state_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_free_fmu_state_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_free_fmu_state_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_free_fmu_state_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_free_fmu_state_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 stateId = 2;
inline bool fmi2_import_free_fmu_state_req::has_stateid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_free_fmu_state_req::set_has_stateid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_free_fmu_state_req::clear_has_stateid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_free_fmu_state_req::clear_stateid() {
  stateid_ = 0;
  clear_has_stateid();
}
inline ::google::protobuf::int32 fmi2_import_free_fmu_state_req::stateid() const {
  return stateid_;
}
inline void fmi2_import_free_fmu_state_req::set_stateid(::google::protobuf::int32 value) {
  set_has_stateid();
  stateid_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_free_fmu_state_res

// required int32 message_id = 1;
inline bool fmi2_import_free_fmu_state_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_free_fmu_state_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_free_fmu_state_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_free_fmu_state_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_free_fmu_state_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_free_fmu_state_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.fmi2_status_t status = 2;
inline bool fmi2_import_free_fmu_state_res::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_free_fmu_state_res::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_free_fmu_state_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_free_fmu_state_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_free_fmu_state_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_free_fmu_state_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// fmi2_import_get_directional_derivative_req

// required int32 message_id = 1;
inline bool fmi2_import_get_directional_derivative_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_directional_derivative_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_directional_derivative_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_directional_derivative_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_directional_derivative_req::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_directional_derivative_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool fmi2_import_get_directional_derivative_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fmi2_import_get_directional_derivative_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fmi2_import_get_directional_derivative_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fmi2_import_get_directional_derivative_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 fmi2_import_get_directional_derivative_req::fmuid() const {
  return fmuid_;
}
inline void fmi2_import_get_directional_derivative_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// repeated int32 v_ref = 3 [packed = true];
inline int fmi2_import_get_directional_derivative_req::v_ref_size() const {
  return v_ref_.size();
}
inline void fmi2_import_get_directional_derivative_req::clear_v_ref() {
  v_ref_.Clear();
}
inline ::google::protobuf::int32 fmi2_import_get_directional_derivative_req::v_ref(int index) const {
  return v_ref_.Get(index);
}
inline void fmi2_import_get_directional_derivative_req::set_v_ref(int index, ::google::protobuf::int32 value) {
  v_ref_.Set(index, value);
}
inline void fmi2_import_get_directional_derivative_req::add_v_ref(::google::protobuf::int32 value) {
  v_ref_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
fmi2_import_get_directional_derivative_req::v_ref() const {
  return v_ref_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
fmi2_import_get_directional_derivative_req::mutable_v_ref() {
  return &v_ref_;
}

// repeated int32 z_ref = 4 [packed = true];
inline int fmi2_import_get_directional_derivative_req::z_ref_size() const {
  return z_ref_.size();
}
inline void fmi2_import_get_directional_derivative_req::clear_z_ref() {
  z_ref_.Clear();
}
inline ::google::protobuf::int32 fmi2_import_get_directional_derivative_req::z_ref(int index) const {
  return z_ref_.Get(index);
}
inline void fmi2_import_get_directional_derivative_req::set_z_ref(int index, ::google::protobuf::int32 value) {
  z_ref_.Set(index, value);
}
inline void fmi2_import_get_directional_derivative_req::add_z_ref(::google::protobuf::int32 value) {
  z_ref_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
fmi2_import_get_directional_derivative_req::z_ref() const {
  return z_ref_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
fmi2_import_get_directional_derivative_req::mutable_z_ref() {
  return &z_ref_;
}

// repeated double dv = 5 [packed = true];
inline int fmi2_import_get_directional_derivative_req::dv_size() const {
  return dv_.size();
}
inline void fmi2_import_get_directional_derivative_req::clear_dv() {
  dv_.Clear();
}
inline double fmi2_import_get_directional_derivative_req::dv(int index) const {
  return dv_.Get(index);
}
inline void fmi2_import_get_directional_derivative_req::set_dv(int index, double value) {
  dv_.Set(index, value);
}
inline void fmi2_import_get_directional_derivative_req::add_dv(double value) {
  dv_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fmi2_import_get_directional_derivative_req::dv() const {
  return dv_;
}
inline ::google::protobuf::RepeatedField< double >*
fmi2_import_get_directional_derivative_req::mutable_dv() {
  return &dv_;
}

// -------------------------------------------------------------------

// fmi2_import_get_directional_derivative_res

// required int32 message_id = 1;
inline bool fmi2_import_get_directional_derivative_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fmi2_import_get_directional_derivative_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fmi2_import_get_directional_derivative_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fmi2_import_get_directional_derivative_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 fmi2_import_get_directional_derivative_res::message_id() const {
  return message_id_;
}
inline void fmi2_import_get_directional_derivative_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// repeated double dz = 2 [packed = true];
inline int fmi2_import_get_directional_derivative_res::dz_size() const {
  return dz_.size();
}
inline void fmi2_import_get_directional_derivative_res::clear_dz() {
  dz_.Clear();
}
inline double fmi2_import_get_directional_derivative_res::dz(int index) const {
  return dz_.Get(index);
}
inline void fmi2_import_get_directional_derivative_res::set_dz(int index, double value) {
  dz_.Set(index, value);
}
inline void fmi2_import_get_directional_derivative_res::add_dz(double value) {
  dz_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
fmi2_import_get_directional_derivative_res::dz() const {
  return dz_;
}
inline ::google::protobuf::RepeatedField< double >*
fmi2_import_get_directional_derivative_res::mutable_dz() {
  return &dz_;
}

// required .fmitcp_proto.fmi2_status_t status = 3;
inline bool fmi2_import_get_directional_derivative_res::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fmi2_import_get_directional_derivative_res::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fmi2_import_get_directional_derivative_res::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fmi2_import_get_directional_derivative_res::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fmitcp_proto::fmi2_status_t fmi2_import_get_directional_derivative_res::status() const {
  return static_cast< ::fmitcp_proto::fmi2_status_t >(status_);
}
inline void fmi2_import_get_directional_derivative_res::set_status(::fmitcp_proto::fmi2_status_t value) {
  assert(::fmitcp_proto::fmi2_status_t_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// get_xml_req

// required int32 message_id = 1;
inline bool get_xml_req::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void get_xml_req::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void get_xml_req::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void get_xml_req::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 get_xml_req::message_id() const {
  return message_id_;
}
inline void get_xml_req::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required int32 fmuId = 2;
inline bool get_xml_req::has_fmuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void get_xml_req::set_has_fmuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void get_xml_req::clear_has_fmuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void get_xml_req::clear_fmuid() {
  fmuid_ = 0;
  clear_has_fmuid();
}
inline ::google::protobuf::int32 get_xml_req::fmuid() const {
  return fmuid_;
}
inline void get_xml_req::set_fmuid(::google::protobuf::int32 value) {
  set_has_fmuid();
  fmuid_ = value;
}

// -------------------------------------------------------------------

// get_xml_res

// required int32 message_id = 1;
inline bool get_xml_res::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void get_xml_res::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void get_xml_res::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void get_xml_res::clear_message_id() {
  message_id_ = 0;
  clear_has_message_id();
}
inline ::google::protobuf::int32 get_xml_res::message_id() const {
  return message_id_;
}
inline void get_xml_res::set_message_id(::google::protobuf::int32 value) {
  set_has_message_id();
  message_id_ = value;
}

// required .fmitcp_proto.jm_log_level_enu_t logLevel = 2;
inline bool get_xml_res::has_loglevel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void get_xml_res::set_has_loglevel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void get_xml_res::clear_has_loglevel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void get_xml_res::clear_loglevel() {
  loglevel_ = 0;
  clear_has_loglevel();
}
inline ::fmitcp_proto::jm_log_level_enu_t get_xml_res::loglevel() const {
  return static_cast< ::fmitcp_proto::jm_log_level_enu_t >(loglevel_);
}
inline void get_xml_res::set_loglevel(::fmitcp_proto::jm_log_level_enu_t value) {
  assert(::fmitcp_proto::jm_log_level_enu_t_IsValid(value));
  set_has_loglevel();
  loglevel_ = value;
}

// required string xml = 3;
inline bool get_xml_res::has_xml() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void get_xml_res::set_has_xml() {
  _has_bits_[0] |= 0x00000004u;
}
inline void get_xml_res::clear_has_xml() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void get_xml_res::clear_xml() {
  if (xml_ != &::google::protobuf::internal::kEmptyString) {
    xml_->clear();
  }
  clear_has_xml();
}
inline const ::std::string& get_xml_res::xml() const {
  return *xml_;
}
inline void get_xml_res::set_xml(const ::std::string& value) {
  set_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    xml_ = new ::std::string;
  }
  xml_->assign(value);
}
inline void get_xml_res::set_xml(const char* value) {
  set_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    xml_ = new ::std::string;
  }
  xml_->assign(value);
}
inline void get_xml_res::set_xml(const char* value, size_t size) {
  set_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    xml_ = new ::std::string;
  }
  xml_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* get_xml_res::mutable_xml() {
  set_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    xml_ = new ::std::string;
  }
  return xml_;
}
inline ::std::string* get_xml_res::release_xml() {
  clear_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xml_;
    xml_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void get_xml_res::set_allocated_xml(::std::string* xml) {
  if (xml_ != &::google::protobuf::internal::kEmptyString) {
    delete xml_;
  }
  if (xml) {
    set_has_xml();
    xml_ = xml;
  } else {
    clear_has_xml();
    xml_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fmitcp_proto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_fmitcp_2eproto__INCLUDED
