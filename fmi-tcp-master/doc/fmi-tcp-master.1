.TH FMI-TCP-MASTER 1 local
.SH NAME
fmi-tcp-master \- simulate FMUs
.SH SYNOPSIS
.ll +8
.B fmi-tcp-master
.RB [ " \-xrlvqhtcdsopfmgwCj5FNMa " ]
[
.I "URLs \&..."
]
.ll -8
.br
.SH DESCRIPTION
.I fmi-tcp-master
simulates FMUs using the FMILibrary from JModelica.org
over TCP/IP, with optional strong coupling between simulation units.
.SH FLAGS
.TP
.B \-h
Show help and quit.
.TP
.B \-l
Show FMILibrary logs.
.TP
.B \-q
Quiet mode, do not print simulation info to STDOUT. This flag should be used together with -r.
.TP
.B \-r
Real time mode. Will usleep() in between communication steps if the execution was faster than real time.
.TP
.B \-v
Show version and quit.
.TP
.B \-x
Print XML and quit.
.TP
.B \-N
Make kinematic connectors nonholonomic rather than holonomic.
In other words, only lock spatial/angular velocities, not positions or angles.
.SH OPTIONS
First note that some options specify lists of values.
These can either be specified as colon separated lists (like "-w 0:1:0") in one long option, or multiple times for each one ("-w 0 -w 1 -w 0"), or any combination of the two ("-w 0 -w 1:0").
This is convenient when building command lines in script, especially when lengthy strong connection specifications (-C) are involved. 
.TP
.B \-w [VISIBILITIES]
Visibility specification list. Specifies which FMUs should show their simulator application windows. Syntax is

    -w VIS0:VIS1:VIS2...

where VISX is 1 or 0 depending on whether FMUX's window should be shown or not.
Example:

    -w 0:1:1:0

which means: show simulator windows for FMU1 and FMU2, but not FMU0 or FMU3.
Note that multiple "-w"'s can be used to break up a list:

    -w 0 -w 1 -w 1 -w 0

Unlike -p, -c and -C order is significant for visibility lists. The following is *not* equivalent to the previous example:

    -w 1 -w 1 -w 0 -w 0

By default no windows are shown (batch mode).
.TP
.B \-g [STEPPING ORDER SPEC]
FMU stepping order list. Used in serial algorithms. Should be a comma separated list of FMU indices. If the list starts with 0, then the first FMU will be stepped, and its output values will be transferred through their connections (if any).
Example:

    -g 0,2,1

Which means: step FMU0 -> FMU2 -> FMU1.
Like other lists stepping order lists can also be broken up. This is equivalent to the previous example:

    -g 0 -g 2 -g 1

Order is significant, just like visibility lists. If no -g is specified then FMUs are stepped in numerical order (FMU0 -> FMU1 -> FMU2 etc.).
.TP
.B \-c [WEAK CONNECTIONS]
Weak connection specification list. Represents which FMU and value reference to connect from and what to connect to. Syntax is

    -c WCONN1:WCONN2:WCONN3...

where the syntax of each WCONNX is as follows:

    WCONNX=[TYPE,]FMUFROM,VRFROM,FMUTO,VRTO.

TYPE is a single character specifying the value type on the connection.
If TYPE is absent then the connection is assumed to be of type real.
Possible types:

    r - Real
    i - Integer
    b - Boolean
    s - String

FMUFROM and FMUTO are the indexes of the FMUs to read values from and to respectively.
VRFROM and VRTO are the corresponding value references. Example:

    -c 0,0,1,0:r,0,1,1,1:i,0,1,1,2

This means: connect real values FMU0 (value reference 0) to FMU1 (vr 0) and FMU0 (vr 1) to FMU1 (vr 1), and connect integer value FMU0 (vr 1) to FMU1 (vr 2).
This is a little hard to read though, so breaking connection lists with multiple "-c"'s is recommended.
Weak connections can also be specified in any order, so the following specifies the exact same set of connections:

    -c i,0,1,1,2 -c 0,1,1,1 -c r,0,0,1,0

Default is no connections.
.TP
.B \-p [PARAMS]
Parameter specification list. Specifies parameters to send to FMUs before initialization. Format is:

    -p PARAM1:PARAM2:PARAM3...

where each PARAMX has the following syntax:

    PARAMX=[TYPE,]FMU,VR,VALUE

If type is not specified then real values are assumed, just like with weak connections.
Example:

    -p b,0,0,true:r,0,0,0:s,0,0,hello

which means set FMU0 boolean VR0 to true, FMU0 real VR0 to zero and FMU0 string VR0 to "hello".
Note that despite identical value references these entries refer to different parameters since VRs apply with respect to a base type.
See -c option for a list of possible types (i, r, s, b).
Parameters can be specified in any order, and like all lists they can be broken up, so the following specifies the exact same set of parameters:

    -p s,0,0,hello -p b,0,0,true -p 0,0,0

Default is no parameters.
.TP
.B \-C [STRONG CONNECTIONS]
Strong coupling specification. Syntax is

    -C SCONN1:SCONN2:SCONN3...

where SCONNX has the following syntax:

    SCONNX=TYPE,FMU0,FMU1,[PARAMS]

FMU0 and FMU1 are the two sides of the strong coupling.
PARAMS depend on TYPE, and TYPE is the type of connection:

    [ball|lock]:
        PARAMS=pos0,acc0,force0,quat0,angAcc0,torque0,pos1,acc1,force1,quat1,angAcc1,torque1
        
        where posX/accX/forceX/angAccX/torqueX are VR triplets (X,Y,Z) and quatX are VR quadruplets (X,Y,Z,W), giving a total of (3+3+3+4+3+3) x 2 = 38 value references.

        The difference between "ball" and "lock" is that lock tries to lock the orientation of both connectors (ball only cares about position). 

    shaft:
        PARAMS=shaftAngle0,angularVelocity0,angularAcceleration0,torque0,shaftAngle1,angularVelocity1,angularAcceleration1,torque1

        The connection tries to keep both shaftAngles equal.

Examples:

    -C\ shaft,0,1,20,19,14,17,20,19,14,17

Meaning: Connect a shaft between FMU0 and FMU1, with VRs shaftAngle=20, angularVelocity=19, angularAcceleration=14 and torque=17 on both sides

    -C\ lock,0,1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18

Meaning: Create a lock constraints between FMU0 and FMU1 with VRs pos={0,1,2}, acc={3,4,5}, force={6,7,8}, quat={9,10,11,12}, angAcc={13,14,15} and torque={16,17,18} on both sides.

Note that like all lists you can concatenate the strong connection specifications with colon characters, but the result is hardly readable:

    -C\ shaft,0,1,20,19,14,17,20,19,14,17:lock,0,1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18:ball,1,2,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18

Default is no strong connections. Specifying strong connections is incompatible with using the Gauss-Seidel stepper (-m gs).
.TP
.B \-j [JSON filename]
Connection configuration file. Used to automatically connect inputs/outputs with specified names, and to assign default values to inputs when no suitable output is found.
.TP
.B \-d [TIMESTEP]
Timestep size. Default is 0.1.
.TP
.B \-f [OUTFORMAT]
Output file format. Currently only "csv" is supported, and it is also the default.
.TP
.B \-m [METHOD]
Stepping method. Available methods are "jacobi" (Jacobi, parallel) and "gs" (Gauss-Seidel, serial). Default is "jacobi".
When strong coupling is used only "jacobi" is possible.
.TP
.B \-o [OUTFILE]
Result output file. Default is STDOUT.
.TP
.B \-s [SEPARATOR]
CSV separator character. Default is comma (,).
.TP
.B \-t [ENDTIME]
End simulation time in seconds. Default is 1.0.
.TP
.B \-5 [HDF5FILENAME]
Dump timing information to HDF5 file with given filename.
.TP
.B \-F [FIELDNAMEFILENAME]
Dump space separated output column names in file with given name, matching the columns in the CSV output.
This is useful for generating .ssv files for plotting with tikz.
.TP
.B \-M [COMPLIANCE]
Set compliance for kinematic solver (real value, default = 0.0).
.TP
.B \-a [ARGSFILENAME]
Add extra arguments parsed from file with given name, or stdin if filename is -.
This is useful for large systems where the total size of the connection specification exceeds the operating system's limit for program arguments (2 KiB of Windows).
The arguments in the file may be separated by anything std::ifstream::operator>>(std::string) considers a white space (space, newline, tab etc.).
The parsed tokens effectively replace the "-a [ARGSFILENAME]" in the list of arguments.
Recursive files are not allowed - if the argument file itself contains a "-a" token then the program stops.
Example:

    fmi-tcp-master -t 100 -a args -p 0,1,123

Contents of file args:

    -C shaft,0,1,0,1,2,3,0,1,2,3
    -C shaft,1,2,6,7,8,9,0,1,2,3
    -c 2,1,0,6

Resulting equivalent command line:

    fmi-tcp-master -t 100 -C shaft,0,1,0,1,2,3,0,1,2,3 -C shaft,1,2,6,7,8,9,0,1,2,3 -c 2,1,0,6 -p 0,1,123

stdin example producing the same command line (bash style here-document):

    fmi-tcp-master -t 100 -a - -p 0,1,123 << EOF
    -C shaft,0,1,0,1,2,3,0,1,2,3
    -C shaft,1,2,6,7,8,9,0,1,2,3
    -c 2,1,0,6
    EOF

.SH URLs
Each URL specifies the address and TCP port of an FMU. The syntax is:

    tcp://<address>:<port>

Examples:

    tcp://localhost:3000
    tcp://192.168.0.2:3000
 
.SH EXAMPLES
To run an FMU simulation from time 0 to 5 with timestep 0.01:
    fmi-tcp-master -t 5 -d 0.01 tcp://localhost:3000

To simulate two FMUs connected from the first output of the first FMU to the first input of the second:
    fmi-tcp-master -c 0,0,1,0 tcp://localhost:3000 tcp://localhost:3001

Simulating four strongly coupled spring systems for 100 s at 100 Hz and writing the result to a CSV file:

    fmi-tcp-master -t 100 -d 0.01\\
        -p 0,3,0 -p 0,0,0:0,6,1 -p 0,9,2 -p 1,0,1:1,6,2 -p 1,3,2 -p 1,9,2 -p 2,0,2:2,6,3 -p 2,3,2 -p 2,9,2 -p 3,0,3:3,6,4\\
        -C ball,0,1,6,16,16,8,16,16,10,16,16,16,16,16,16,16,16,16,16,16,16,0,16,16,2,16,16,4,16,16,16,16,16,16,16,16,16,16,16,16\\
        -C ball,1,2,6,16,16,8,16,16,10,16,16,16,16,16,16,16,16,16,16,16,16,0,16,16,2,16,16,4,16,16,16,16,16,16,16,16,16,16,16,16\\
        -C ball,2,3,6,16,16,8,16,16,10,16,16,16,16,16,16,16,16,16,16,16,16,0,16,16,2,16,16,4,16,16,16,16,16,16,16,16,16,16,16,16\\
        tcp://localhost:3000 tcp://localhost:3001 tcp://localhost:3002 tcp://localhost:3003 > results/output-N4-h0.01.csv

.SH "ABOUT"
The app was built by Stefan Hedman at UMIT Research Lab 2013. Large parts were rewritten by Tomas Härdin at UMIT Research Lab 2014.